<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Golang | DAY's Blog</title><meta name="keywords" content="Notes,Language,DataBase"><meta name="author" content="santidad DAY"><meta name="copyright" content="santidad DAY"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Golang（又称Go语言）是一种由Google开发的开源编程语言，它结合了静态语言的安全性和动态语言的高效性。Golang的语法简单明了，易于学习和使用，同时它还有着出色的并发编程和内存管理能力，因此被广泛应用于网络编程、云计算、分布式系统等领域。">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang">
<meta property="og:url" content="https://santidadday.github.io/2022/02/15/Golang/index.html">
<meta property="og:site_name" content="DAY&#39;s Blog">
<meta property="og:description" content="Golang（又称Go语言）是一种由Google开发的开源编程语言，它结合了静态语言的安全性和动态语言的高效性。Golang的语法简单明了，易于学习和使用，同时它还有着出色的并发编程和内存管理能力，因此被广泛应用于网络编程、云计算、分布式系统等领域。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://5b0988e595225.cdn.sohucs.com/images/20190127/98d2709000f649198967eb6e91d26a1a.jpeg">
<meta property="article:published_time" content="2022-02-14T16:00:00.000Z">
<meta property="article:modified_time" content="2023-03-14T13:26:52.000Z">
<meta property="article:author" content="santidad DAY">
<meta property="article:tag" content="Notes">
<meta property="article:tag" content="Language">
<meta property="article:tag" content="DataBase">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://5b0988e595225.cdn.sohucs.com/images/20190127/98d2709000f649198967eb6e91d26a1a.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://santidadday.github.io/2022/02/15/Golang/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Golang',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-14 21:26:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/day.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">17</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">DAY's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Golang</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">Created</span><time datetime="2022-02-14T16:00:00.000Z" title="Created 2022-02-15 00:00:00">2022-02-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Golang"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="Go语言的特点"><a href="#Go语言的特点" class="headerlink" title="Go语言的特点"></a>Go语言的特点</h3><p>Go语言保证了既能达到<strong>静态编译语言</strong>的安全和性能，又达到了<strong>动态语言开发维护的高效率</strong></p>
<ol>
<li>从C语言中继承的很多理念，包括表达式语法，控制结构，基础数据类型，调用参数传值，<strong>指针</strong>等，也保留了和C语言一样的编译执行方式及弱化的指针</li>
<li>引入了包的概念，用于组织程序结构，Go语言的<strong>一个文件都要归于一个包</strong>，而不是单独存在</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main <span class="comment">//一个Go文件需要在一个包里</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//输出一句话</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>垃圾回收机制，内存自动回收，不需要开发人员管理</p>
</li>
<li><p>天然并发：</p>
<ul>
<li>从语言层面支持并发，实现简单</li>
<li>Goroutine，轻量级线程，<strong>可实现大并发处理，高效利用多核</strong></li>
<li>基于CPS并发模型（Communicating Sequential Processes）实现</li>
</ul>
</li>
<li><p>吸收了管道通信机制，形成Go语言特有的管道channel</p>
<p>通过管道channel，可以实现不同的Goroute之间的互相通讯</p>
</li>
<li><p>函数返回多个值</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写一个函数，实现同时返回 和，差</span></span><br><span class="line"><span class="comment">//Go函数支持返回多个值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSumAndSub</span><span class="params">(n1 <span class="type">int</span>, n2 <span class="type">int</span>)</span></span>(<span class="type">int</span>, <span class="type">int</span>)&#123;</span><br><span class="line">  sum := n1 + n2 <span class="comment">//Go语言后面不用带分号</span></span><br><span class="line">  sub := n1 + n2</span><br><span class="line">  <span class="keyword">return</span> sum,sub</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>新的创新：切片，延迟执行defer等</li>
</ol>
<hr>
<h2 id="Go语言的快速开发入门"><a href="#Go语言的快速开发入门" class="headerlink" title="Go语言的快速开发入门"></a>Go语言的快速开发入门</h2><h3 id="Go语言的开发步骤"><a href="#Go语言的开发步骤" class="headerlink" title="Go语言的开发步骤"></a>Go语言的开发步骤</h3><p><strong>目录结构</strong></p>
<p>GoProject&#x2F;src&#x2F;Go_Code&#x2F;Project01&#x2F;main&#x2F;hello.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要求开发一个hellow.go，可以输出“hello, world!”</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello,world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Go文件的后缀是.go</p>
</li>
<li><p>package main表示hello.go文件所在包是main，在go中，每个文件必须归属于一个包</p>
</li>
<li><p>import “fmt”表示：引入一个<strong>包</strong>，包名fmt，引入该包后，就可以使用fmt包的函数</p>
</li>
<li><p>func main(){</p>
<p>}       func是一个<strong>关键字</strong>，表示一个<strong>函数</strong>，main是<strong>函数名</strong></p>
</li>
<li><p>fmt.Println(“hello,world!”)表示调用fmt包里的函数，输出hello,world!</p>
</li>
<li><p>通过 go build 命令（在dos中执行）对该go文件进行<strong>编译</strong>，生成.exe文件</p>
</li>
<li><p>运行.exe文件即可</p>
</li>
</ul>
<h3 id="Go的执行流程"><a href="#Go的执行流程" class="headerlink" title="Go的执行流程"></a>Go的执行流程</h3><p><strong>.go文件</strong>  —-（编译）—-&gt;<strong>可执行文件（.exe）</strong>—-（运行）—-&gt;<strong>结果</strong></p>
<ul>
<li>如果我们先编译生成可执行文件，那么我们可以将该可执行文件拷贝到没有go开发环境的机器上，仍然可以运行</li>
<li>如果我们是直接go run go源代码，那么如果在另一台机器上这么运行，也需要go开发环境，否则无法执行</li>
<li>在编译时，编译器将程序运行依赖的库文件包含在可执行文件中，所以可执行文件会变大很多</li>
</ul>
<h3 id="Go开发注意事项"><a href="#Go开发注意事项" class="headerlink" title="Go开发注意事项"></a>Go开发注意事项</h3><ul>
<li>Go原文家以“go”为扩展名</li>
<li>Go应用程序的执行入口时main()方法</li>
<li>Go语言<strong>严格区分大小写</strong></li>
<li>Go方法由一条条语句构成，每条语句后面不带分号</li>
<li>Go编译器时一行行进行编译的，不可将多条语句写入同一行</li>
<li>Go语言<strong>定义的变量或者import的包</strong>如果没有使用到，代码编译不能通过</li>
<li>大括号成对出现缺一不可</li>
</ul>
<h3 id="Go语言的转义字符"><a href="#Go语言的转义字符" class="headerlink" title="Go语言的转义字符"></a>Go语言的转义字符</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//     \t  :一个制表位，实现对齐功能</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	fmt.Println(<span class="string">&quot;tom\tjack&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：tom	jack</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//     \n  :换行符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	fmt.Println(<span class="string">&quot;hello\nworld&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：hello</span></span><br><span class="line"><span class="comment">//         world</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//     \\  :一个\</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	fmt.Println(<span class="string">&quot;D:\\Go\\Code&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：D:\Go\Code</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//     \&quot;  :一个&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	fmt.Println(<span class="string">&quot;tom说\&quot;i love you\&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：tom说&quot;i love you&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//     \r  :回车</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	fmt.Println(<span class="string">&quot;天龙八部\r雪山飞狐&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：雪山飞狐</span></span><br><span class="line"><span class="comment">//回车不换行，跟着本行最开始进行</span></span><br></pre></td></tr></table></figure>

<h3 id="Go语言注释（comment）"><a href="#Go语言注释（comment）" class="headerlink" title="Go语言注释（comment）"></a>Go语言注释（comment）</h3><p>介绍：用于注释说明解释程序的文字就是注释，注释是为了<strong>提高代码的阅读性</strong>；注释是一个程序员必须要有的良好编程习惯。将自己的思想通过注释先整理出来，再用代码去提现</p>
<h4 id="注释类型"><a href="#注释类型" class="headerlink" title="注释类型"></a>注释类型</h4><ul>
<li>行注释</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注释内容</span></span><br><span class="line"><span class="comment">// ctrl+/：可以进行多行注释</span></span><br></pre></td></tr></table></figure>

<ul>
<li>块注释</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*注释内容（一次可注释多行，不可嵌套）*/</span></span><br></pre></td></tr></table></figure>

<h3 id="规范的代码风格"><a href="#规范的代码风格" class="headerlink" title="规范的代码风格"></a>规范的代码风格</h3><p>正确的注释和注释风格：推荐使用<strong>行注释</strong>来注释整个方法和语句</p>
<p>正确的缩进和空白：shift+tab整体向左移动，tab整体向右移动</p>
<p>运算符两边各加一个空格</p>
<h3 id="Golang标准库API文档"><a href="#Golang标准库API文档" class="headerlink" title="Golang标准库API文档"></a>Golang标准库API文档</h3><ul>
<li>API(Application Programming Interface 应用程序编程接口)是Golang提供的基本的编程接口</li>
<li>Go语言提供了大量的标准库，因此google公司也为标准库提供了相应的API文档，用于告诉开发猪如何使用这些标准库，以及标准库包含的方法</li>
<li>Golang中文网在线标准库文档:<a target="_blank" rel="noopener" href="https://studygolang.com/pkgdoc">Golang标准库文档</a></li>
</ul>
<hr>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量相当于内存中的一个数据存储空间的表示</p>
<p><strong>变量的使用步骤：</strong></p>
<ol>
<li>变量的声明（定义变量）</li>
<li>变量赋值</li>
<li>变量使用</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//定义变量</span></span><br><span class="line">	<span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">	i = <span class="number">10</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;i = &quot;</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>变量表示内存中的一个存储区域</li>
<li>该区有自己的<strong>名称（变量名）和类型（数据类型）</strong></li>
<li>Golang变量使用的三种方式<ul>
<li>指定变量类型，声明后若不赋值，使用默认值</li>
<li>根据值自行判断变量类型（类型推导）</li>
<li>省略var，注意  :&#x3D;  左侧的变量不应该是已经申明过的，否则导致编译错误</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//Golang的变量使用当时</span></span><br><span class="line">    <span class="comment">//指定变量类型，声明后若不赋值，使用默认值</span></span><br><span class="line">	<span class="comment">//int的默认值是0</span></span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;i = &quot;</span>, i)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据值自行判断变量类型（类型推导）</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">10.11</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;num = &quot;</span>, num)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略var，注意  :=  左侧的变量不应该是已经申明过的，否则导致编译错误</span></span><br><span class="line">    <span class="comment">// :=的: 不能省略 </span></span><br><span class="line">    name := <span class="string">&quot;tom&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;name = &quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：i =  0</span></span><br><span class="line"><span class="comment">//         num =  10.11</span></span><br><span class="line"><span class="comment">//         name =  tom </span></span><br></pre></td></tr></table></figure>

<ul>
<li>多变量声明：在编程中，我们需要<strong>一次性声明多个变量</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Golang中一次性声明多的变量</span></span><br><span class="line">    <span class="keyword">var</span> n1, n2, n3 <span class="type">int</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;n1 = &quot;</span>, n1, <span class="string">&quot;n2 = &quot;</span>, n2, <span class="string">&quot;n3 = &quot;</span>, n3)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> n4, name, n5 = <span class="number">100</span>, <span class="string">&quot;tom&quot;</span>, <span class="number">888</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;n4 = &quot;</span>, n4, <span class="string">&quot;name = &quot;</span>, name, <span class="string">&quot;n5 = &quot;</span>, n5)</span><br><span class="line">  </span><br><span class="line">  	n6, n7 := <span class="number">10</span>, <span class="number">200</span> </span><br><span class="line"> 	fmt.Println(<span class="string">&quot;n6 = &quot;</span>, n6, <span class="string">&quot;n7 = &quot;</span>, n7)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：n1 =  0 n2 =  0 n3 =  0</span></span><br><span class="line"><span class="comment">//         n4 =  100 name =  tom n5 =  888</span></span><br><span class="line"><span class="comment">//         n6 = 10 n7 = 200</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一次声明多个全局变量</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">  	n1 = <span class="number">300</span></span><br><span class="line">  	n2 = <span class="number">400</span></span><br><span class="line">  	name = <span class="string">&quot;tom&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	fmt.Println(<span class="string">&quot;n1 = &quot;</span>, n1, <span class="string">&quot;n2 = &quot;</span>, n2, <span class="string">&quot;name = &quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：n1 =  300 n2 =  400 name =  tom</span></span><br></pre></td></tr></table></figure>

<ul>
<li>该区域的数值可以在同一类型范围内不断变化</li>
<li>变量在同一作用域内不能重名</li>
<li>变量 &#x3D; 变量名 + 值 + 数据类型</li>
<li>Golang的变量如果没有赋初值，编译器会使用默认值</li>
</ul>
<h3 id="程序中-的使用"><a href="#程序中-的使用" class="headerlink" title="程序中 + 的使用"></a>程序中 + 的使用</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="comment">//数据类型做加法运算</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> r = i + j</span><br><span class="line">    fmt.Println(<span class="string">&quot;r = &quot;</span>, r)</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//字符串类型做拼接</span></span><br><span class="line">    <span class="keyword">var</span> str1 = <span class="string">&quot;hello&quot;</span></span><br><span class="line">    <span class="keyword">var</span> str2 = <span class="string">&quot;world&quot;</span></span><br><span class="line">    <span class="keyword">var</span> res = str1 + str2</span><br><span class="line">    fmt.Println(<span class="string">&quot;res = &quot;</span>, res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：r =  3</span></span><br><span class="line"><span class="comment">//         res =  helloworld</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul>
<li>常量使用const修改</li>
<li>常量在定义的时候，必须初始化</li>
<li>常量不能修改</li>
<li>常量只能修饰bool、数值类型（int、float类型）、string类型</li>
<li>语法：const indentifier [type] &#x3D; value</li>
</ul>
<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>比较简单的写法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>还有一种专业的写法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">a = <span class="literal">iota</span></span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">)</span><br><span class="line"><span class="comment">//a为0，b为1，c为2.没行提升1，同一行不提升</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Golang中<strong>没有常量名必须字母大写的规范</strong>，比如TAX_RATE</li>
<li>仍然通过首字母的大小写来控制常量的访问范围</li>
</ul>
<hr>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p><strong>整数类型分类：</strong></p>
<ul>
<li>int8：有符号，占存储空间1字节，表示范围-128~127</li>
<li>int16：有符号，占存储空间2字节，表示范围-2^15^~2^15^-1</li>
<li>int32：有符号，占存储空间4字节，表示范围-2^31^~2^31^-1</li>
<li>int64：有符号，占存储空间8字节，表示范围-2^63^~2^63^-1</li>
<li>uint8：无符号，占存储空间1字节，表示范围0~255</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span> = <span class="number">1</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;i = &quot;</span>, i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> j <span class="type">int</span> = <span class="number">127</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;j = &quot;</span>, j)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> k <span class="type">uint8</span> = <span class="number">0</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;k = &quot;</span>, k)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：i = 1</span></span><br><span class="line"><span class="comment">//         j = 127</span></span><br><span class="line"><span class="comment">//         k = 0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>byte：无符号，占存储空间1字节，表示范围0~255，处理字符</li>
<li>rune：有符号，占存储空间4字节，表示范围-2^31^~2^31^-1，处理中文</li>
</ul>
<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>Golang各整数类型分：<strong>有符号和无符号</strong>，int unit的大小和系统有关</li>
<li>Golang的整型默认声明为int型</li>
<li>如何在程序查看某变量的<strong>字节大小和数据类型</strong></li>
<li>Golang程序中整型变量在使用时，遵守保小不保大的原则，即：在保证程序正确运行下，尽量使用占用空间小的数据类型</li>
<li><strong>bit：计算机中最小的存储单位。byte：计算机中基本的存储单元</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如何查看一个变量的格式</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;i 的类型是%T, i 占用的字节数是%d&quot;</span>, i, unsafe.Sizeof(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小数类型-x2F-浮点类型"><a href="#小数类型-x2F-浮点类型" class="headerlink" title="小数类型&#x2F;浮点类型"></a>小数类型&#x2F;浮点类型</h3><p><strong>基本介绍：</strong>小数类型就是用于存放小数的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> price <span class="type">float32</span> = <span class="number">89.12</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;price = &quot;</span>, price)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小数类型分类：</strong></p>
<ul>
<li>单精度float32：占用空间4字节，表示范围-3.403E38~3.403E38</li>
<li>双精度float64：占用空间8字节，表示范围-1.798E308~1.798E308</li>
</ul>
<p>说明：</p>
<ul>
<li>关于浮点数在机器中存在的形式简单说明，<strong>浮点数&#x3D;符号位+指数位+尾数位</strong>（说明所有浮点数都是有符号位的）</li>
<li>尾数部分可能会丢失，造成精度损失</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num1 <span class="type">float32</span> = <span class="number">-0.00089</span></span><br><span class="line">    <span class="keyword">var</span> num2 <span class="type">float32</span> = <span class="number">-7809656.09</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;num1 = &quot;</span>, num1, <span class="string">&quot;num2 = &quot;</span>, num2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//精度损失</span></span><br><span class="line">    <span class="keyword">var</span> num3 <span class="type">float32</span> = <span class="number">-123.0000901</span></span><br><span class="line">    <span class="keyword">var</span> num4 <span class="type">float64</span> = <span class="number">-123.0000901</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;num3 = &quot;</span>, num3, <span class="string">&quot;num4 = &quot;</span>, num4)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果:num1 =  -0.00089 num2 =  -7.809656e+06</span></span><br><span class="line"><span class="comment">//        num3 =  -123.00009 num4 =  -123.0000901</span></span><br><span class="line"><span class="comment">//如果希望保存精度更高的数，选用float64</span></span><br></pre></td></tr></table></figure>

<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>Golang浮点类型有固定的范围和字节长度，不受具体OS的影响(注意：Golang中没有float，只有float32和float64)</li>
<li>Golang的浮点型默认声明为float64</li>
<li>浮点型常量有两种表示形式<ul>
<li>十进制数形式，如：5.12</li>
<li>科学计数法形式，如：5.1234e2 &#x3D; 5.12*10^2^</li>
</ul>
</li>
<li>通常情况下，应该用float64，因为它比float32更健康</li>
</ul>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p><strong>基本介绍：Golang没有专门的字符类型</strong>，如果需要存储单个字符（字母），一般使用byte来保存</p>
<p>字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是有单个字节连接起来的。也就是说对于传统的字符串是有字符组成的，而<strong>Go的字符串不同，它是由字节组成的</strong> </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c1 <span class="type">byte</span> = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> c2 <span class="type">byte</span> = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    <span class="comment">//当我们直接输出byte值时，就输出对应的字符的码值</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;c1 = &quot;</span>, c1, <span class="string">&quot;c2 = &quot;</span>, c2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：c1 =  97 c2 =  48</span></span><br></pre></td></tr></table></figure>

<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>字符常量是用单引号(‘ ‘)括起来的单个字符</li>
<li>Go中允许使用转义字符’&#39;将其后的转义字符变为特殊字符常量</li>
<li>Go语言的字符使用UTF-8编码</li>
<li>在Go中，字符的本质是一个整数，直接输出时，是该字符对应的UTF-8编码的码值</li>
<li>可以直接给某个变量附一个数字，然后按格式化输出时%c，会输出改数字对应的unicode字符</li>
<li>字符类型是可以进行运算的，相当于一个整数，因为他都对应有<strong>Unicode码</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//var c3 byte = &#x27;北&#x27;  </span></span><br><span class="line">    <span class="keyword">var</span> c3 <span class="type">int</span> = <span class="string">&#x27;北&#x27;</span>   <span class="comment">//overflow溢出</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;c3 = %c c3对应的码值 = %d\n&quot;</span>, c3, c3)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以直接给出某个变量赋一个数字，然后按格式化输出时%c，会输出改数字对应的Unicode字符</span></span><br><span class="line">    <span class="keyword">var</span> c4 <span class="type">int</span> = <span class="number">22269</span>  <span class="comment">// 22269-&gt;&#x27;国&#x27;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;c4 = %c\n&quot;</span>, c4)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符类型是可以进行运算，相当于一个整数，运输时是按照码值运行</span></span><br><span class="line">    <span class="keyword">var</span> n1 = <span class="number">10</span> + <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;n1 = &quot;</span>, n1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：c3 = 北 c3对应的码值 = 21271</span></span><br><span class="line"><span class="comment">//         c4 = 国</span></span><br><span class="line"><span class="comment">//         n1 = k </span></span><br></pre></td></tr></table></figure>

<p><strong>字符类型的本质探讨</strong></p>
<ul>
<li>字符型存储到计算机中，需要将字符对应的码值（整数）找出来<ul>
<li>存储：字符-&gt;对应码值-&gt;二进制-&gt;存储</li>
<li>读取：二进制-&gt;码值-&gt;字符-&gt;读取</li>
</ul>
</li>
<li>字符和码值的对应关系是通过字符编码表决定的（规定好的）</li>
<li>Go语言的编码统一成了<strong>UTF-8</strong>。方便切统一，没有乱码困扰</li>
</ul>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p><strong>基本介绍：</strong></p>
<ul>
<li>布尔类型也叫bool类型，bool类型<strong>只允许取值true和false</strong></li>
<li>bool类型占1个字节</li>
<li>boolean类型适于<strong>逻辑运算</strong>，一般用于程序流程控制</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="literal">false</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;b = &quot;</span>, b)</span><br><span class="line">    fmt.Println(<span class="string">&quot;b占用的空间为&quot;</span>, unsafe.Sizeof(b))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：b =  false</span></span><br><span class="line"><span class="comment">//         b占用的空间为 1</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p><strong>基本介绍：</strong>字符串就是一串固定长度的字符连接起来的<strong>字符序列</strong>，Go的字符串是有单个字节连接起来的。Go语言的字符串的的字节使用UTF-8编码表示UniCode文本</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> address <span class="type">string</span> = <span class="string">&quot;北京长城 110 hello world&quot;</span></span><br><span class="line">    fmt.Println(address)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：北京长城 110 hello world</span></span><br></pre></td></tr></table></figure>

<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li><p>Go语言的字符串的字节使用UTF-8编码表示UniCode文本，这样Golang统一使用UTF-8编码吗，中文乱码问题不会困扰程序员</p>
</li>
<li><p>字符串一旦赋了值，字符串就不能修改了：<strong>在Go中字符串是不可变的</strong></p>
</li>
<li><p>字符串的两种表示形式</p>
<ul>
<li>双引号(“ “)，会识别转义字符</li>
<li>反引号(&#96;&#96;)，以字符串的原生形式输出，包括换行和特殊字符，可以实现<strong>防止攻击</strong>、输出源代码等效果</li>
</ul>
</li>
<li><p>字符串拼接方式</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="type">string</span></span><br><span class="line">str = <span class="string">&quot;hello &quot;</span> + <span class="string">&quot;world &quot;</span></span><br><span class="line">fmt.Println(str)</span><br><span class="line">str += <span class="string">&quot;ok&quot;</span></span><br><span class="line">fmt.Println(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：hello world</span></span><br><span class="line"><span class="comment">//         hello world ok</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当一行字符串太长时，需要使用多行字符串</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str := <span class="string">&quot;hello &quot;</span> +     <span class="comment">//加号需要在上一行</span></span><br><span class="line">	   <span class="string">&quot;world!&quot;</span></span><br><span class="line">fmt.Println(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：hello world!</span></span><br></pre></td></tr></table></figure>

<h3 id="Golang的基本数据类型的默认值"><a href="#Golang的基本数据类型的默认值" class="headerlink" title="Golang的基本数据类型的默认值"></a>Golang的基本数据类型的默认值</h3><p><strong>基本介绍：</strong>在Go中，数据类型都有一个默认值，当程序员没有赋值时，就会保留默认值。在Go中，默认值叫零值</p>
<p>基本数据类型的默认值如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="type">float32</span></span><br><span class="line">    <span class="keyword">var</span> c <span class="type">float64</span></span><br><span class="line">    <span class="keyword">var</span> isMarried <span class="type">bool</span></span><br><span class="line">    <span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;a = %d\n&quot;</span>, <span class="string">&quot;b = %v\n&quot;</span>, <span class="string">&quot;c = %v\n&quot;</span>, <span class="string">&quot;isMarried = %v\n&quot;</span>, <span class="string">&quot;name = %c\n&quot;</span>, a, b, c, isMarried, name) <span class="comment">//%v按照变量的值输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：a = 0</span></span><br><span class="line"><span class="comment">//         b = 0</span></span><br><span class="line"><span class="comment">//         c = 0</span></span><br><span class="line"><span class="comment">//         isMarried = false</span></span><br><span class="line"><span class="comment">//         name = </span></span><br></pre></td></tr></table></figure>

<h3 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h3><p><strong>基本介绍：</strong>Golang和java&#x2F;c不同，Go在不同类型的变量之间赋值需要<strong>显示转换</strong>（强制转化）。也就是说Golang中数据类型<strong>不能自动转换</strong></p>
<p><strong>基本语法：</strong></p>
<p>表达式T(v)将值v转化为T</p>
<ul>
<li>T：就是数据类型，例如int32，int64，float32等</li>
<li>v：就是需要转换的变量</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int32</span> = <span class="number">100</span></span><br><span class="line"><span class="comment">//希望将i装换为float32</span></span><br><span class="line"><span class="keyword">var</span> n1 <span class="type">float32</span> = <span class="type">float32</span>(i)</span><br><span class="line"><span class="keyword">var</span> n2 <span class="type">int8</span> = <span class="type">int8</span>(i)</span><br><span class="line"><span class="keyword">var</span> n3 <span class="type">int64</span> = <span class="type">int64</span>(i) <span class="comment">//低精度到高精度</span></span><br></pre></td></tr></table></figure>

<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>Go中，数据类型的转换可以是从表示范围小-&gt;表示范围大，也可以 范围大-&gt;范围小</li>
<li>被转化的是<strong>变量存储的数据</strong>（即值），变量本身的数据类型没有变换</li>
<li>再转换中，将int64转换为int8，编译时不会报错，只是转换结果是按照溢出处理</li>
</ul>
<h3 id="基本数据类型转换为string"><a href="#基本数据类型转换为string" class="headerlink" title="基本数据类型转换为string"></a>基本数据类型转换为string</h3><p><strong>基本介绍：</strong>在程序开发中，我们经常需要将基本数据类型转成string类型，或者将string转换为基本数据类型</p>
<ul>
<li>方式一：	<strong>fmt.Sprintf(“%参数”, 表达式)</strong></li>
</ul>
<p>Sprintf根据format参数生成格式化的字符串并返回该字符串</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num1 <span class="type">int</span> = <span class="number">99</span></span><br><span class="line">    <span class="keyword">var</span> num2 <span class="type">float64</span> = <span class="number">23.456</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="type">bool</span> = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> myChar <span class="type">byte</span> = <span class="string">&#x27;h&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> str <span class="type">string</span><span class="comment">//空的str</span></span><br><span class="line"></span><br><span class="line">    str = fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, num1)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;str type %T str = %v\n&quot;</span>, str,str)</span><br><span class="line"></span><br><span class="line">    str = fmt.Sprintf(<span class="string">&quot;%f&quot;</span>, num2)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;str type %T str = %v\n&quot;</span>, str,str)</span><br><span class="line"></span><br><span class="line">    str = fmt.Sprintf(<span class="string">&quot;%t&quot;</span>, b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;str type %T str = %v\n&quot;</span>, str,str)</span><br><span class="line"></span><br><span class="line">    str = fmt.Sprintf(<span class="string">&quot;%c&quot;</span>, myChar)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;str type %T str = %v\n&quot;</span>, str,str)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：str type string str = 99</span></span><br><span class="line"><span class="comment">//         str type string str = 23.456000</span></span><br><span class="line"><span class="comment">//         str type string str = true</span></span><br><span class="line"><span class="comment">//         str type string str = h</span></span><br></pre></td></tr></table></figure>

<ul>
<li>方式二：使用strconv包中的函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num1 <span class="type">int</span> = <span class="number">99</span></span><br><span class="line">    <span class="keyword">var</span> num2 <span class="type">float64</span> = <span class="number">23.456</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="type">bool</span> = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> str <span class="type">string</span><span class="comment">//空的str</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//func FormatInt(i int64, base int) string</span></span><br><span class="line">    str = strconv.FormatInt(<span class="type">int64</span>(num1), <span class="number">10</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;str type %T str = %v\n&quot;</span>, str,str)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//func FormatFloat(f float64, fmt byte, prec, bitSize int) string</span></span><br><span class="line">    str = strconv.FormatFloat(num2, <span class="string">&#x27;f&#x27;</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;str type %T str = %v\n&quot;</span>, str,str)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//func FormatBool(b bool) string</span></span><br><span class="line">    str = strconv.FormatBool(b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;str type %T str = %v\n&quot;</span>, str,str)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//补充Itoa函数</span></span><br><span class="line">    <span class="comment">//func Itoa(i int)</span></span><br><span class="line">    <span class="keyword">var</span> num3 <span class="type">int</span> = <span class="number">4567</span></span><br><span class="line">    str = strconv.Itoa(num3)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;str type %T str = %v\n&quot;</span>, str, str)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：str type string str = 99</span></span><br><span class="line"><span class="comment">//         str type string str = 23.4560000000</span></span><br><span class="line"><span class="comment">//         str type string str = true</span></span><br><span class="line"><span class="comment">//         str type string str = 4567 </span></span><br></pre></td></tr></table></figure>

<h3 id="string转换为基本数据类型"><a href="#string转换为基本数据类型" class="headerlink" title="string转换为基本数据类型"></a>string转换为基本数据类型</h3><ul>
<li>方式：使用strconv包的函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//func ParseBool(str string) (value bool, err error)</span></span><br><span class="line">    <span class="comment">//ParseBool传入一个值，返回两个值，需要对两个值分别接收</span></span><br><span class="line">    <span class="comment">//_可以忽略一个返回值</span></span><br><span class="line">    b, _ = strconv.ParseBool(str)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;b type %T b = %v\n&quot;</span>, b, b)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//func ParseInt(s string, base int, bitSize int) (i int64, err error)</span></span><br><span class="line">    <span class="comment">//base为进制，bitSize为int类型</span></span><br><span class="line">    <span class="keyword">var</span> str2 <span class="type">string</span> = <span class="string">&quot;1234590&quot;</span></span><br><span class="line">    <span class="keyword">var</span> n1 <span class="type">int64</span></span><br><span class="line">    n1, _ = strconv.ParseInt(str2, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;n1 type %T n1 = %v\n&quot;</span>, n1, n1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//func ParseFloat(s string, bitSize int) (f float64, err error)</span></span><br><span class="line">    <span class="keyword">var</span> str3 <span class="type">string</span> = <span class="string">&quot;123.456&quot;</span></span><br><span class="line">    <span class="keyword">var</span> f1 <span class="type">float64</span></span><br><span class="line">    f1, _ = strconv.ParseFloat(str3, <span class="number">64</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;f1 type %T f1 = %v\n&quot;</span>, f1, f1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：b type bool b = true</span></span><br><span class="line"><span class="comment">//         n1 type int64 n1 = 1234590</span></span><br><span class="line"><span class="comment">//         f1 type float64 f1 = 123.456</span></span><br></pre></td></tr></table></figure>

<p><strong>注意事项和使用细节：</strong></p>
<p>在将string类型转成基本数据类型时，<strong>要确保string类型能够转成有效的数据</strong>。如果转换失败，则接收值类型为目标类型，但接收值的值为<strong>默认值</strong></p>
<h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p><strong>基本介绍：</strong></p>
<ul>
<li>基本数据类型，变量存的就是值，也叫值类型</li>
<li>获取变量的地址，用&amp;。比如：var num in，获取num的地址：&amp;num</li>
<li>指针类型，变量存的是一个地址，这个地址指向的空间存的才是值。比如：var ptr *int &#x3D; &amp;num</li>
<li>获取指针类型所指向的值，用*。比如var *ptr int，使用 *ptr获取p指向的值</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">	<span class="comment">//i的地址是&amp;i</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;i 的地址是 %v\n&quot;</span>, &amp;i)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ptr是一个指针变量</span></span><br><span class="line">    <span class="comment">//ptr的类型是*int</span></span><br><span class="line">    <span class="comment">//ptr本身的值是&amp;i</span></span><br><span class="line">    <span class="keyword">var</span> ptr *<span class="type">int</span> = &amp;i</span><br><span class="line">    fmt.Printf(<span class="string">&quot;i 的地址是 %v\n&quot;</span>, ptr)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;ptr 的地址是 %v\n&quot;</span>, &amp;ptr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：i 的地址是 0xc0000140b8</span></span><br><span class="line"><span class="comment">//         i 的地址是 0xc0000140b8  </span></span><br><span class="line"><span class="comment">//         ptr 的地址是 0xc000006030(在本主机结果)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过ptr指针修改num的值</span></span><br><span class="line"><span class="keyword">var</span> num <span class="type">int</span> = <span class="number">9</span></span><br><span class="line"><span class="keyword">var</span> ptr *<span class="type">int</span></span><br><span class="line">ptr = &amp;num <span class="comment">//这里修改时，会导致num变化</span></span><br><span class="line">*ptr = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p><strong>注意事项和使用细节</strong></p>
<ul>
<li>值类型，都有对应的指针类型，形式为*<strong>数据类型</strong>，比如int的对应指针就是 *int，float32对应的指针就是 *float32，以此类推</li>
<li>值类型包括：基本数据类型int系列，float系列，bool，string、数组和结构体struct</li>
</ul>
<h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><ul>
<li>常见的值类型：基本数据类型int系列，float系列，bool，string、数组和结构体struct</li>
<li>常见的引用类型：指针、slice切片、map、管道chan、接口interface等</li>
</ul>
<p><strong>值类型和引用类型的区别：</strong></p>
<ul>
<li>值类型：变量直接存储值，内存通常在<strong>栈中分配</strong></li>
<li>引用类型：变量存储的是一个地址，这个地址对应的空间才是真正存储数据（值），内存通常在<strong>堆上分配</strong>，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由GC回收</li>
</ul>
<h3 id="标识符的命名规范"><a href="#标识符的命名规范" class="headerlink" title="标识符的命名规范"></a>标识符的命名规范</h3><p><strong>基本介绍：</strong></p>
<ul>
<li>Golang对各种变量、方法、函数等命名时使用的字符序列成为标识符</li>
<li>凡是自己可以起名字的地方都叫标识符</li>
</ul>
<p><strong>标识符的命名规则：</strong></p>
<ul>
<li>由26个英文字母大小写，0-9，_ 组成</li>
<li>数字不可以开头</li>
<li>Golang中严格区分大小写</li>
<li>标识符不能包含空格</li>
<li>下划线”_”本身在Go中是一个特殊的标识符，称为<strong>空标识符</strong>。可以代表任何其他的标识符，但是它对应的值会被忽略（比如：忽略某个返回值）。所以仅能被作为占位符使用，不能作为标识符使用</li>
<li>不能一系统<strong>保留关键字</strong>作为标识符，比如break，if等</li>
</ul>
<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>包名：<strong>保持package的名字和目录保持一致</strong>，尽量采取有意义的包名，简短，有意义，不要和标准库冲突</li>
<li>变量名、函数名、常量名：采用<strong>驼峰法</strong></li>
<li>如果变量名、函数名、常量名首字母大写，则可以被其他的包访问；如果首字母小写，则只能在本包中使用（注：可以简单的理解成，<strong>首字母大写是公有的，首字母小写是私有的</strong>），在Golang中没有public、private等关键字</li>
</ul>
<h3 id="保留关键字和预定义标识符"><a href="#保留关键字和预定义标识符" class="headerlink" title="保留关键字和预定义标识符"></a>保留关键字和预定义标识符</h3><p><strong>包里关键字介绍：</strong></p>
<p>在Go中，为了简化代码的编译过程中对代码的解析，其定义的保留关键字只有25个，如下：</p>
<p>break、default、func、interface、select、case、defer、go、map、struct、chan、else、goto、package、switch、const、fallthrough、if、range、type、continue、for、import、return、var</p>
<p><strong>预定义标识符介绍：</strong></p>
<p>除了保留关键字外，Go中还提供了36个预定义标识符，其中包括基础数据类型和系统内嵌函数</p>
<p>append、bool、byte、cap、close、complex、complex64、complex128、uint16、copy、false、float32、float64、imag、int、int8、int16、int32、int64、ioat、len、make、new、nil、panic、uint64、print、println、real、recover、string、true、uint、unit8、uintprt</p>
<hr>
<h2 id="运算符介绍"><a href="#运算符介绍" class="headerlink" title="运算符介绍"></a>运算符介绍</h2><p>运算符是一种特殊的符号，用以表示数据的<strong>运算、赋值和比较</strong>等</p>
<h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p><strong>基本介绍：</strong>算术运算法是对数值类型的变量进行运算的，比如：加减乘除等</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="number">3</span> + <span class="number">4</span>)  <span class="comment">//7</span></span><br><span class="line">    fmt.Println(<span class="number">6</span> - <span class="number">2</span>)  <span class="comment">//4</span></span><br><span class="line">    fmt.Println(<span class="number">10</span> / <span class="number">4</span>) <span class="comment">//2，如果希望保留小数部分，则需要有浮点数参与运算</span></span><br><span class="line">    fmt.Println(<span class="number">2</span> * <span class="number">3</span>)  <span class="comment">//6</span></span><br><span class="line">    fmt.Println(<span class="number">10</span> % <span class="number">3</span>) <span class="comment">//1，取模运算公式：a - b / b * b</span></span><br><span class="line">    <span class="comment">//++：自增</span></span><br><span class="line">    <span class="comment">//--：自减</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>对于除号” &#x2F; “，它的整数除和小数除是有区别的，整数之间做除法时，只保留整数部分而舍弃小数部分</li>
<li>当对一个数取模时，可以等价a % b &#x3D; a - b &#x2F; b * b</li>
<li>Golang的自增自减只能当做一个独立语言使用</li>
<li>Golang的++和–<strong>只能写在变量后面</strong>，不能写在变量前面</li>
<li>Golang的设计者去掉c &#x2F; java中的自增自减的容易混淆的写法，让Golang更加简洁，统一</li>
</ul>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p><strong>基本介绍：</strong></p>
<ul>
<li>关系运算符的结果都是bool型，也就是要么是true，要么是false</li>
<li>关系表达式经常用在<strong>if结构</strong>的条件中或<strong>循环结构</strong>的条件中</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n1 <span class="type">int</span> = <span class="number">8</span></span><br><span class="line">    <span class="keyword">var</span> n2 <span class="type">int</span> = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(n1 == n2) <span class="comment">//false</span></span><br><span class="line">    fmt.Println(n1 != n2) <span class="comment">//true</span></span><br><span class="line">    fmt.Println(n1 &gt;= n2) <span class="comment">//false</span></span><br><span class="line">    fmt.Println(n1 &lt;= n2) <span class="comment">//true</span></span><br><span class="line">    fmt.Println(n1 &gt; n2)  <span class="comment">//false</span></span><br><span class="line">    fmt.Println(n1 &lt; n2)  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    flag := n1 &gt; n2</span><br><span class="line">    fmt.Println(flag)     <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>关系运算符的结果都是bool型，也就是要么是true，要么是false</li>
<li>关系运算符组成的表达式，我们称为<strong>关系表达式</strong></li>
<li>关系运算符” &#x3D;&#x3D; “不能误写成” &#x3D; “</li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><strong>基本介绍：</strong>用于连接多个条件（一般来讲就是关系表达式），最终结果也是一个bool值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age <span class="type">int</span> = <span class="number">40</span></span><br><span class="line">    <span class="keyword">if</span> age &gt; <span class="number">30</span> &amp;&amp; age &lt; <span class="number">50</span>&#123;</span><br><span class="line">      	fmt.Println(<span class="string">&quot;ok1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> age &gt; <span class="number">30</span> || age &lt; <span class="number">40</span>&#123;</span><br><span class="line">      	fmt.Println(<span class="string">&quot;ok2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !(age &lt; <span class="number">30</span>)&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;ok3&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>&amp;&amp;也叫<strong>短路与</strong>，如果第一个条件为false，则第二个条件不会判断，最终结果为false</li>
<li>||也叫<strong>短路或</strong>，如果第一个条件为true，则第二个条件不会判断，做种结果为true</li>
</ul>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p><strong>基本介绍：</strong>赋值运算符就是将某个运算后的值，赋给指定的变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">    fmt.Println(i)</span><br><span class="line"></span><br><span class="line">    a := <span class="number">9</span></span><br><span class="line">    b := <span class="number">2</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;交换前，a = %v, b = %v\n&quot;</span>, a, b)</span><br><span class="line">    t := a</span><br><span class="line">    a = b</span><br><span class="line">    b = t</span><br><span class="line">    fmt.Printf(<span class="string">&quot;交换后，a = %v, b = %v\n&quot;</span>, a, b)</span><br><span class="line"></span><br><span class="line">    a += <span class="number">7</span> <span class="comment">//a = a + 7</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>运算顺序<strong>从右向左</strong></li>
<li>赋值运算符的<strong>最左边只能是变量</strong>，<strong>右边可以是变量、表达式、常量值</strong></li>
<li>复合赋值运算符等价效果</li>
</ul>
<h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><ul>
<li>&amp;：返回变量存储地址，&amp;a将给出变量的实际地址</li>
<li>*：指针变量， *a是一个指针变量</li>
</ul>
<p><strong>特别说明：</strong>Go语言中不支持三目运算符，可以使用if-else来实现</p>
<h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><ul>
<li>运算符有不同的优先级，所谓优先级就是表达式运算中的<strong>运算顺序</strong></li>
<li>只有单目运算符、赋值运算符是从右向左</li>
<li>大致顺序：括号 ++ –、单目运算、算数运算、移位运算、关系运算、位运算、逻辑运算、赋值运算、逗号<ul>
<li>后缀：() [] {} -&gt; . ++ –  左到右</li>
<li>单目：+ - ! ~ (type) * &amp; sizeof  右到左</li>
<li>乘法：* &#x2F; %  左到右</li>
<li>加法：+ -  左到右</li>
<li>移位：&gt;&gt; &lt;&lt;  左到右</li>
<li>相等： &#x3D;&#x3D; !&#x3D;  左到右</li>
<li>按位AND：&amp;  左到右</li>
<li>按位XOR：^  左到右</li>
<li>按位AND：|  左到右</li>
<li>逻辑AND：&amp;&amp;  左到右</li>
<li>逻辑OR：||  左到右</li>
<li>赋值运算符：&#x3D;   +&#x3D;   -&#x3D;   *&#x3D;   &#x2F;&#x3D;   %&#x3D;   &gt;&gt;&#x3D;   &lt;&lt;&#x3D;   &amp;&#x3D;   ^&#x3D;   |&#x3D;  右到左</li>
<li>逗号：,   左到右</li>
</ul>
</li>
</ul>
<hr>
<h2 id="获取用户中端输入"><a href="#获取用户中端输入" class="headerlink" title="获取用户中端输入"></a>获取用户中端输入</h2><h3 id="键盘输入语句"><a href="#键盘输入语句" class="headerlink" title="键盘输入语句"></a>键盘输入语句</h3><p><strong>基本介绍：</strong>在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取</p>
<p>步骤：</p>
<ol>
<li>导入fmt包</li>
<li>调用fmt包中函数fmt.Scanln()或fmt.Scanf()</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> age <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> sal <span class="type">float32</span></span><br><span class="line">    <span class="keyword">var</span> isPass <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;请输入姓名&quot;</span>)</span><br><span class="line">    fmt.Scanln(&amp;name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;请输入年龄&quot;</span>)</span><br><span class="line">    fmt.Scanln(&amp;age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;请输入薪水&quot;</span>)</span><br><span class="line">    fmt.Scanln(&amp;sal)</span><br><span class="line">    fmt.Println(<span class="string">&quot;请输入是否通过考试&quot;</span>)</span><br><span class="line">    fmt.Scanln(&amp;isPass)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;姓名：%v\n年龄：%v\n薪水：%v\n是否通过考试：%v\n&quot;</span>, name, age , sal, isPass)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> age <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> sal <span class="type">float32</span></span><br><span class="line">    <span class="keyword">var</span> isPass <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;请输入你的姓名，年龄，薪水，是否通过考试，使用空格隔开&quot;</span>)</span><br><span class="line">    fmt.Scanf(<span class="string">&quot;%s %d %f %t&quot;</span>, &amp;name, &amp;age, &amp;sal, &amp;isPass)</span><br><span class="line">  	fmt.Printf(<span class="string">&quot;姓名：%v\n年龄：%v\n薪水：%v\n是否通过考试：%v\n&quot;</span>, name, age , sal, isPass)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><h3 id="进制介绍"><a href="#进制介绍" class="headerlink" title="进制介绍"></a>进制介绍</h3><p>对于整数，有四种表示方式</p>
<ul>
<li>二进制：0，1，满二进一</li>
<li>十进制：0-9，满十进一</li>
<li>八进制：0-7，满八进一，以数字0开头表示</li>
<li>十六进制：0-9及A-F，满十六进一，以0x或0X开头表示</li>
</ul>
<h3 id="进制的转换"><a href="#进制的转换" class="headerlink" title="进制的转换"></a>进制的转换</h3><h4 id="其他进制转十进制"><a href="#其他进制转十进制" class="headerlink" title="其他进制转十进制"></a>其他进制转十进制</h4><p>二进制转十进制</p>
<p>规则：从最低位开始（右边），将每个位上的数提取出来，乘以2的（位数-1）次方，然后求和</p>
<p>案例：1011 &#x3D; 1 * 1 + 1 * 2 + 0 * 2 * 2 + 1 * 2 * 2 * 2 &#x3D; 1 + 2 +  0 + 8 &#x3D; 11</p>
<p>八进制转十进制</p>
<p>规则：从最低位开始（右边），将每个位上的数提取出来，乘以8的（位数-1）次方，然后求和</p>
<p>案例：0123 &#x3D; 3 * 1 + 2 * 8 + 1 * 8 * 8 &#x3D; 3 + 16 + 64 &#x3D; 83</p>
<p>十六进制转十进制</p>
<p>规则：从最低位开始（右边），将每个位上的数提取出来，乘以16的（位数-1）次方，然后求和</p>
<p>案例：0x34A &#x3D; 10 * 1 + 4 * 16 + 3 * 16 * 16 &#x3D; 10 + 64 + 768 &#x3D; 842</p>
<h4 id="十进制转其他进制"><a href="#十进制转其他进制" class="headerlink" title="十进制转其他进制"></a>十进制转其他进制</h4><p>十进制转二进制：将该数不断除以2，直到商为0为止，然后将每步得到的余数倒过来，就是对应的二进制</p>
<p>案例：56（十进制） &#x3D; 111000（二进制）</p>
<p>十进制转八进制：将该数不断除以8，直到商为0为止，然后将每步得到的余数倒过来，就是对应的二进制</p>
<p>案例：156（十进制） &#x3D; 0234（八进制）</p>
<p>十进制转十六进制：将该数不断除以16，直到商为0为止，然后将每步得到的余数倒过来，就是对应的二进制</p>
<p>案例：356（十进制） &#x3D; 0x164（十六进制）</p>
<h4 id="二进制转其他进制"><a href="#二进制转其他进制" class="headerlink" title="二进制转其他进制"></a>二进制转其他进制</h4><p>二进制转八进制：将二进制数每三位一组（从低位开始组合），转成对应的八进制数即可</p>
<p>案例：11 010 101（二进制） &#x3D; 0325（八进制）</p>
<p>二进制转十六进制：将二进制数每四位一组（从低位开始组合），转成对应的十六进制数即可</p>
<p>案例：1101 0101（二进制） &#x3D; 0xD5（十六进制）</p>
<h4 id="其他进制转二进制"><a href="#其他进制转二进制" class="headerlink" title="其他进制转二进制"></a>其他进制转二进制</h4><p>八进制转二进制：将八进制每一位，转成对应的三位二进制数即可</p>
<p>案例：0237（八进制） &#x3D; 10 011 111（十六进制）</p>
<p>十六进制转二进制：将十六进制每一位，转成对应的四位二进制数即可</p>
<p>案例：0x237（十六进制） &#x3D; 10 0011 0111（二进制）</p>
<h3 id="反码-原码-补码"><a href="#反码-原码-补码" class="headerlink" title="反码 原码 补码"></a>反码 原码 补码</h3><h4 id="二进制在运算中的说明"><a href="#二进制在运算中的说明" class="headerlink" title="二进制在运算中的说明"></a>二进制在运算中的说明</h4><p>二进制是逢二进位的进位制，0、1是基本算符。</p>
<p>现代的电子计算机技术全部采用的是二进制，因为它使用0、1两个数字符号，非常简单方便，易于用电子方式实现。<strong>计算机内部处理的信息，都是采用二进制数来表示的</strong>。二进制（Binary）数用0和1两个数字及其组合来表示任何数。进位规则是“逢二进一”，数字1在不同位上代表不同值，按从右至左的次序，这个值以二倍递增</p>
<h4 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h4><p>对有符号数而言：</p>
<ul>
<li>二进制最高位是符号位：0表示正数，1表示负数</li>
<li>正数的原码、反码、补码都是一样的</li>
<li>负数的反码等于它的原码符号位不变，其他位取反</li>
<li>负数的补码等于它的反码加一<ul>
<li>1  -&gt;原码[0000 0001]、反码[0000 0001]、补码[0000 0001]</li>
<li>-1 -&gt;原码[1000 0001]、反码[1111 1110]、补码[1111 1111]</li>
</ul>
</li>
<li>0的反码、补码都是0</li>
<li>在计算机运行时候，都是<strong>以补码的方式来运算</strong></li>
</ul>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>Golang中有三个位运算：分别是按位与&amp;、按位或|、按位异或^</p>
<ul>
<li>按位与&amp;：两位全为1，结果为1，否则为0</li>
<li>按位或|：两位有一个为1，结果为1，否则为0</li>
<li>按位异或^：两位相同为0，不同为1</li>
</ul>
<p>案例：</p>
<ul>
<li>2&amp;3：0000 0010 &amp; 0000 0011 &#x3D; 0000 0010 &#x3D; 2</li>
<li>2|3：0000 0010 | 0000 0011 &#x3D; 0000 0011 &#x3D; 3</li>
<li>2^3：0000 0010 ^ 0000 0011 &#x3D; 0000 0001 &#x3D; 1</li>
<li>-2^2：1111 1110 ^ 0000 0010 &#x3D; 1111 1100 &#x3D; -4</li>
</ul>
<p>Golang中有两个移位运算符：</p>
<ul>
<li>右移运算符&gt;&gt;：低位溢出，符号位不变，并用符号位补溢出的高位</li>
<li>左移运算符&lt;&lt;：符号位不变，低位补0</li>
</ul>
<p>案例：</p>
<ul>
<li>1&gt;&gt;2：0000 0001 &gt;&gt; 0000 0000 &#x3D; 0</li>
<li>1&lt;&lt;2：0000 0001 &lt;&lt; 0000 0100 &#x3D; 4</li>
</ul>
<hr>
<h2 id="程序流程控制"><a href="#程序流程控制" class="headerlink" title="程序流程控制"></a>程序流程控制</h2><p>在程序中，程序运行的流程控制决定程序是如何执行的，使我们必须掌握的，主要有三大流程控制语句：</p>
<ol>
<li>顺序控制</li>
<li>分支控制</li>
<li>循环控制</li>
</ol>
<h3 id="顺序控制介绍"><a href="#顺序控制介绍" class="headerlink" title="顺序控制介绍"></a>顺序控制介绍</h3><p>程序从上到下逐行地执行，中间没有任何判断和跳转</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在下列代码中，没有判断和跳转</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="number">3</span> + <span class="number">4</span>)</span><br><span class="line">    fmt.Println(<span class="number">6</span> - <span class="number">2</span>)</span><br><span class="line">    fmt.Println(<span class="number">10</span> / <span class="number">4</span>)</span><br><span class="line">    fmt.Println(<span class="number">2</span> * <span class="number">3</span>)</span><br><span class="line">    fmt.Println(<span class="number">10</span> % <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项和使用细节：</strong></p>
<p>先声明在使用，不可先试用在声明；必须<strong>自上而下</strong></p>
<h3 id="分支控制介绍"><a href="#分支控制介绍" class="headerlink" title="分支控制介绍"></a>分支控制介绍</h3><p>分支控制if-else介绍</p>
<p>让程序有选择执行，分支控制有三种：单分支；双分支；多分支</p>
<h4 id="单分支"><a href="#单分支" class="headerlink" title="单分支"></a>单分支</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单分支基本语法</span></span><br><span class="line"><span class="keyword">if</span> 条件表达式 &#123;</span><br><span class="line">  	执行代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><p>当条件表达式为true是，就会执行{ }的代码</p>
</li>
<li><p>{ }是必须有的，就算只有一行代码</p>
</li>
<li><p>Golang支持在if语句中直接定义一个变量</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> age := <span class="number">20</span>; age &gt; <span class="number">18</span> &#123;   <span class="comment">//支持在if语句中直接定义一个变量</span></span><br><span class="line">  	fmt.Println(<span class="string">&quot;你已经大于18了&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双分支"><a href="#双分支" class="headerlink" title="双分支"></a>双分支</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双分支基本语法</span></span><br><span class="line"><span class="keyword">if</span> 条件表达式 &#123;</span><br><span class="line">  	代码块<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  	代码块<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>当条件表达式成立，即执行代码块1，否则执行代码块2</li>
<li>{ }必须存在</li>
<li>else必须紧接着if{ }后面写，<strong>不可换行</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt; <span class="number">18</span> &#123;             <span class="comment">//支持在if语句中直接定义一个变量</span></span><br><span class="line">  	fmt.Println(<span class="string">&quot;你已经大于18了&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;                  <span class="comment">//else必须紧接着if&#123; &#125;后面写，不可换行</span></span><br><span class="line">  	fmt.Println(<span class="string">&quot;你还未满18&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多分支"><a href="#多分支" class="headerlink" title="多分支"></a>多分支</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多分支基本语法</span></span><br><span class="line"><span class="keyword">if</span> 条件表达式<span class="number">1</span> &#123;</span><br><span class="line">  代码块<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 条件表达式<span class="number">2</span> &#123;</span><br><span class="line">  代码块<span class="number">2</span></span><br><span class="line">&#125; ... <span class="keyword">else</span> &#123;</span><br><span class="line">  代码块n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>多分支的判断流程如下<ul>
<li>先判断条件表达式1是否成立，如果为真，执行代码块1</li>
<li>如果条件表达式1不成立，判断条件表达式2是否成立，以此类推</li>
<li>如果所有条件表达式都不成立，则执行else中的代码块</li>
</ul>
</li>
<li>else不是必须的</li>
<li>多分支最多只有一个入口</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> score == <span class="number">100</span> &#123;</span><br><span class="line">  	fmt.Println(<span class="string">&quot;奖励BMW&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt;= <span class="number">80</span> &amp;&amp; score &lt; <span class="number">100</span> &#123;</span><br><span class="line">  	fmt.Println(<span class="string">&quot;奖励IPhone&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt;= <span class="number">60</span> &amp;&amp; score &lt; <span class="number">80</span> &#123;</span><br><span class="line">  	fmt.Println(<span class="string">&quot;奖励IPad&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  	fmt.Println(<span class="string">&quot;什么都不奖励&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项和使用细节：</strong></p>
<p>若一个分支条件表达式与其后分支条件表达式有重叠部分，则先到先得</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">9</span> &#123;</span><br><span class="line">  	fmt.Println(<span class="string">&quot;ok1&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> i &gt; <span class="number">6</span> &#123;</span><br><span class="line">  	fmt.Println(<span class="string">&quot;ok2&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> i &gt; <span class="number">3</span> &#123;</span><br><span class="line">  	fmt.Println(<span class="string">&quot;ok3&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  	fmt.Println(<span class="string">&quot;ok4&quot;</span>)</span><br><span class="line">&#125;<span class="comment">//该式仅会输出ok1</span></span><br></pre></td></tr></table></figure>

<h4 id="嵌套分支"><a href="#嵌套分支" class="headerlink" title="嵌套分支"></a>嵌套分支</h4><p>一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支的结构称为内层分支外面的分支结构称为外层分支</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//嵌套分支基本语法</span></span><br><span class="line"><span class="keyword">if</span> 条件表达式 &#123;</span><br><span class="line">    <span class="keyword">if</span> 条件表达式 &#123;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：嵌套分支不宜过多，最多我们建议控制在三层</p>
<h4 id="switch分支结构"><a href="#switch分支结构" class="headerlink" title="switch分支结构"></a>switch分支结构</h4><ul>
<li>switch语句用于基于不同条件执行不同动作，每一个case分支都是唯一的，<strong>从上到下逐一测试</strong> ，直到匹配为止</li>
<li>匹配项后面也<strong>不需要再加break</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> 表达式 &#123;</span><br><span class="line">    <span class="keyword">case</span> 表达式<span class="number">1</span>, 表达式<span class="number">2</span>, ...:</span><br><span class="line">    语句块<span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> 表达式<span class="number">3</span>, 表达式<span class="number">4</span>, ...:</span><br><span class="line">    语句块<span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> 表达式<span class="number">5</span>, 表达式<span class="number">6</span>, ...:</span><br><span class="line">    语句块<span class="number">3</span></span><br><span class="line">  	<span class="comment">//可以有多个case</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch执行流程：</p>
<ul>
<li>switch的执行的流程是，先执行表达式，得到值，然后和case的表达式进行比较，如果相等，就匹配到，然后执行对应的case的语句块，然后退出switch</li>
<li>如果switch的表达式的值没有和任何的case的表达式匹配成功，则执行default的语句块。执行后退出switch的控制</li>
</ul>
<p>switch使用细节：</p>
<ul>
<li>case后面是一个表达式(即：常量值、变量、一个有返回值的函数等都可以)</li>
<li>case后的各个表达式的值得数据类型，必须和switch的表达式数据类型一致</li>
<li>case后面可以带多个表达式，使用逗号间隔。比如case 表达式1， 表达式2…</li>
<li>case后面的表达式如果是常量值（字面量），则要求<strong>不能重复</strong></li>
<li>case后面不需要带break</li>
<li>default语句不是必须的</li>
<li>switch后也可以不带表达式，类似多个if-else分支来使用</li>
<li>switch后也可以直接声明一个变量，分号结束，不推荐</li>
<li>switch穿透-fallthrough，如果case语句块后增加fallthrough，则会执行下一个case，也叫switch穿透(默认只能穿透一层)</li>
<li>Type switch：switch语句还可以被用于type-switch来判断某个interface变量中实际指向的变量类型</li>
</ul>
<p>switch与if比较</p>
<ol>
<li>如果判断的<strong>具体数值不多</strong>，而且符合整数、浮点数、字符、字符串这几种类型。建议使用switch语句，简洁高效</li>
<li>其他情况，对区间判断的结果为bool类型的判断，使用if，if的使用范围更广</li>
</ol>
<h3 id="循环控制介绍"><a href="#循环控制介绍" class="headerlink" title="循环控制介绍"></a>循环控制介绍</h3><h4 id="循环介绍"><a href="#循环介绍" class="headerlink" title="循环介绍"></a>循环介绍</h4><p>让代码块可以循环执行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//输出十句hello world</span></span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">  	<span class="comment">//for循环</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      	fmt.Println(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="for循环控制"><a href="#for循环控制" class="headerlink" title="for循环控制"></a>for循环控制</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for循环基本语法</span></span><br><span class="line"><span class="keyword">for</span> 循环变量初始化; 循环条件; 循环变量迭代&#123;</span><br><span class="line">  	循环操作语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for循环四要素：</p>
<ul>
<li>循环变量初始化</li>
<li>循环条件</li>
<li>循环操作（循环体）</li>
<li>循坏变量的迭代</li>
</ul>
<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>循环条件是返回一个bool值得表达式</li>
<li>for循环的第二种使用方式</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环判断条件 &#123;</span><br><span class="line">	循环执行语句</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将变量初始化和变量迭代写到其他位置</span></span><br></pre></td></tr></table></figure>

<ul>
<li>for循环的第三种使用方式</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	循环执行语句</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面写法等价于for ； ； &#123;&#125;是一个无线循环，通常需要配合break语句使用</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Golang提供<strong>for-range的方式</strong>，可以方便遍历字符串和数组</p>
<p>注意：for-range在遍历字符串时，是按照字符来遍历的，而不是按照字节来的</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;hello,world!&quot;</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">  	fmt.Printf(<span class="string">&quot;%c \n&quot;</span>, str[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, val := <span class="keyword">range</span> str &#123;</span><br><span class="line">  	fmt.Printf(<span class="string">&quot;index = %d, val = %c\n&quot;</span>, index, val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>中文乱码问题：如果字符串含有中文，传统的遍历方式就是错误的，会出现乱码。传统的字符串遍历是按照字节遍历的，而中文在UTF-8中一个字为三个字节。解决方式：将 str 转成 []rune切片</li>
<li>对于for-range遍历方式而言，是按照字符方式便利。因此如果字符串有中文，也是可以正常遍历的</li>
</ul>
<h4 id="while和do…while的实现"><a href="#while和do…while的实现" class="headerlink" title="while和do…while的实现"></a>while和do…while的实现</h4><p>Go语言中没有while和do…while的语法，这一点需要注意，如果我们需要使用类似其他语言（例如jav&#x2F;c的while的do…while），可以通过for循环来实现其使用效果</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//while使用for循环实现</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> 循环条件表达式 &#123;</span><br><span class="line">      	<span class="keyword">break</span> <span class="comment">//跳出for循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    循环操作（语句）</span><br><span class="line">    循环变量迭代</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多重循环控制"><a href="#多重循环控制" class="headerlink" title="多重循环控制"></a>多重循环控制</h3><p><strong>基本介绍：</strong></p>
<ul>
<li>将一个循环放在另一个循环体内，就形成了循环嵌套。在外边的for称为外层循环，在里面的for称为内层循环</li>
<li>实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的循环条件为false时，才会跳出内层循环，才可结束外层循环的当次循环，开始下一次的循环</li>
<li>设外层循环次数为m次，内层循环为n次，则内层循环实际上需要执行m*n次</li>
</ul>
<h3 id="跳转控制语句"><a href="#跳转控制语句" class="headerlink" title="跳转控制语句"></a>跳转控制语句</h3><h4 id="Break"><a href="#Break" class="headerlink" title="Break"></a>Break</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//随机生成一个数，当这个数为99时，跳出循环，判断一共输出了多少数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> count <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">      	<span class="comment">//查询math/rand包及time包</span></span><br><span class="line">		rand.Seed(time.Now().UnixNano())</span><br><span class="line">		n := rand.Intn(<span class="number">100</span>) + <span class="number">1</span></span><br><span class="line">		fmt.Println(n)</span><br><span class="line">		count++</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">99</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;生成99一共使用了&quot;</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>break用于终止某个语句块的执行，用于中断当前for循环或跳出switch语句</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本语法</span></span><br><span class="line">&#123;</span><br><span class="line">  	<span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>说明语句块中，可以通过标签指明要终止的是哪条语句块</li>
<li><strong>标签</strong>基本使用</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">label1 &#123;</span><br><span class="line">    label2 &#123;</span><br><span class="line">        label3 &#123;</span><br><span class="line">          	<span class="keyword">break</span> label2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//跳出label2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><ul>
<li>continue语句用于结束本次循环，继续执行下一次循环</li>
<li>continue语句出现在多层循环语句体中时，可以通过标签指明要跳转的是哪一层循环，这个和前面break的标签使用方法一致</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  	<span class="keyword">continue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从键盘输入一个整数，判断这个数正数还是负数，最终输出正数与负数的个数</span></span><br><span class="line"><span class="comment">//输入0则退出程序</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> positiveCount <span class="type">int</span> </span><br><span class="line">    <span class="keyword">var</span> negativeCount <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> num <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;请输入一个整数：&quot;</span>)</span><br><span class="line">        fmt.Scanln(&amp;num)</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span> &#123;</span><br><span class="line">          	<span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> num &gt; <span class="number">0</span> &#123;</span><br><span class="line">            positiveCount++</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        negativeCount++</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;正整数有%v个，负整数有%v个&quot;</span>, positiveCount, negativeCount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h4><ul>
<li>Go语言的goto语句可以无条件的转移到程序中指定的行</li>
<li>goto语句通常与条件语句配合使用。可用来使用条件跳转，跳出循环体等功能</li>
<li>在Go程序设计中<strong>一般不主张使用goto语句</strong>，以免造成程序流程的混乱，是理解和调试程序都产生困难</li>
</ul>
<h4 id="return"><a href="#return" class="headerlink" title="return"></a>return</h4><p>return使用在方法或者函数中，表示跳出所在方法或函数，详见函数章节</p>
<ul>
<li>如果return在一般函数中，则跳出该函数</li>
<li>如果return在main函数中，则退出程序</li>
</ul>
<hr>
<h2 id="函数和方法"><a href="#函数和方法" class="headerlink" title="函数和方法"></a>函数和方法</h2><p>为什么需要函数？</p>
<ul>
<li>函数可以解决模块化编程</li>
<li>函数可以减少代码冗余</li>
</ul>
<p>为了完成某一功能的程序指令（语句）的集合，称为函数。</p>
<p>在Go语言中，函数分为：自定义函数、系统函数（查看Go编程手册）</p>
<h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数的基本语法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> 函数名（形参列表）（返回值类型列表）</span>&#123;</span><br><span class="line">  	执行语句</span><br><span class="line">  	<span class="keyword">return</span> 返回值列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>形参列表：表示函数的输入</li>
<li>函数中的语句：表示为了实现某一功能代码块</li>
<li>函数可以有返回值，也可以没有</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(n1 <span class="type">float64</span>, n2 <span class="type">float64</span>, opertor <span class="type">byte</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> res <span class="type">float64</span></span><br><span class="line">	<span class="keyword">switch</span> opertor &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">		res = n1 + n2</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">		res = n1 - n2</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">		res = n1 * n2</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">		res = n1 / n2</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;输入有误&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> n1 <span class="type">float64</span> = <span class="number">1.2</span></span><br><span class="line">	<span class="keyword">var</span> n2 <span class="type">float64</span> = <span class="number">2.4</span></span><br><span class="line">	<span class="keyword">var</span> opertor <span class="type">byte</span> = <span class="string">&#x27;+&#x27;</span></span><br><span class="line"></span><br><span class="line">	res := cal(n1, n2, opertor)     <span class="comment">//调用函数</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="包的介绍"><a href="#包的介绍" class="headerlink" title="包的介绍"></a>包的介绍</h3><p>在实际的开发中，我们往往需要在不同文件中，去调用其他文件的定义的函数，比如main.go中使用utils.go文件中的函数</p>
<p><strong>基本介绍：</strong>Go的每一个文件都属于一个包，也就是说Go是以包的形式来管理文件和项目目录结构的</p>
<p>包的三大作用：</p>
<ul>
<li>区分相同名字的函数、变量等标识符</li>
<li>当程序文件很多时，可以很好的管理项目</li>
<li>控制函数、变量等访问范围，即作用域</li>
</ul>
<p>包的相关说明：</p>
<p>打包的基本语法：package 包名</p>
<p>引入包的基本语法：import “包的路径”</p>
<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>在给一个文件打包时，该包对应一个文件夹，比如utils文件夹对应的包就是utils，文件的包名通常和文件所在的文件夹名一致，一般为小写字母。当一个文件要使用其他包函数或变量时，需要新引入对应的包。package指令在文件第一行，然后是import指令。在import包时，路径从GoPath的src下开始，不用带src，编译器会自动识别</li>
<li>为了让其他包的文件可以访问到本包的函数，则该<strong>函数名的首字母需要大写</strong>，类似其他语言的public，这样才能跨包使用</li>
<li>在访问其他包函数时，其语法是<strong>包名.函数名</strong></li>
<li>如果包名较长，Go支持给包取别名，但取别名后原包名就不能使用了</li>
<li>在同一包下，不能有相同的函数名，否则报重复定义错误</li>
<li>如果编译一个可执行文件，就需要将这个包声明为main，即package main，如果写的是一个库，包名可以自定义</li>
</ul>
<h3 id="函数-调用机制"><a href="#函数-调用机制" class="headerlink" title="函数-调用机制"></a>函数-调用机制</h3><p><strong>栈区</strong>：基本数据类型一般分配到栈区，编译器存在一个逃逸分析</p>
<p><strong>堆区</strong>：引用书序类型一般分配在堆区，编译器存在一个逃逸分析</p>
<p><strong>代码区</strong>：代码本身一般存放在代码区</p>
<p>在调用一个函数时，会给该函数分配一个新的空间，编译器会通过自身的处理让这个新空间和其他的栈的空间区分开来</p>
<p>每个函数对应的栈中，数据空间是独立的，不会混淆</p>
<p>当一个函数执行完毕后，程序会销毁函数对应的栈空间</p>
<h4 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//return基本语法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> 函数名 （形参列表） （返回值类型列表）</span>&#123;</span><br><span class="line">  	语句</span><br><span class="line">  	<span class="keyword">return</span> 返回值列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果返回多个值时，在接受时，希望忽略某个返回值，则使用 _ 符号表示占位忽略</li>
<li>如果返回值只有一个，（返回值类型列表）中的( )可以不写</li>
</ul>
<h3 id="函数的递归调用"><a href="#函数的递归调用" class="headerlink" title="函数的递归调用"></a>函数的递归调用</h3><p><strong>基本介绍：</strong>一个函数体内有调用了本身称为递归调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span> <span class="params">(n1 <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n1 &gt; <span class="number">2</span> &#123;</span><br><span class="line">      	n1--     <span class="comment">//向退出递归逼近</span></span><br><span class="line">      test1(n1)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;n1 = &quot;</span>, n1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span> <span class="params">(n2 <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n2 &gt; <span class="number">2</span> &#123;</span><br><span class="line">      	n2--     <span class="comment">//向退出递归逼近</span></span><br><span class="line">      test2(n2)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	fmt.Println(<span class="string">&quot;n2 = &quot;</span>, n2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    test1(<span class="number">4</span>)</span><br><span class="line">    test2(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：n1 =  2</span></span><br><span class="line"><span class="comment">//         n1 =  2</span></span><br><span class="line"><span class="comment">//         n1 =  3</span></span><br><span class="line"><span class="comment">//         n2 =  2</span></span><br></pre></td></tr></table></figure>

<p><strong>函数递归调用需要遵循的重要原则</strong></p>
<ul>
<li>执行一个函数时，就创建一个新的受保护的独立空间（新函数栈）</li>
<li>函数的局部变量是独立的，不会相互影响</li>
<li>递归必须向退出递归的条件逼近，否则就会无限递归</li>
<li>当一个函数执行完毕，或者遇到return，就会返回。遵守谁调用，就将结果返回给谁。但函数执行完毕时，该函数本身也被销毁</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span> || n == <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> test(n<span class="number">-1</span>) + test(n<span class="number">-2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;test = &quot;</span>, test(<span class="number">3</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>函数的形参列表可以是多个，返回值列表也可以是多个</li>
<li>形参列表和返回值列表的数据类型可以是值类型和引用类型</li>
<li>函数的命名遵循标识符命名规范，首字母不能是数字，首字母大写该函数可以北本包文件和其他包文件使用，首字母小写只嗯呢该本包文件使用</li>
<li>函数中的变量是局部的，函数外不生效</li>
<li><strong>基本数据类型和数组默认都是值传递</strong>，即进行值拷贝。函数内修改不会影响原来值</li>
<li>如果希望函数内的变量能修改函数外的变量，可以**传入变量的地址&amp;**，函数内以指针的方式操作变量，从效果上看类似引用</li>
<li>Go函数不支持重载</li>
<li>在Go中，<strong>函数也是一种数据类型</strong>，可以赋值给一个变量，则该变量就是一个函数类型的变量了。通过该变量可以对函数调用</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(n1 <span class="type">int</span>, n2 <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数既然是一种数据类型，因此在Go中，函数可以作为形参，并且调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFun</span><span class="params">(funvar <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>, num1 <span class="type">int</span>, num2 <span class="type">int</span>)&#123;</span><br><span class="line">  	<span class="keyword">return</span> funvar(num1, num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  a := getSum</span><br><span class="line">  fmt.Printf(<span class="string">&quot;a的类型%T，getSum类型是%T\n&quot;</span>, a, getSum)</span><br><span class="line">  </span><br><span class="line">  res := a(<span class="number">10</span>, <span class="number">40</span>)   <span class="comment">//等价 res := getSum(10, 40)</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;res = &quot;</span>, res)</span><br><span class="line">  </span><br><span class="line">  res2 := myFun(getSum, <span class="number">50</span> <span class="number">60</span>)</span><br><span class="line">  fmt.Println(<span class="string">&quot;res2 = &quot;</span>, res2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数既然是一种数据类型，因此在Go中，函数可以作为形参，并且调用</p>
</li>
<li><p>为了简化数据类型定义，Go支持自定义数据类型</p>
<p>基本语法：type 自定义数据类型名 数据类型</p>
<p>相当于一个别名。取别名之后，Go会认为别名和原名是不同的类型</p>
</li>
<li><p>支持函数返回值命名</p>
</li>
<li><p>使用 _ 标识符，忽略返回值</p>
</li>
<li><p>Go支持可变参数</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//支持0到多个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span> <span class="params">(args... <span class="type">int</span>)</span></span> sum <span class="type">int</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//支持1到多个参数</span></span><br><span class="line"><span class="comment">//可变参数只能放在形参列表中的最后一个</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span> <span class="params">(n1 <span class="type">int</span> ,args... <span class="type">int</span>)</span></span> sum <span class="type">int</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//说明：args是slice，通过args[index]可以访问到各个值</span></span><br></pre></td></tr></table></figure>

<h3 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h3><p><strong>基本介绍：</strong>每一个源文件都可以包含一个init函数，该函数会在main函数执行前，被Go运行框架调用，也就是说init会在main函数前被调用</p>
<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>如果一个文件同时包含全局变量定义，init函数和main函数，则执行流程是变量定义、init函数、main函数</li>
<li>init函数最主要的作用是，就是完成一些初始化工作</li>
<li>main.go和utils.go中都有全局变量定义和init函数，则首先执行utils中的变量定义、init函数；其次执行main中的变量定义、init函数、main函数</li>
</ul>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p><strong>基本介绍：</strong>Go支持匿名函数，如果某个函数只希望使用一次，可以考虑使用匿名函数，匿名函数也可以实现多次调用</p>
<p>匿名函数使用方式：</p>
<ul>
<li>在定义匿名函数时就直接调用</li>
<li>将匿名函数赋给一个变量（函数变量），在通过该变量来调用匿名函数</li>
</ul>
<p>全局匿名函数：如果将匿名函数赋给一个全局变量，那么这个匿名函数就成为一个全局匿名函数，可以在程序有效</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><strong>基本介绍：</strong>闭包就是一个函数和与其相关的引用环境组合的一个整体（实体）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUpper</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span> <span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        n = n + x</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f := AddUpper()</span><br><span class="line">    fmt.Println(f(<span class="number">1</span>)) <span class="comment">//11</span></span><br><span class="line">    fmt.Println(f(<span class="number">2</span>)) <span class="comment">//13</span></span><br><span class="line">    fmt.Println(f(<span class="number">3</span>)) <span class="comment">//16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n = n + x</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回的是一个匿名函数，但是匿名函数使用到了函数外的n，因此这个匿名函数就和n形成了一个整体构成闭包</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>类似面向对象：闭包是一个类，函数时操作，n时字段。函数和它使用到的n构成闭包</p>
</li>
<li><p>当我们反复调用f函数时，因为<strong>n只初始化一次</strong>，因此没调用一次就进行累加</p>
</li>
<li><p>闭包的关键，分析出返回的函数它使用（引用）哪些变量，函数和它引用的变量共同构成闭包</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编写一个函数makeSuffix(suffix string)接收一个文件后缀名，并返回一个闭包</span></span><br><span class="line"><span class="comment">//调用闭包，可以传入一个文件名，如果该文件名没有指定的后缀则返回文件名.后缀</span></span><br><span class="line"><span class="comment">//使用string HasSuffix</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">  	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSuffix</span> <span class="params">(suffix <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span> <span class="params">(<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">(name <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !strings.HasSuffix(name,suffix) &#123;</span><br><span class="line">          	<span class="keyword">return</span> name + suffix</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f := makeSuffix(<span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;文件名处理后为：&quot;</span>, f(<span class="string">&quot;winter&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数中——defer"><a href="#函数中——defer" class="headerlink" title="函数中——defer"></a>函数中——defer</h3><p><strong>基本介绍：</strong>在函数中，程序员经常需要创建资源（比如：数据库连接、文件句柄、锁等），为了<strong>在函数执行完毕后，及时的释放资源</strong>，Go的设计者提供defer（延迟机制）</p>
<p>当执行到defer时，暂时不执行，会将defer后面的语句压入到独立栈（defer栈）</p>
<p>当函数执行完毕后，再执行defer栈中语句。按在先入后出的方式执行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="type">int</span>, n2 <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;ok1 n1 =&quot;</span>, n1)<span class="comment">//延迟输出</span></span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;ok2 n2 =&quot;</span>, n2)<span class="comment">//延迟输出</span></span><br><span class="line">	res := n1 + n2</span><br><span class="line">	fmt.Println(<span class="string">&quot;ok3 res =&quot;</span>, res)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	res := sum(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;res =&quot;</span>, res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：ok3 res = 30</span></span><br><span class="line"><span class="comment">//         ok2 n2 = 20</span></span><br><span class="line"><span class="comment">//         ok1 n1 = 10</span></span><br><span class="line"><span class="comment">//         res = 30   </span></span><br></pre></td></tr></table></figure>

<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>当Go执行到一个defer时，不会立即执行defer后的语句，而是将defer后的语句压入一个栈中，然后继续执行函数下一个语句</li>
<li>当函数执行完毕后，在从defer栈中，依次从栈顶取出语句执行（遵循栈先入后出原则）</li>
<li>在defer将语句放到栈时，也会将相关的值拷贝同时入栈</li>
</ul>
<h3 id="函数参数的传递方式"><a href="#函数参数的传递方式" class="headerlink" title="函数参数的传递方式"></a>函数参数的传递方式</h3><p><strong>基本介绍：</strong>值类型参数默认就是值传递，而引用类型参数默认就是引用传递</p>
<p>两种传递方式：<strong>值传递、引用传递</strong></p>
<p>无论是值传递还是引用传递，传递给函数的都是变量的副本。不同的是，值传递的是值的拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小；而值拷贝由拷贝数据大小决定，数据越大效率越低</p>
<ul>
<li>值类型：基本数据类型int系列、float系列、bool、string、数据、结构体</li>
<li>引用类型：指针、slice切片、map、管道chan、interface等都是引用类型</li>
</ul>
<p><strong>值传递和引用传递使用特点：</strong></p>
<ul>
<li>值类型默认是值传递：变量直接存储值，内存通常在栈中分配</li>
<li>引用类型默认是引用传递：变量存储的是一个地址，这个地址对应的空间才是真正的存储数据（值），内存通常在堆上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由GC来回收</li>
<li>如果希望函数内的变量能修改函数外的变量，可以传入变量的地址&amp;，函数内以指针的方式操作变量</li>
</ul>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p><strong>基本介绍：</strong></p>
<ul>
<li><p>函数内部声明&#x2F;定义的变量叫局部变量，作用域仅限于函数内部</p>
</li>
<li><p>函数外部声明&#x2F;定义的变量叫全局变量，作用域在整个包都是有效的，如果首字母大写，则作用域在整个程序有效 </p>
</li>
<li><p>如果变量是在一个代码块，比如for&#x2F;if中，那么这个变量的作用域就在该代码块</p>
</li>
<li><p>函数体外不可以执行：Name :&#x3D; “tom”，因为这句话为两句合并而成</p>
<p>var Name string</p>
<p>Name &#x3D; “tom” &#x2F;&#x2F;会报错</p>
</li>
</ul>
<h3 id="字符串中常用的系统函数"><a href="#字符串中常用的系统函数" class="headerlink" title="字符串中常用的系统函数"></a>字符串中常用的系统函数</h3><p><strong>基本介绍：</strong>字符串在我们日常程序开发中使用的非常多，Go语言为我们准备了常用函数</p>
<ul>
<li>统计字符串的长度，按字节len(str)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str := <span class="string">&quot;hello西安&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;str长度 =&quot;</span>, <span class="built_in">len</span>(str))</span><br><span class="line"><span class="comment">//输出：str长度 = 11</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符串遍历，同时<strong>处理有中文</strong>的问题r :&#x3D; []rune(str)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str2 := []<span class="type">rune</span>(str) <span class="comment">//   转成切片</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str2); i++ &#123;</span><br><span class="line">  	fmt.Printf(<span class="string">&quot;字符 = %c &quot;</span>, str2[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：字符 = h 字符 = e 字符 = l 字符 = l 字符 = o 字符 = 西 字符 = 安</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>字符串转整数： n,err :&#x3D; strconv.Atoi(“12”)</p>
</li>
<li><p>整数转字符串： str &#x3D; strconv.Itoa(12345)</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n, err := strconv.Atoi(<span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  	fmt.Println(<span class="string">&quot;转换出错&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  	fmt.Println(<span class="string">&quot;转换结果是：&quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：转换结果是： 123</span></span><br><span class="line">str := strconv.Itoa(<span class="number">123</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str = %v str = %T&quot;</span>, str, str)</span><br><span class="line"><span class="comment">//输出：str = 123 str = string</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符串转[]byte：var bytes &#x3D; []byte(“hello go”)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bytes = []<span class="type">byte</span>(<span class="string">&quot;hello go&quot;</span>) <span class="comment">// 对应的ascii编码</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;bytes = %v &quot;</span>, bytes)</span><br><span class="line"><span class="comment">//输出：bytes = [104 101 108 108 111 32 103 111]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>[]byte转字符串：str &#x3D; string([]byte{97,98,99})</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str := <span class="type">string</span>([]<span class="type">byte</span>&#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str = %v &quot;</span>, str)</span><br><span class="line"><span class="comment">//输出：str = abc</span></span><br></pre></td></tr></table></figure>

<ul>
<li>10进制转2、8、16进制：str &#x3D; strconv.FormatInt(123,2)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str := strconv.FormatInt(<span class="number">123</span>, <span class="number">2</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str = %v &quot;</span>, str)</span><br><span class="line"><span class="comment">//输出：str = 1111011</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查找子串是否在指定字符串中：strings.Contains(“seafood”,”foo”)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b := strings.Contains(<span class="string">&quot;seafood&quot;</span>, <span class="string">&quot;foo&quot;</span>)</span><br><span class="line">fmt.Println(b)</span><br><span class="line"><span class="comment">//输出：true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>统计一个字符串有几个指定子串：strings.Count(“ceheese”,”e”)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b := strings.Count(<span class="string">&quot;ceheese&quot;</span>, <span class="string">&quot;e&quot;</span>)</span><br><span class="line">fmt.Println(b)</span><br><span class="line"><span class="comment">//输出：4</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>不区分大小写的字符串比较：fmt.Println(strings.EqualFold(“abc”,”Abc”))</p>
<p>两个等号区分大小写</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(strings.EqualFold(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;Abc&quot;</span>))</span><br><span class="line"><span class="comment">//输出：true</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Abc&quot;</span> == <span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="comment">//输出：false</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>返回子串在字符串第一次出现的index，如果没有返回-1：strings.Index(“NLT_abc”,”abc”)</p>
<p>如果主串中有多个子串字符，则返回第一个</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">index := strings.Index(<span class="string">&quot;NLT_abc&quot;</span>, <span class="string">&quot;abc&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;位置是:%v&quot;</span>, index)</span><br><span class="line"><span class="comment">//输出：位置是:4</span></span><br></pre></td></tr></table></figure>

<ul>
<li>返回子串在字符串最后一次出现的index，如果没有返回-1：strings.LastIndex(“go golang”,”go”)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">index := strings.LastIndex(<span class="string">&quot;go golang&quot;</span>, <span class="string">&quot;go&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;位置是:%v&quot;</span>, index)</span><br><span class="line"><span class="comment">//输出：位置是:3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将指定的子串替换成另一个子串：strings.Replace(“go go hello”,”go”,”go语言”,n)n可以指定你希望替换的几个，如果n&#x3D;-1表示全部替换</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">result := strings.Replace(<span class="string">&quot;go go golang&quot;</span>, <span class="string">&quot;go&quot;</span>, <span class="string">&quot;go语言&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">//替换后返回新串，原串不变化</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;输出：%v&quot;</span>, result)</span><br><span class="line"><span class="comment">//输出：go语言 go golang</span></span><br></pre></td></tr></table></figure>

<ul>
<li>按照指定的某个字符，为分割标识，将一个字符串拆分成字符串数组：strings.Split(“hello,world,ok”, “,”)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">result := strings.Split(<span class="string">&quot;hello,world,ok&quot;</span>, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;输出：%v\n&quot;</span>, result)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(result); i++ &#123;</span><br><span class="line">  	fmt.Printf(<span class="string">&quot;result[%v] = %v\n&quot;</span>, i, result[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：[hello world ok]</span></span><br><span class="line"><span class="comment">//result[0] = hello</span></span><br><span class="line"><span class="comment">//result[1] = world</span></span><br><span class="line"><span class="comment">//result[2] = ok   </span></span><br></pre></td></tr></table></figure>

<ul>
<li>将字符串的字母进行大小写的转换：strings.ToLower(“Go”)&#x2F;&#x2F;go strings.ToUpper(“Go”)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str := <span class="string">&quot;goLang Hello&quot;</span></span><br><span class="line">result := strings.ToLower(str)</span><br><span class="line">fmt.Printf(<span class="string">&quot;输出：%v\n&quot;</span>, result)</span><br><span class="line"><span class="comment">//输出：golang hello</span></span><br><span class="line"></span><br><span class="line">str := <span class="string">&quot;goLang Hello&quot;</span></span><br><span class="line">result := strings.ToUpper(str)</span><br><span class="line">fmt.Printf(<span class="string">&quot;输出：%v\n&quot;</span>, result)</span><br><span class="line"><span class="comment">//输出：GOLANG HELLO</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将字符串左右两边的空格去掉：strings.TrimSpace(“ tn a lone gopher ntrn  “)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">result := strings.TrimSpace(<span class="string">&quot; tn a lone gopher ntrn  &quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;输出：%q\n&quot;</span>, result)</span><br><span class="line"><span class="comment">//输出：&quot;tn a lone gopher ntrn&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>将字符串左右两边指定字符去掉：strings.Trim(“! hello! “, “ !”)</p>
</li>
<li><p>将字符串左边指定字符去掉：strings.TeimLeft(“! hello! “,” !”)</p>
</li>
<li><p>将字符串右边指定字符去掉：strings.TeimRight(“! hello! “,” !”)</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">result := strings.Trim(<span class="string">&quot;! hello! &quot;</span>, <span class="string">&quot; !&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;输出：%q\n&quot;</span>, result)</span><br><span class="line"><span class="comment">//输出：&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>判断字符串是否一指定的字符串开头：strings.HasPrefix(“ftp:198.168.10.1”,”ftp”)</li>
<li>判断字符串是否一指定的字符串结束：strings.HasSuffix(“NLT_abc.jpg”,”abc”)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">result := strings.HasPrefix(<span class="string">&quot;ftp:198.168.10.1&quot;</span>, <span class="string">&quot;ftp&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;输出：%v\n&quot;</span>, result)</span><br><span class="line"><span class="comment">//输出：true</span></span><br><span class="line">result := strings.HasSuffix(<span class="string">&quot;NLT_abc.jpg&quot;</span>, <span class="string">&quot;abc&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;输出：%v\n&quot;</span>, result)</span><br><span class="line"><span class="comment">//输出：false</span></span><br></pre></td></tr></table></figure>

<h3 id="时间和日期相关函数"><a href="#时间和日期相关函数" class="headerlink" title="时间和日期相关函数"></a>时间和日期相关函数</h3><p><strong>基本介绍：</strong>在编程中，程序员会经常使用到日期相关的函数，比如：统计某段代码执行话费的时间等</p>
<ul>
<li>时间和日期相关函数，需要引入time包</li>
<li>获取当前时间now :&#x3D; time.Now()</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">result := time.Now()</span><br><span class="line">fmt.Printf(<span class="string">&quot;输出：%v\ntype = %T&quot;</span>, result, result)</span><br></pre></td></tr></table></figure>

<ul>
<li>如何获取其他日期信息</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;年 = %v\n&quot;</span>, result.Year())</span><br><span class="line">fmt.Printf(<span class="string">&quot;月 = %v\n&quot;</span>, result.Month())</span><br><span class="line">fmt.Printf(<span class="string">&quot;日 = %v\n&quot;</span>, result.Day())</span><br><span class="line">fmt.Printf(<span class="string">&quot;时 = %v\n&quot;</span>, result.Hour())</span><br><span class="line">fmt.Printf(<span class="string">&quot;分 = %v\n&quot;</span>, result.Minute())</span><br><span class="line">fmt.Printf(<span class="string">&quot;秒 = %v\n&quot;</span>, result.Second())</span><br></pre></td></tr></table></figure>

<ul>
<li>格式化日期时间</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;当前年月日：%d-%d-%d %d:%d:%d&quot;</span>, result.Year(), result.Month(), result.Day(), result.Hour(), result.Minute(),result.Second())</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(result.Format(<span class="string">&quot;2006/01/02 15:04:05&quot;</span>))<span class="comment">//输入内容固定</span></span><br><span class="line">fmt.Printf(result.Format(<span class="string">&quot;2006/01/02&quot;</span>))</span><br><span class="line">fmt.Printf(result.Format(<span class="string">&quot;15:04:05&quot;</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间的常量</p>
<p>常量的作用：在程序中可用于获取指定时间单位的时间，比如100毫秒</p>
<p>Hour、Minute、Secon、Millisecond、Microsecond、Nanosecond</p>
</li>
<li><p>休眠：time.Sleep(100 * time.Millisecond)</p>
</li>
<li><p>Unix时间戳和Unixnano时间戳（可以获取随机数字）</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Printf(<span class="string">&quot;Unix: %v\nUnixnano: %v&quot;</span>, now.Unix(), now.UnixNano())</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test03</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot; &quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line">		str += <span class="string">&quot;hello&quot;</span> + strconv.Itoa(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	start := time.Now().Unix()</span><br><span class="line">	test03()</span><br><span class="line">	end := time.Now().Unix()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;一共花费时间为%v秒&quot;</span>, end-start)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p><strong>基本介绍：</strong>Golang设计者为了编程方便，提供了一些函数，这些函数可以直接使用，我们称为Go的内置函数</p>
<ul>
<li>len：用来求长度，比如string、array、slice、map、channel</li>
<li>new：用来分配内存，主要用来分配值类型，比如int、float32、struct…返回是指针</li>
<li>make：用来分配内存，主要用来分配引用类型，比如map、chan、slice</li>
</ul>
<h3 id="Go错误处理机制"><a href="#Go错误处理机制" class="headerlink" title="Go错误处理机制"></a>Go错误处理机制</h3><ul>
<li>在默认情况下，当发生错误后（panic），程序就会退出（崩溃）</li>
<li>如果希望，当发生错误后我们可以捕获该错误，并进行处理，保证代码可以继续执行，还可以在捕获错误后给管理员一个提示（邮件、短信）</li>
</ul>
<p><strong>基本介绍：</strong></p>
<ul>
<li>Go语言主球简洁优雅，所以Go语言不支持传统的try…catch…finally这种处理</li>
<li>Go中引入的处理方式为：<strong>defer，panic，recover</strong></li>
<li>这几个异常的使用场景可以这么简单描述：Go中可以抛出一个panic的异常，然后再defer中通过<strong>recover捕获这个异常</strong>，然后正常处理</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    err := <span class="built_in">recover</span>()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      	fmt.Println(<span class="string">&quot;err =&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>错误处理的好处：进行错误处理后，程序不会轻易挂掉，如果加入预警代码，就可以让程序更加的健壮</p>
<h3 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h3><p>Go程序中，也支持自定义错误，使用erroes.New和panic内置函数</p>
<ul>
<li>errors.New(“错误说明”)，会返回一个error类型的值，表示一个错误</li>
<li>panic内置函数，接收一个interface{}类型的值（也就是任何值）作为参数。可以接收error类型的变量，<strong>输出错误信息并退出程序</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件名，如果文件名不正确则返回一个error错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readConf</span><span class="params">(name <span class="type">string</span>)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;config.ini&quot;</span> &#123;</span><br><span class="line">  		<span class="comment">//读取...</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">//返回一个自定义错误</span></span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;读取文件错误&quot;</span>)  <span class="comment">//自定义错误</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := readConf(<span class="string">&quot;config.ini&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      	<span class="comment">//如果读取文件发送错误，就输出这个错误，并终止程序</span></span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;test中代码块&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  	<span class="comment">//测试自定义错误的使用</span></span><br><span class="line">	test()</span><br><span class="line">	fmt.Println(<span class="string">&quot;main中代码块&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//23行处有报错（程序报错），但可以编译运行</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h2><h3 id="数组介绍"><a href="#数组介绍" class="headerlink" title="数组介绍"></a>数组介绍</h3><p><strong>基本介绍：</strong>数组可以存放多个同一种类型数据。数组也是一种数据类型，在Go中数组是值类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  	<span class="comment">//声明数组</span></span><br><span class="line">	<span class="keyword">var</span> hens [<span class="number">6</span>]<span class="type">float64</span></span><br><span class="line">	hens[<span class="number">0</span>] = <span class="number">3.0</span></span><br><span class="line">	hens[<span class="number">1</span>] = <span class="number">5.0</span></span><br><span class="line">	hens[<span class="number">2</span>] = <span class="number">1.0</span></span><br><span class="line">	hens[<span class="number">3</span>] = <span class="number">3.4</span></span><br><span class="line">	hens[<span class="number">4</span>] = <span class="number">2.0</span></span><br><span class="line">	hens[<span class="number">5</span>] = <span class="number">5.0</span></span><br><span class="line"></span><br><span class="line">	totalWeight := <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(hens); i++ &#123;</span><br><span class="line">		totalWeight += hens[i]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	avgWeight := fmt.Sprintf(<span class="string">&quot;%.2f&quot;</span>, totalWeight/<span class="type">float64</span>(<span class="built_in">len</span>(hens)))</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;total = %v\navg = %v&quot;</span>, totalWeight, avgWeight)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用数组来解决问题，程序的可维护性增加了，代码清晰容易扩展</p>
<h3 id="数组定义和内存布局"><a href="#数组定义和内存布局" class="headerlink" title="数组定义和内存布局"></a>数组定义和内存布局</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组定义：</span></span><br><span class="line"><span class="keyword">var</span> 数组名 [数组大小]数据类型</span><br></pre></td></tr></table></figure>

<p>当定义完数组之后，数组就有默认值，为0</p>
<p>内存布局：</p>
<ul>
<li>数组的地址可以通过数组名获取</li>
<li>数组的第一个元素的地址是数组的首地址</li>
<li>数组的内存是连续分布</li>
<li>数组元素间隔取决于数组类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> score [<span class="number">6</span>]<span class="type">float64</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(score); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;请输入地%v个学生成绩&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		fmt.Scanln(&amp;score[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(score); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;score[%v] = %v&quot;</span>, i, score[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组初始化的四种方式：</p>
<ul>
<li>var nums [3]int &#x3D; [3]int {1, 2, 3}</li>
<li>var nums &#x3D; [3]int {1, 2, 3}</li>
<li>var nums &#x3D; […]int {1, 2, 3}  &#x2F;&#x2F;这里的…是固定写法</li>
<li>var names &#x3D; [3]string{1:”tom”, 0:”jack”, 2:”marry”}</li>
</ul>
<h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p><strong>基本介绍：</strong></p>
<p>方式一：常规遍历方式，通过for循环，遍历数组下标</p>
<p>方式二：for-range结构</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index, value :=<span class="keyword">range</span> array01 &#123;    <span class="comment">//array01为数组名称</span></span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项和使用细节：</strong> </p>
<ul>
<li>第一个返回值index是数组下标</li>
<li>第二个返回值value是在该下标位置的值</li>
<li>两个返回值都是仅在for循环内部可见的<strong>局部变量</strong></li>
<li>遍历数组元素的时候，如果不想使用下标index，可以把下标index标为下划线_</li>
<li>index和value的名称不是固定的，即程序员可以自行指定，一般命名为index和value</li>
</ul>
<h3 id="数组使用"><a href="#数组使用" class="headerlink" title="数组使用"></a>数组使用</h3><p><strong>注意事项和使用细节：</strong></p>
<ul>
<li><p>数组是多个<strong>同类型数据</strong>的组合，一个数组一旦声明&#x2F;定义了。其<strong>长度是固定的</strong>，不能动态变动</p>
</li>
<li><p>var arr []int这是arr就是一个slice切片，详见切片章节</p>
</li>
<li><p>数组中的元素可以是任何数据类型，包括值类型和引用类型，但不能混用</p>
</li>
<li><p>数组创建后，如果没有赋值，含有默认值</p>
<p>数值类型数组，默认值为0</p>
<p>字符串类型数组，默认值为””</p>
<p>bool类型数组，默认值为false</p>
</li>
<li><p>使用数组步骤：</p>
<ol>
<li>声明数组并开辟空间</li>
<li>给数组各个元素赋值</li>
<li>使用数组</li>
</ol>
</li>
<li><p>数组的下标是<strong>从0开始的</strong></p>
</li>
<li><p>数组下标必须在指定范围内使用，否则报panic：数组越界</p>
</li>
<li><p>Go的数组属<strong>值类型</strong>，在默认情况下是值传递</p>
</li>
<li><p>如果想在其他函数中，去修改原来的数组，可以使用引用传递（指针方式）</p>
</li>
<li><p><strong>长度是数组类型的一部分</strong>，在传递函数参数时需要考虑数组长度</p>
</li>
</ul>
<h3 id="slice切片"><a href="#slice切片" class="headerlink" title="slice切片"></a>slice切片</h3><p>当我们需要保存<strong>个数不确定</strong>的数据</p>
<p><strong>基本介绍：</strong></p>
<ul>
<li><p>切片是数组的一个引用，因此<strong>切片是引用类型</strong>，在进行传递，遵守引用传递的机制</p>
</li>
<li><p>切片的使用和数组类似，遍历切片、访问切片的元素和求切片长度len(slice)一样</p>
</li>
<li><p>切片长度是可以变化的，因此切片是一个可以动态变换数组</p>
</li>
<li><p>切片定义的基本语法：</p>
<p>var 变量名 []类型</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intArr [<span class="number">5</span>]<span class="type">int</span> = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">slice := intArr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment">//1.slice就是切片名</span></span><br><span class="line"><span class="comment">//2.intArr[1:3]表示slice引用到intArr这个数组</span></span><br><span class="line"><span class="comment">//3.引用数组的起始下标为1，终止下标为3，不包含3</span></span><br><span class="line"><span class="built_in">len</span>(slice)<span class="comment">//slice的元素个数</span></span><br><span class="line"><span class="built_in">cap</span>(slice)<span class="comment">//slice的容量</span></span><br></pre></td></tr></table></figure>

<p><strong>切片在内存中形式：</strong></p>
<p>切片为引用类型，在内存中，slice由三个部分构成：</p>
<p>首先，slice存放指向的首地址，&amp;slice[0] &#x3D; &amp;intArr[1]，slice[0] &#x3D; intArr[1]</p>
<p>其次，存放slice的长度</p>
<p>最后，存放slice的容量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//slice从底层上说就是一个结构体</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    ptr *[<span class="number">2</span>]<span class="type">int</span></span><br><span class="line">    <span class="built_in">len</span> <span class="type">int</span></span><br><span class="line">    <span class="built_in">cap</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="切片使用方式"><a href="#切片使用方式" class="headerlink" title="切片使用方式"></a>切片使用方式</h3><p>方式一：定义一个切片，然后让切片引用一个已经创建好的数组</p>
<p>方式二：通过<strong>make</strong>来创建切片</p>
<p>​		var 切片名 []type &#x3D; make ([],len,cap)</p>
<p>​		type：数据类型；len：大小；cap：容量。cap可以不写，但如果写了需要大于len</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="type">float64</span> = <span class="built_in">make</span>([]<span class="type">float64</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">slice[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line">slice[<span class="number">3</span>] = <span class="number">20</span></span><br><span class="line">fmt.Println(slice)</span><br><span class="line">fmt.Println(<span class="string">&quot;slice的长度为&quot;</span>, <span class="built_in">len</span>(slice))</span><br><span class="line">fmt.Println(<span class="string">&quot;slice的容量为&quot;</span>,<span class="built_in">cap</span>(slice))</span><br><span class="line"><span class="comment">//[0 10 0 20 0]</span></span><br><span class="line"><span class="comment">//slice的长度为 5 </span></span><br><span class="line"><span class="comment">//slice的容量为 10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过make方式创建切片可以指定切片的大小和容量</li>
<li>如果没有给切片的各个元素赋值就会使用默认值</li>
<li>通过make创建的切片对应的数组室友make底层维护，对外不可见，只能通过slice访问切片</li>
</ul>
<p>方式三：定义一个切片，直接就指定具体数组，使用原理类似make的方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="type">string</span> = []<span class="type">string</span>&#123;<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;jack&quot;</span>, <span class="string">&quot;marry&quot;</span>&#125;</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">fmt.Println(<span class="string">&quot;slice的长度为&quot;</span>, <span class="built_in">len</span>(slice))</span><br><span class="line">fmt.Println(<span class="string">&quot;slice的容量为&quot;</span>, <span class="built_in">cap</span>(slice))</span><br><span class="line"><span class="comment">//[tom jack marry]</span></span><br><span class="line"><span class="comment">//slice的长度为 3</span></span><br><span class="line"><span class="comment">//slice的容量为 3</span></span><br></pre></td></tr></table></figure>

<p><strong>切片使用方式的区别：</strong></p>
<p>方式一是直接引用数组，这个数组是事先存在的，程序员是可见的</p>
<p>方式二是通过make来创建切片，make也会创建一个数组，是有切片在底层进行维护，程序员无法看见</p>
<h3 id="切片遍历"><a href="#切片遍历" class="headerlink" title="切片遍历"></a>切片遍历</h3><p>切片遍历和数组遍历类似，可以通过for循环进行遍历，也可以通过for-range结构进行遍历</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="type">int</span> = [...]<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line">slice := arr&#123;<span class="number">1</span>,<span class="number">4</span>&#125;<span class="comment">//20, 30, 40</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ &#123;</span><br><span class="line">  	fmt.Printf(<span class="string">&quot;slice[%v] = %v\n&quot;</span>, i, slice[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;slice[%v] = %v\n&quot;</span>, index, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li><p>切片初始化时var slice &#x3D; arr[startIndex:endIndex]</p>
<p>从arr数组下标为startIndex，取到下标endIndex的元素（不包含endIndex）</p>
</li>
<li><p>切片初始化时，仍然不能越界。范围在[0-len(slice)]，到那时可以动态增长</p>
<p>var slice &#x3D; arr [0:end]                  可以简写为      var slice &#x3D; arr[:end]</p>
<p>var slice &#x3D; arr[start:len(arr)]       可以简写为      var slice &#x3D; arr[start:]</p>
<p>var slice &#x3D; arr[0:len(arr)]             可以简写为      var slice &#x3D; arr[:]</p>
</li>
<li><p>cap是一个内置函数，用于统计切片的容量，即最大可以存放多少个元素</p>
</li>
<li><p>切片定义完后，还不能使用，因为本身是一个空的，需要让其引用到一个数组，或者make一个空间供切片来使用</p>
</li>
<li><p>切片可以<strong>继续切片</strong></p>
</li>
<li><p>用<strong>append内置函数</strong>，可以对切片进行动态追加</p>
<p>切片append操作的本质就是对数组扩容</p>
<p>go底层会闯将一下新的数组newArr（安装扩容后大小）</p>
<p>将slice原来包含的元素拷贝到新的数组newArr</p>
<p>slice重新引用到newArr</p>
<p>注意newArr是在底层来维护的</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="type">int</span> = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">slice = <span class="built_in">append</span>(slice, slice...)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line"><span class="comment">//append后可为一个数据、多个数据、切片</span></span><br><span class="line"><span class="comment">//当append后为数据时，数据类型必须相同</span></span><br><span class="line"><span class="comment">//当append后为切片时，切片后需要有...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>切片的拷贝操作</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span> = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line"><span class="built_in">copy</span>(slice, a)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line"><span class="comment">//[0 0 0 0 0 0 0 0 0 0]</span></span><br><span class="line"><span class="comment">//[1 2 3 4 5 0 0 0 0 0]</span></span><br><span class="line"><span class="comment">//数据空间独立，不会进行相互干涉</span></span><br><span class="line"><span class="comment">//copy(slice1,slice2)要求数据类型都是切片</span></span><br><span class="line"><span class="comment">//若slice2容量大于slice1也不会报错仅拷贝前面部分</span></span><br></pre></td></tr></table></figure>

<ul>
<li>切片时引用类型，所以在传递时，遵循引用传递机制</li>
</ul>
<h3 id="string和slice"><a href="#string和slice" class="headerlink" title="string和slice"></a>string和slice</h3><ul>
<li><p>string底层是一个byte数组，因此string也可以进行切片处理</p>
</li>
<li><p>string和切片在内存的形式</p>
</li>
<li><p>string是不可变的，也就是说不能通过str[0] &#x3D; ‘z’方式来修改字符2</p>
</li>
<li><p>如果需要修改字符串，可以先将string-&gt;<strong>[]byte</strong>或**[]rune**-&gt;修改-&gt;重写转成string</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str := <span class="string">&quot;hello@atguigu&quot;</span></span><br><span class="line">slice := []<span class="type">byte</span>(str)</span><br><span class="line">slice[<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span></span><br><span class="line">str = <span class="type">string</span>(slice)</span><br><span class="line">fmt.Println(str)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中文替换</span></span><br><span class="line">str := <span class="string">&quot;hello@atguigu&quot;</span></span><br><span class="line">slice := []<span class="type">rune</span>(str)</span><br><span class="line">slice[<span class="number">0</span>] = <span class="string">&#x27;北&#x27;</span></span><br><span class="line">str = <span class="type">string</span>(slice)</span><br><span class="line">fmt.Println(str)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用切片输出斐波那契数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fbn</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">uint64</span> &#123;</span><br><span class="line">	fbnSlice := <span class="built_in">make</span>([]<span class="type">uint64</span>, n)</span><br><span class="line">	fbnSlice[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	fbnSlice[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++ &#123;</span><br><span class="line">		fbnSlice[i] = fbnSlice[i<span class="number">-1</span>] + fbnSlice[i<span class="number">-2</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fbnSlice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>使用方式：先声明&#x2F;定义再赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line"><span class="keyword">var</span> 数组名 [大小][大小]类型</span><br><span class="line"><span class="keyword">var</span> 数组名 [大小][大小]类型 = [大小][大小]类型&#123;&#123;初值&#125;,&#123;初值&#125;,.&#125;</span><br><span class="line"><span class="keyword">var</span> 数组名 [大小][大小]类型 = [...][大小]类型&#123;&#123;初值&#125;,&#123;初值&#125;,.&#125;</span><br><span class="line"><span class="keyword">var</span> 数组名 = [大小][大小]类型&#123;&#123;初值&#125;,&#123;初值&#125;,.&#125;</span><br><span class="line"><span class="keyword">var</span> 数组名 = [...][大小]类型&#123;&#123;初值&#125;,&#123;初值&#125;,.&#125;</span><br></pre></td></tr></table></figure>

<p>二维数组遍历：</p>
<ul>
<li>双层for循环完成遍历</li>
<li>for-range方式完成遍历</li>
</ul>
<hr>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map是kay-value数据结构，又称为字段或者关联数组。类似其他编程语言的集合，在编程中经常用到</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本语法</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">map</span>变量名 <span class="keyword">map</span>[keytype]valuetype</span><br></pre></td></tr></table></figure>

<p>key可以是什么类型：</p>
<p>Golang中map的key可以时很多类型，例如：bool、数字、string、指针、channel，还可以是只包含前面几个类型的接口、结构体、数组，<strong>通常为int、string</strong></p>
<p>注意：slice、map和function是不可以的</p>
<p>valuetype可以是什么类型：</p>
<p>valuetype的类型和key基本一样，<strong>通常为数字（整数、浮点数）、string、map、struct</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//map的声明</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line"><span class="comment">//注意：声明不会分配内存的，初始化需要make，分配内存后才能赋值和使用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//map的声明和注意事项 key不可以重复，若key重复则会覆盖</span></span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">	<span class="comment">//在使用map前，需要先make，make的作用就是给map分配数据空间</span></span><br><span class="line">	a = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line">	a[<span class="string">&quot;no1&quot;</span>] = <span class="string">&quot;宋江&quot;</span></span><br><span class="line">	a[<span class="string">&quot;no2&quot;</span>] = <span class="string">&quot;吴用&quot;</span></span><br><span class="line">	a[<span class="string">&quot;no3&quot;</span>] = <span class="string">&quot;武松&quot;</span></span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//map在Golang中是无序的</span></span><br></pre></td></tr></table></figure>

<h3 id="map的使用方式"><a href="#map的使用方式" class="headerlink" title="map的使用方式"></a>map的使用方式</h3><ul>
<li>方式一：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明，这时map=nil</span></span><br><span class="line"><span class="keyword">var</span> cities <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line"><span class="comment">//make(map[strign]string, 空间)分配一个map空间</span></span><br><span class="line">cities = <span class="built_in">make</span>(<span class="keyword">map</span>[strign]<span class="type">string</span>, 空间)</span><br></pre></td></tr></table></figure>

<ul>
<li>方式二：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明，直接make</span></span><br><span class="line"><span class="keyword">var</span> cities = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>方式三：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明，直接赋值</span></span><br><span class="line"><span class="keyword">var</span> cities <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">  <span class="string">&quot;no1&quot;</span>:<span class="string">&quot;成都&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>map使用前一定要make</strong></p>
<h3 id="map的增删改查"><a href="#map的增删改查" class="headerlink" title="map的增删改查"></a>map的增删改查</h3><ul>
<li>增加和更新：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="string">&quot;key&quot;</span>] = value <span class="comment">//如果key不存在就是增加，如果key存在就是修改</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//仅需删除cities中一个元素时</span></span><br><span class="line"><span class="built_in">delete</span>(cities, <span class="string">&quot;no1&quot;</span>)</span><br><span class="line"><span class="comment">//当delete指定的key不存在时，删除不会操作，也不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除所有cities，可重新定义一遍</span></span><br><span class="line">cities = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>查找</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回ok为bool类型，val为值类型</span></span><br><span class="line">val, ok := cities[<span class="string">&quot;no1&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">  	fmt.Printf(<span class="string">&quot;有no1 ket值为%v\n&quot;</span>, val)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  	fmt.Printf(<span class="string">&quot;没有no1 key\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="map遍历"><a href="#map遍历" class="headerlink" title="map遍历"></a>map遍历</h3><p>map的遍历使用for-range的结构遍历，无法使用for循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> cities &#123;</span><br><span class="line">  	fmt.Printf(<span class="string">&quot;k = %v v = %v\n&quot;</span>, k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="map切片"><a href="#map切片" class="headerlink" title="map切片"></a>map切片</h3><p><strong>基本介绍：</strong>切片的数据类型如果是map，则我们称为slice of map，map切片，这样使用则map个数就可以动态变化了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//声明一个map切片</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> monsters []<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">	monsters = <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">2</span>) <span class="comment">//对切片进行make</span></span><br><span class="line">	<span class="keyword">if</span> monsters[<span class="number">0</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">		monsters[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">2</span>) <span class="comment">//对map进行make</span></span><br><span class="line">		monsters[<span class="number">0</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;牛魔王&quot;</span></span><br><span class="line">		monsters[<span class="number">0</span>][<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;500&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> monsters[<span class="number">1</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">		monsters[<span class="number">1</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">2</span>) <span class="comment">//对map进行make</span></span><br><span class="line">		monsters[<span class="number">1</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;玉兔精&quot;</span></span><br><span class="line">		monsters[<span class="number">1</span>][<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;400&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">  	</span><br><span class="line">	<span class="comment">//下方例子越界</span></span><br><span class="line">	<span class="comment">//if monsters[2] == nil &#123;</span></span><br><span class="line">	<span class="comment">//	monsters[2] = make(map[string]string, 2) //对map进行make</span></span><br><span class="line">	<span class="comment">//	monsters[2][&quot;name&quot;] = &quot;狐狸精&quot;</span></span><br><span class="line">	<span class="comment">//	monsters[2][&quot;age&quot;] = &quot;300&quot;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里我们使用切片的动态增长append函数</span></span><br><span class="line">	newMonsters := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;name&quot;</span>: <span class="string">&quot;新妖怪&quot;</span>,</span><br><span class="line">		<span class="string">&quot;age&quot;</span>:  <span class="string">&quot;200&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	monsters = <span class="built_in">append</span>(monsters, newMonsters)</span><br><span class="line">	fmt.Println(monsters)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过map切动态增加</span></span><br></pre></td></tr></table></figure>



<h3 id="map排序"><a href="#map排序" class="headerlink" title="map排序"></a>map排序</h3><p><strong>基本介绍：</strong></p>
<ul>
<li>Golang中<strong>没有一个专门的方法针对map的key进行排序</strong></li>
<li>Golang中的map默认是无序的，注意也不是按照添加的顺序存放的，每次遍历的输出可能不一样</li>
<li>Golang中map的排序，是先将key进行排序，然后根据key值遍历输出</li>
</ul>
<p><strong>Golang中map中排序：</strong></p>
<ol>
<li>先将map的key放到切片</li>
<li>对切片排序</li>
<li>遍历切片，然后按照key来输出map的值</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	map1[<span class="number">10</span>] = <span class="number">100</span></span><br><span class="line">	map1[<span class="number">1</span>] = <span class="number">13</span></span><br><span class="line">	map1[<span class="number">4</span>] = <span class="number">56</span></span><br><span class="line">	map1[<span class="number">8</span>] = <span class="number">90</span></span><br><span class="line">	fmt.Println(map1)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> keys []<span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> k, _ := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">		keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//排序</span></span><br><span class="line">	sort.Ints(keys)</span><br><span class="line">	fmt.Println(keys)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//由已经排序好的keys的输出map</span></span><br><span class="line">	<span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;map[%v] = %v\n&quot;</span>, k, map1[k])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="map的使用细节和陷阱"><a href="#map的使用细节和陷阱" class="headerlink" title="map的使用细节和陷阱"></a>map的使用细节和陷阱</h3><p><strong>注意事项和细节说明：</strong></p>
<ul>
<li>map是<strong>引用类型</strong>，遵守引用类型传递机制，在一个函数接收map修改后，会直接修改原来的map</li>
<li>map的容量达到后，如果希望map增加元素<strong>会自动扩容</strong>，并不会发生panic，<strong>map能动态的增长键值对（key-value）</strong></li>
<li>map的value也经常使用<strong>struct类型</strong>，更适合管理复杂的数据（比前面的value是一个map更好）</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="type">string</span></span><br><span class="line">	Age     <span class="type">int</span></span><br><span class="line">	Address <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	students := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]Stu, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	stu1 := Stu&#123;<span class="string">&quot;tom&quot;</span>, <span class="number">18</span>, <span class="string">&quot;北京&quot;</span>&#125;</span><br><span class="line">	stu2 := Stu&#123;<span class="string">&quot;marry&quot;</span>, <span class="number">16</span>, <span class="string">&quot;上海&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	students[<span class="string">&quot;no1&quot;</span>] = stu1</span><br><span class="line">	students[<span class="string">&quot;no2&quot;</span>] = stu2</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> students &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;学生编号是%v\n&quot;</span>, k)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;学生姓名是%v\n&quot;</span>, v.Name)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;学生年龄是%v\n&quot;</span>, v.Age)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;学生住址是%v\n&quot;</span>, v.Address)</span><br><span class="line">		fmt.Println()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="面向”对象“编程"><a href="#面向”对象“编程" class="headerlink" title="面向”对象“编程"></a>面向”对象“编程</h2><p>Golang语言面向对象编程说明：</p>
<ul>
<li>Golang也支持<strong>面向对象编程（OOP）</strong>，但是和传统的面向对象编程有区别，并<strong>不是纯粹的面向对象语言</strong>。所以我们说Golang支持面向对象编程特性是比较准确地</li>
<li><strong>Golang没有类（class）</strong>，Go语言的结构体（struct）和其他编程语言的类（class）有同等的地位，可以理解Golang是基于struct来实现OOP特性的</li>
<li>Golang面向对象编程非常简洁，去掉了传统OOP语言的继承、方法重载、构造函数和析构函数、隐藏的this指针等等</li>
<li>Golang仍然有面向对象编程的继承性，封装和多态的特性，只是实现方式和其他OOP语言不一样。例如继承：Golang没有extends关键字，继承通过匿名字段来实现</li>
<li>Golang面向对象（OOP）很优雅，OOP本身就是语言类型系统（type system）的一部分，通过接口（interface）关联，<strong>耦合性低</strong>，也非常灵活。也就是说Golang中<strong>面向接口编程</strong>是非常重要的特性</li>
</ul>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体与结构变量（实例&#x2F;对象）</p>
<ul>
<li>将一类事物的特性提取出来，形成一个新的数据类型，就是结构体</li>
<li>通过这个结构体我们可以创建多个变量</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="type">string</span></span><br><span class="line">	Age   <span class="type">int</span></span><br><span class="line">	Color <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> cat1 Cat</span><br><span class="line">	cat1.Name = <span class="string">&quot;小白&quot;</span></span><br><span class="line">	cat1.Age = <span class="number">10</span></span><br><span class="line">	cat1.Color = <span class="string">&quot;白色&quot;</span></span><br><span class="line">	fmt.Println(cat1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结构体是<strong>自定义的数据类型</strong>，代表一类事物</li>
<li>结构体变量(实例)是具体的、实际的，代表一个具体变量</li>
</ul>
<p><strong>结构体是一个值类型</strong></p>
<h3 id="结构体声明和是用缺陷"><a href="#结构体声明和是用缺陷" class="headerlink" title="结构体声明和是用缺陷"></a>结构体声明和是用缺陷</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体声明</span></span><br><span class="line"><span class="keyword">type</span> 结构体名称 <span class="keyword">struct</span> &#123;</span><br><span class="line">  	field1 <span class="keyword">type</span></span><br><span class="line">  	field2 <span class="keyword">type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基本介绍：</strong></p>
<ul>
<li>从概念或叫法上看：<strong>结构体字段 &#x3D; 属性 &#x3D; field</strong></li>
<li>字段是结构体的一个组成部分，一般是基本数据类型、数组，也可以是引用类型</li>
</ul>
<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>字段声明语法同变量</li>
<li>字段的类型可以为：基本类型、数组或引用类型</li>
<li>创建一个结构体变量后，如果没有给字段赋值，都对应一个零值（默认值）</li>
<li><strong>不同结构体变量</strong>的字段是独立的，互补影响的，一个结构体变量字段的更改不影响另一个</li>
</ul>
<p>如果结构体字段类型是<strong>slice和map的零值都是nil</strong>，即未分配空间。如果需要使用这样的字段需要先make在使用</p>
<h3 id="创建结构体变量和访问结构体字段"><a href="#创建结构体变量和访问结构体字段" class="headerlink" title="创建结构体变量和访问结构体字段"></a>创建结构体变量和访问结构体字段</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  	内容...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接声明</span></span><br><span class="line"><span class="keyword">var</span> person Person</span><br><span class="line"><span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> person Person = Person&#123;&#125;</span><br><span class="line">person := Person&#123;&#125;</span><br><span class="line"><span class="comment">//&amp;,new结果为指向结构体的指针</span></span><br><span class="line"><span class="keyword">var</span> person *Person = <span class="built_in">new</span>(Person)</span><br><span class="line"><span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> person *Person = &amp; Person&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基本介绍：</strong></p>
<ul>
<li>第三种和第四种返回的是<strong>结构体指针</strong></li>
<li>结构体指针访问字段的标准方式应该是：**(<em>结构体指针).字段名</em>*</li>
<li>Go做出了简化，支持<strong>结构体指针.字段名</strong></li>
</ul>
<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>结构体的所有字段在内存中是连续的</li>
<li>结构体是用户单独定义的类型，和其他类型进行转换时需要完全相同的字段</li>
<li>结构体进行type重新定义（相当于取别名），Golang认为是新的数据类型，但是<strong>相互可以强制转换</strong></li>
<li>struct的每个字段上，可以写一个tag，该tag可以通过<strong>反射机制</strong>获取，常见的使用场景就是<strong>序列化和发序列化</strong></li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><strong>基本介绍：</strong>在某些情况下，我们需要声明（定义）<strong>方法</strong>。比如Person结构体：除了一些字段外（年龄、姓名…），Person结构体还有一些行为比如：可以说话、跑步…</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法的声明和调用</span></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123;</span><br><span class="line">  	Num <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//A结构体有一个方法，方法名是test</span></span><br><span class="line"><span class="comment">//(a A)体现test方法是和A类型绑定的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> test()&#123;</span><br><span class="line">  	fmt.Println(a.Num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> test() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;test() Name =&quot;</span>, p.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p Person</span><br><span class="line">	p.Name = <span class="string">&quot;tom&quot;</span></span><br><span class="line">	p.test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>test方法和Person类型绑定</li>
<li><strong>test方法只能通过Person类型的变量来调用</strong>，而不能直接调用，也不能使用其他类型变量来调用</li>
<li>func (p Person) test(){}…   p类似于函数传参，p名字可以修改</li>
</ul>
<p>方法的调用和传参机制和函数基本一样，不一样的地方是方法调用时，会将调用方法的变量，当做实参也传递给方法</p>
<h3 id="方法的声明（定义）"><a href="#方法的声明（定义）" class="headerlink" title="方法的声明（定义）"></a>方法的声明（定义）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recevier <span class="keyword">type</span>)</span></span> methodName (参数列表) (返回值列表) &#123;</span><br><span class="line">  	方法体</span><br><span class="line">  	<span class="keyword">return</span> 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基本介绍：</strong></p>
<ul>
<li><strong>参数列表：表示方法输入</strong></li>
<li>recevier type：表示这个方法和type这个类型进行绑定，或者说该方法作用于type类型</li>
<li>receiver type：type可以是结构体也可以是其他的自定义类型</li>
<li>recriver type：就是type类型的一个变量（实例），比如：Person结构体的一个变量（实例）</li>
<li><strong>返回值列表：表示返回的值，可以多个</strong></li>
<li><strong>方法主体：表示为了实现某一功能代码块</strong></li>
<li><strong>return 语句不是必须的</strong></li>
</ul>
<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>结构体类型是值类型，在方法调用中，遵守值类型的传递机制，是值拷贝传递方式</li>
<li>如程序员希望在方法中修改结构体变量的值，可以通过结构体指针的方式来处理</li>
<li>Golang中的<strong>方法作用在指定的数据类型上</strong>的（即：和指定的数据类型绑定），因此<strong>自定义类型都可以有方法</strong>，而不仅仅是struct</li>
<li>方法的访问范围控制的规则，和函数一样，方法名首字母小写，只能在本报包访问；方法首字母大写，可以在本包和其他包访问</li>
<li>如果一个类型实现String()这个方法，那么fmt.Println默认会调用这个变量的String()进行输出</li>
</ul>
<h3 id="方法和函数区别"><a href="#方法和函数区别" class="headerlink" title="方法和函数区别"></a>方法和函数区别</h3><ul>
<li><p>调用方式不一样</p>
<p>函数调用方式：函数名（实参列表）</p>
<p>方法调用方式：变量.方法名（实参列表）</p>
</li>
<li><p>对于普通函数，接受者为值类型时，不能将指针类型的数据直接传递，反之亦然</p>
</li>
<li><p>对于方法（如struct的方法），接受者为值类型时，可以直接用指针类型的变量调用方法，反过来也可以接收。<strong>具体类型看方法的接收类型</strong></p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(num *MyInt)</span></span> Sum() &#123;</span><br><span class="line">	*num = *num + <span class="number">1</span></span><br><span class="line">	fmt.Println(*num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num MyInt</span><br><span class="line">	num = <span class="number">100</span></span><br><span class="line">  	</span><br><span class="line">	num.Sum()</span><br><span class="line">	fmt.Println(num)</span><br><span class="line">	(&amp;num).Sum()</span><br><span class="line">	fmt.Println(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面向对象编程应用"><a href="#面向对象编程应用" class="headerlink" title="面向对象编程应用"></a>面向对象编程应用</h3><h4 id="面向对象步骤"><a href="#面向对象步骤" class="headerlink" title="面向对象步骤"></a>面向对象步骤</h4><ul>
<li>声明（定义）结构体，确定结构体名</li>
<li>编写结构体的字段</li>
<li>编写结构体的方法</li>
</ul>
<h4 id="结构体赋值"><a href="#结构体赋值" class="headerlink" title="结构体赋值"></a>结构体赋值</h4><ul>
<li>在创建结构体变量时，就直接指定字段的值。将字段名和字段值写在一起，不依赖与顺序</li>
<li>返回结构体的指针类型</li>
</ul>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>使用工厂模式实现挎包创建结构体实例（变量）</p>
<ul>
<li><p>如果model包的结构体变量首字母大写，引入后可直接使用</p>
</li>
<li><p>如果model包的结构体变量首字母小写，可使用工厂模式解决</p>
<p>在model包中创建一个方法或函数，从而调用</p>
</li>
</ul>
<h3 id="面向对象编程思想-抽象"><a href="#面向对象编程思想-抽象" class="headerlink" title="面向对象编程思想-抽象"></a>面向对象编程思想-抽象</h3><p>如何理解抽象：我们在前面去定义一个结构体时候，实际上就是把一类事物的<strong>共有的属性（字段）和行为（方法）</strong>提取出来，形成一个物理模型（模板）。这种研究问题的方法称为抽象</p>
<h3 id="面向对象编程的三大特性（封装、继承、多态）"><a href="#面向对象编程的三大特性（封装、继承、多态）" class="headerlink" title="面向对象编程的三大特性（封装、继承、多态）"></a>面向对象编程的三大特性（封装、继承、多态）</h3><p><strong>基本介绍：</strong>Golang仍然有面向对象编程的继承，封装和多态的特性，只是实现的方式和其他OOP语言不太一样</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装介绍：封装（encapsulation）就是把抽象出的<strong>字段和对字段的操作</strong>封装在一起，数据被保护在内部，程序的其他包只通过被授权的操作（方法），才能访问字段进行操作</p>
<p>封装的好处：</p>
<ul>
<li>隐藏实现细节</li>
<li>提可以对数据进行验证，保证安全合理</li>
</ul>
<p>如何体现封装：</p>
<ul>
<li>对结构体中的属性进行封装</li>
<li>通过方法、包实现封装</li>
</ul>
<p>封装的实现步骤：</p>
<ol>
<li>将<strong>结构体、字段(属性)的首字母小写</strong>（不能导出了，其他包不能使用，类型private）</li>
<li>给结构体所在包提供一个工厂模式的<strong>函数，首字母大写</strong>。类似构造函数</li>
<li>提供一个<strong>首字母大写的Set方法</strong>（类似其他语言的public），用于对属性判断并赋值</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="keyword">var</span> 结构体类型名)</span></span> SetXxx(参数列表)(返回值列)&#123;</span><br><span class="line">  	<span class="comment">//加入数据验证的业务逻辑</span></span><br><span class="line">	<span class="keyword">var</span>.字段 = 参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>提供一个<strong>首字大写的Get方法</strong>（类似其他语言的public），用于获取属性的值</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="keyword">var</span> 结构体类型名)</span></span> GetXxx()&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">var</span>.字段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例演示</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;Test/model&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := model.NewPerson(<span class="string">&quot;smith&quot;</span>)</span><br><span class="line">	p.SetAge(<span class="number">18</span>)</span><br><span class="line">	p.SetSal(<span class="number">5000</span>)</span><br><span class="line">	fmt.Println(p.GetAge(), p.GetSal())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span>     <span class="comment">//不可导出</span></span><br><span class="line">	sal  <span class="type">float64</span> <span class="comment">//不可导出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂模式函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="type">string</span>)</span></span> *person &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">		Name: name,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了访问age和sal编写一对Set和Get</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> SetAge(age <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> age &lt;= <span class="number">0</span> || age &gt; <span class="number">150</span> &#123;</span><br><span class="line">		p.age = <span class="number">-1</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;年龄不正确&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		p.age = age</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> GetAge() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> SetSal(sal <span class="type">float64</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> sal &lt;= <span class="number">0</span> || sal &gt; <span class="number">30000</span> &#123;</span><br><span class="line">		p.sal = <span class="number">-1</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;薪水不正确&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		p.sal = sal</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> GetSal() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.sal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承介绍：继承可以解决代码复用，让我们编程思维更加靠近人类思维</p>
<p>当多个结构体存在相同的属性(字段)和方法时，可以从这些结构体中抽象出结构体，在该结构体中定义这些相同的属性和方法</p>
<p>其他结构体不需要重新定义这些属性和方法，只需要嵌套一个匿名结构体即可</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//嵌套匿名结构体的基本语法</span></span><br><span class="line"><span class="keyword">type</span> 共性结构体名 <span class="keyword">struct</span>&#123;</span><br><span class="line">  	<span class="comment">//共性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> 个性结构体名 <span class="keyword">struct</span>&#123;</span><br><span class="line">  	共性结构体名</span><br><span class="line">  	个性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>结构体可以使用嵌套匿名结构体所有的字段和方法，即：首字母大写或者小写的字段和方法都可以使用</li>
<li>匿名结构体字段访问可以简化</li>
<li>当结构体和匿名结构体有相同的字段或者方法时，编译器采用<strong>就近访问原则</strong>访问，如希望访问匿名结构体的字段和方法，可以通过匿名结构体来区分</li>
<li>结构体中嵌入了两个或多个匿名结构体，如两个匿名结构体有相同的字段和方法<strong>（同时结构体本身没有同名的字段和方法）</strong>，在访问时就<strong>必须明确指定匿名结构体名字</strong>，否则编译器报错</li>
<li>如果一个结构体嵌套一个有名的结构体，这种模式就是<strong>组合</strong>，如果是组合关系，那么在访问组合的结构体字段或方法时，必须带上<strong>结构体名字</strong></li>
<li>嵌套匿名结构体后，也可以在创建结构体变量（实例）时，直接指定各个匿名结构体字段的值</li>
</ul>
<p>多重继承说明：</p>
<ul>
<li>如果一个结构体嵌套了多个匿名结构体，那么该结构体可以直接访问嵌套的匿名函数结构体的字段和方法，从而实现多重嵌套</li>
<li>如嵌入的匿名结构体有相同的字段名或者方法名，在访问时需要通过匿名结构体的类型名来区分</li>
<li>为了保证代码的简洁性，建议不要使用多重继承</li>
</ul>
<h4 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h4><p>在Golang中<strong>多态特性</strong>主要是通过接口实现的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Usb <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">//定义两个方法</span></span><br><span class="line">	Start()</span><br><span class="line">	Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手机</span></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span></span> Start() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;手机开始工作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span></span> Stop() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;手机停止工作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相机</span></span><br><span class="line"><span class="keyword">type</span> Camera <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Camera)</span></span> Start() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;相机开始工作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Camera)</span></span> Stop() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;相机停止工作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//电脑</span></span><br><span class="line"><span class="keyword">type</span> Computer <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现了usb接口，接受一个usb接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(co Computer)</span></span> Working(usb Usb) &#123;</span><br><span class="line">	<span class="comment">//通过usb接口变量来调用Start和Stop方法</span></span><br><span class="line">	usb.Start()</span><br><span class="line">	usb.Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	computer := Computer&#123;&#125;</span><br><span class="line">	phone := Phone&#123;&#125;</span><br><span class="line">	camera := Camera&#123;&#125;</span><br><span class="line"></span><br><span class="line">	computer.Working(phone)</span><br><span class="line">	computer.Working(camera)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口介绍：interface类型可以定义一组方法，但是这些不需要实现。并且interface不能包含任何变量。到某个自定义类型（比如结构体）要用的时候，再根据情况把这些方法写出来</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本语法</span></span><br><span class="line"><span class="keyword">type</span> 接口名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    method1(参数列表)返回值列表</span><br><span class="line"> 	method2(参数列表)返回值列表</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口所有方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(t 自定义类型)</span></span>method1(参数列表)(返回值列表)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(t 自定义类型)</span></span>method2(参数列表)(返回值列表)&#123;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>使用说明：</p>
<ul>
<li>接口里的所有方法都没有方法体，即接口的方法都是没有实现的方法。接口体现了程序设计的<strong>多态和高内聚低耦合</strong>的思想</li>
<li>Golang中的接口不需要显式的实现。只要一个变量含有接口类型中的所有方法那么就这个变量就实现这个接口。因此，<strong>Golang中没有implement这样的关键字</strong></li>
</ul>
<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>接口本身不能创建实例，但是可以指向一个实现了该接口的自定义类型的变量（实例）</li>
<li>接口中所有的方法都没有方法体，即都是没有实现的方法</li>
<li>在Golang中，一个自定义类型需要将某个接口的所有方法都实现，我们说这个自定义类型实现了该接口</li>
<li>一个自定义类型只有实现了某个接口，才能将该自定义类型的实例(变量)赋给接口类型</li>
<li>只要是<strong>自定义数据类型，就可以实现接口</strong>，不仅仅是结构体类型</li>
<li>一个自定义类型可以实现多个接口</li>
<li>Goalng接口不能有任何变量</li>
<li>一个接口可以继承多个别的接口，这是如果要实现该接口，就要将内部所有接口实现</li>
<li>interface类型默认是一个指针类型（引用类型），如果没有对interface初始化就使用会输出nil</li>
<li>空接口interface{}没有任何方法，所以<strong>所有类型都是实现了空接口</strong>，可以把任何一个变量赋给空接口</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口案例</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Hero <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//切片结构体</span></span><br><span class="line"><span class="keyword">type</span> HeroSlice []Hero</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hs HeroSlice)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(hs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hs HeroSlice)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> hs[i].Age &lt; hs[j].Age</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hs HeroSlice)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">	hs[j], hs[i] = hs[i], hs[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> heroes HeroSlice</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		hero := Hero&#123;</span><br><span class="line">			Name: fmt.Sprintf(<span class="string">&quot;英雄-%d&quot;</span>, rand.Intn(<span class="number">100</span>)),</span><br><span class="line">			Age:  rand.Intn(<span class="number">100</span>),</span><br><span class="line">		&#125;</span><br><span class="line">		heroes = <span class="built_in">append</span>(heroes, hero)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> heroes &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sort.Sort(heroes)</span><br><span class="line">	fmt.Println()</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> heroes &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口和继承的区别"><a href="#接口和继承的区别" class="headerlink" title="接口和继承的区别"></a>接口和继承的区别</h4><ul>
<li>当A结构体继承了B结构体，那么A结构体就自动的继承了B结构体的字段和方法，并且可以直接使用</li>
<li>当A结构体需要扩展功能，同时不希望去破坏继承关系，则可以去实现某个接口即可，因此我们认为接口是对继承机制的补充</li>
</ul>
<p>接口和继承解决的问题不同：</p>
<ul>
<li>继承的价值主要在于：解决代码的<strong>复用性和可维护性</strong></li>
<li>接口的价值主要在于：设计好各种规范（方法），让其他自定义类型去实现这些方法</li>
</ul>
<p>接口比继承更加灵活</p>
<p>接口在一定程度上实现代码解耦</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>基本介绍：变量（实例）具有<strong>多种形态</strong>。面向对象的第三大特性，在Go语言中，多态特征是通过接口实现的。可以按照统一的接口来调用不同的实现。这是接口变量就呈现不同的形态</p>
<p>接口体现多态特征：</p>
<ul>
<li>多态参数：在前的Usb案例中，Usb usb，即可接收手机变量又可以接收相机变量，就体现了Usb接口的多态</li>
<li>多态数组：给定Usb数组存放Phone和Camera 结构体变量</li>
</ul>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p><strong>基本介绍：</strong>类型断言由于<strong>接口是一般类型</strong>，不知道具体类型，如果要转成具体类型，就需要使用类型断言</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果我们希望将空接口类型重新转换为对应的类型，就需要使用到类型断言</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">	x <span class="type">int</span></span><br><span class="line">	y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> point Point = Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	a = point</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> b Point</span><br><span class="line">	<span class="comment">//类型断言，前提是a必须是指向Point类型</span></span><br><span class="line">	b = a.(Point)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带检测的类型断言</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">y, ok = x.(<span class="type">float64</span>)</span><br><span class="line"><span class="comment">//ok为bool类型，如果成功则y转换成功，否则ok失败ok为false</span></span><br></pre></td></tr></table></figure>

<p>类型断言的好处：如果转换出错不至于报panic，而是可以继续执行代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Phone、Camera案例，使用类型断言给phone加上call方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(co Computer)</span></span> Working(usb Usb) &#123;</span><br><span class="line">	<span class="comment">//通过usb接口变量来调用Start和Stop方法</span></span><br><span class="line">	usb.Start()</span><br><span class="line">    <span class="keyword">if</span> phone, ok := usb.(Phone); ok&#123;</span><br><span class="line">      	phone.Call()</span><br><span class="line">    &#125;</span><br><span class="line">	usb.Stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>文件是数据源（保存数据的地方）的一种。文件最主要的作用就是<strong>保存数据</strong>，它即可以保存一张图片，也可以保存视频音频</p>
<p>文件在程序中是以流的形式来操作的</p>
<p>流：数据在数据源（文件）和程序（内存）之间经历的路径</p>
<p>输入流：数据从数据源（文件）到程序（内存）的路径</p>
<p>输出流：数据从程序（内存）到数据源（文件）的路径</p>
<p>os.File封装所有文件相关操作，File是一个结构体</p>
<h3 id="常用的文件操作函数和方法"><a href="#常用的文件操作函数和方法" class="headerlink" title="常用的文件操作函数和方法"></a>常用的文件操作函数和方法</h3><ul>
<li>打开一个文件进行读操作：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">os.Open(name <span class="type">string</span>)(*File, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭一个文件：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">File.Close()</span><br></pre></td></tr></table></figure>

<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p><strong>读取文件的内容并显示在终端（带缓冲区的方式）</strong>，使用os.Open，file.Close，bufio.NewReader()，reader.ReadString函数和方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.Open(<span class="string">&quot;D:/test.txt&quot;</span>) <span class="comment">//根据文件位置及文件名不同</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file err = &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="comment">//reader是带缓冲区的，缓冲大小默认为4096</span></span><br><span class="line">	reader := bufio.NewReader(file)</span><br><span class="line">	<span class="comment">//循环读取内容</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		str, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">//读到换行就结束</span></span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;                  <span class="comment">//io.EOF表示文件的末尾</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(str)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;文件读取结束...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>读取文件的内容并显示在终端（使用ioutil一次性将整个文件读到内存中），这种方式适用于文件不大的情况。相关方法和函数ioutil.ReadFile</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file := <span class="string">&quot;D:/test.txt&quot;</span></span><br><span class="line">	<span class="comment">//没有显示open文件，也无需显示的close</span></span><br><span class="line">	<span class="comment">//open和close被封装到readfile中</span></span><br><span class="line">	content, err := ioutil.ReadFile(file)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;read file err = &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v&quot;</span>, <span class="type">string</span>(content)) <span class="comment">//[]byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写文件操作"><a href="#写文件操作" class="headerlink" title="写文件操作"></a>写文件操作</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span>(file *File, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>说明：os.OpenFile是一个更一般性的文件打开函数，它会使用指定的选项（如O_RDONLY等）、指定的模式（如0666等）打开指定名称的文件。如果操作成功，返回的文件对象可用于I&#x2F;O。如果出错，底层错位类型是*PathError</p>
<p>第二个参数：文件打开模式（可以组合）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    O_RDONLY <span class="type">int</span> = syscall.O_RDONLY <span class="comment">// 只读模式打开文件</span></span><br><span class="line">    O_WRONLY <span class="type">int</span> = syscall.O_WRONLY <span class="comment">// 只写模式打开文件</span></span><br><span class="line">    O_RDWR   <span class="type">int</span> = syscall.O_RDWR   <span class="comment">// 读写模式打开文件</span></span><br><span class="line">    O_APPEND <span class="type">int</span> = syscall.O_APPEND <span class="comment">// 写操作时将数据附加到文件尾部</span></span><br><span class="line">    O_CREATE <span class="type">int</span> = syscall.O_CREAT  <span class="comment">// 如果不存在将创建一个新文件</span></span><br><span class="line">    O_EXCL   <span class="type">int</span> = syscall.O_EXCL   <span class="comment">// 和O_CREATE配合使用，文件必须不存在</span></span><br><span class="line">    O_SYNC   <span class="type">int</span> = syscall.O_SYNC   <span class="comment">// 打开文件用于同步I/O</span></span><br><span class="line">    O_TRUNC  <span class="type">int</span> = syscall.O_TRUNC  <span class="comment">// 如果可能，打开时清空文件</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>第三个参数：权限控制（Linux&#x2F;Unix），在Windows在无效。详见Linux内容</p>
<p>r-&gt;4</p>
<p>w-&gt;2</p>
<p>x-&gt;1</p>
<h3 id="判断文件是否存在"><a href="#判断文件是否存在" class="headerlink" title="判断文件是否存在"></a>判断文件是否存在</h3><p>Golang判断文件或文件夹时候存在的方法为使用os.Stat()函数返回的错误值进行判断：</p>
<ul>
<li>如果返回的错误值为nil，说明文件或文件夹存在</li>
<li>如果返回的错误值类型使用os.IsNotExist()判断为true，说明文件或文件夹不存在</li>
<li>如果返回的错误值为其他类型，则不确定是否存在</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PathExists</span><span class="params">(path <span class="type">string</span>)</span></span> (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	_, err := os.Stat(path)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span></span>(written <span class="type">int64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	srcFile := <span class="string">&quot;D:/text.txt&quot;</span></span><br><span class="line">	dstFile := <span class="string">&quot;D:/abc.txt&quot;</span></span><br><span class="line">	_, err := CopyFile(dstFile, srcFile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;error, main&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;copy finish&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstFileName <span class="type">string</span>, srcFileName <span class="type">string</span>)</span></span> (<span class="type">int64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  	<span class="comment">//获取reader</span></span><br><span class="line">	srcFile, err := os.Open(srcFileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;error, src&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	reader := bufio.NewReader(srcFile)</span><br><span class="line">	<span class="keyword">defer</span> srcFile.Close()</span><br><span class="line">	<span class="comment">//获取writer</span></span><br><span class="line">	dstFile, err := os.OpenFile(dstFileName, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;error, dst&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	writer := bufio.NewWriter(dstFile)</span><br><span class="line">	<span class="keyword">defer</span> dstFile.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> io.Copy(writer, reader)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="统计在文件中的字符"><a href="#统计在文件中的字符" class="headerlink" title="统计在文件中的字符"></a>统计在文件中的字符</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CharCount <span class="keyword">struct</span> &#123;</span><br><span class="line">	ChCount    <span class="type">int</span> <span class="comment">//英文</span></span><br><span class="line">	NumCount   <span class="type">int</span> <span class="comment">//数字</span></span><br><span class="line">	SpaceCount <span class="type">int</span> <span class="comment">//空格</span></span><br><span class="line">	OtherCount <span class="type">int</span> <span class="comment">//其他字符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fileName := <span class="string">&quot;D:/text.txt&quot;</span></span><br><span class="line">	file, err := os.Open(fileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open error&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="keyword">var</span> count CharCount</span><br><span class="line">	reader := bufio.NewReader(file)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		str, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> str &#123;</span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> v &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">				<span class="keyword">fallthrough</span></span><br><span class="line">			<span class="keyword">case</span> v &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">				count.ChCount++</span><br><span class="line">			<span class="keyword">case</span> v == <span class="string">&#x27; &#x27;</span> || v == <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">				count.SpaceCount++</span><br><span class="line">			<span class="keyword">case</span> v &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">				count.NumCount++</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				count.OtherCount++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;空格有%v，字母有%v，数字有%v，其他有%v&quot;</span>, count.SpaceCount, count.ChCount, count.NumCount, count.OtherCount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>os.Args是一个string切片，用来存储所有的命令行参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;命令行参数有：&quot;</span>, <span class="built_in">len</span>(os.Args))</span><br><span class="line">	<span class="comment">//遍历os.Args切片，就可以得到所有的命令行输入参数值</span></span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;args[%v] = %v&quot;</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="flag解析命令行参数"><a href="#flag解析命令行参数" class="headerlink" title="flag解析命令行参数"></a>flag解析命令行参数</h3><p>说明：前面的方式比较原生的方式，对解析参数不是特别的方便，特别是带有指定参数形式的命令行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//用于接收命令行的参数值</span></span><br><span class="line">	<span class="keyword">var</span> user <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> pwd <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> host <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> port <span class="type">int</span></span><br><span class="line">	<span class="comment">//&amp;user就是接收用户命令行中输入的-u后面的参数值</span></span><br><span class="line">	<span class="comment">//&quot;u&quot;就是 -u 指定参数</span></span><br><span class="line">	flag.StringVar(&amp;user, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;用户名，默认为空&quot;</span>)</span><br><span class="line">	flag.StringVar(&amp;pwd, <span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;密码，默认为空&quot;</span>)</span><br><span class="line">	flag.StringVar(&amp;host, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;主机，默认为localhost&quot;</span>)</span><br><span class="line">	flag.IntVar(&amp;port, <span class="string">&quot;port&quot;</span>, <span class="number">3306</span>, <span class="string">&quot;端口号，默认为3306&quot;</span>)</span><br><span class="line">	flag.Parse()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;user = %v, pwd = %v, host = %v, port = %v&quot;</span>, user, pwd, host, port)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Json基本介绍"><a href="#Json基本介绍" class="headerlink" title="Json基本介绍"></a>Json基本介绍</h2><p>概述：JSON（JavaScript Object Notation）是一种<strong>轻量级的数据交换格式</strong>。易于人的阅读和编写。同时也易于机器解析和生成</p>
<p>JSON实在2001年开始推广使用的数据格式，目前已经成为<strong>主流的数据格式</strong></p>
<p>JSON易于机器解析和生成，并有效的提升网络的传输效率，通常程序在网络传输时会将数据（结构体、map等）序列化成json字符串，到接收方得到json字符串时再反序列化恢复成原来的数据类型（结构体、map等）。这种方式已然成为各个语言的标准</p>
<div align="center">
    <img src="/2022/02/15/Golang/JSON的应用场景.jpg" style="zoom:25%" alt="JSON的应用场景">
</div>

<h3 id="JSON数据格式"><a href="#JSON数据格式" class="headerlink" title="JSON数据格式"></a>JSON数据格式</h3><p>在JS语言中，一切都是对象。因此，任何的数据类型都可以通过JSON来表示，例如字符串、数字、对象、数字、mao等，<strong>任何数据类型都可以转成JSON</strong></p>
<p>JSON键值对是用来保存数据一种方式，键&#x2F;值对组合中的键名写在前面并用双引号””包裹，使用冒号:分隔，然后紧接着值</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  	<span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;tom&quot;</span></span><br><span class="line">  	<span class="attr">&quot;age&quot;</span> <span class="punctuation">:</span> <span class="number">18</span></span><br><span class="line">  	<span class="attr">&quot;address&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;上海&quot;</span><span class="punctuation">,</span><span class="string">&quot;北京&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="JSON序列化"><a href="#JSON序列化" class="headerlink" title="JSON序列化"></a>JSON序列化</h3><p> json序列化是指将有key-value结构的数据类型（比如结构体、map、切片）序列化成json字符串的操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">json.Marshal()</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name     <span class="type">string</span></span><br><span class="line">	Age      <span class="type">int</span></span><br><span class="line">	Birthday <span class="type">string</span></span><br><span class="line">	Sal      <span class="type">float64</span></span><br><span class="line">	Skill    <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//将结构体、map、切片序列化</span></span><br><span class="line">	testStruct()</span><br><span class="line">	testMap()</span><br><span class="line">	testSlice()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testStruct</span><span class="params">()</span></span> &#123;</span><br><span class="line">	monster := Monster&#123;</span><br><span class="line">		Name:     <span class="string">&quot;marry&quot;</span>,</span><br><span class="line">		Age:      <span class="number">22</span>,</span><br><span class="line">		Birthday: <span class="string">&quot;2000-11-11&quot;</span>,</span><br><span class="line">		Sal:      <span class="number">8000.22</span>,</span><br><span class="line">		Skill:    <span class="string">&quot;Golang&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	data, err := json.Marshal(&amp;monster)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;struct序列化后&quot;</span>, <span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	a = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	a[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;lilei&quot;</span></span><br><span class="line">	a[<span class="string">&quot;age&quot;</span>] = <span class="number">30</span></span><br><span class="line">	a[<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;西安&quot;</span></span><br><span class="line"></span><br><span class="line">	data, err := json.Marshal(a)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;map序列化后&quot;</span>,<span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSlice</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> slice []<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	m1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	m1[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;jack&quot;</span></span><br><span class="line">	m1[<span class="string">&quot;age&quot;</span>] = <span class="number">7</span></span><br><span class="line">	m1[<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;北京&quot;</span></span><br><span class="line">	slice = <span class="built_in">append</span>(slice, m1)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> m2 <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	m2 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	m2[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;tom&quot;</span></span><br><span class="line">	m2[<span class="string">&quot;age&quot;</span>] = <span class="number">20</span></span><br><span class="line">	m2[<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;墨西哥&quot;</span></span><br><span class="line">	slice = <span class="built_in">append</span>(slice, m2)</span><br><span class="line"></span><br><span class="line">	data, err := json.Marshal(slice)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;slice序列化后&quot;</span>,<span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对基本数据类型数据化意义不大</p>
<h3 id="JSON反序列化"><a href="#JSON反序列化" class="headerlink" title="JSON反序列化"></a>JSON反序列化</h3><p>json反序列化是指将json字符串反序列化成对应的数据类型（比如结构体、map、切片）的操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">json.Unmarshal()</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name     <span class="type">string</span></span><br><span class="line">	Age      <span class="type">int</span></span><br><span class="line">	Birthday <span class="type">string</span></span><br><span class="line">	Sal      <span class="type">float64</span></span><br><span class="line">	Skill    <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	unmarshaStruct()</span><br><span class="line">	unmarshaMap()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unmarshaStruct</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;&#123;\&quot;Name\&quot;:\&quot;marry\&quot;,\&quot;Age\&quot;:22,\&quot;Birthday\&quot;:\&quot;2000-11-11\&quot;,\&quot;Sal\&quot;:8000.22,\&quot;Skill\&quot;:\&quot;Golang\&quot;&#125;&quot;</span></span><br><span class="line">	<span class="keyword">var</span> monster Monster</span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(str), &amp;monster)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(monster.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unmarshaMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;&#123;\&quot;address\&quot;:\&quot;西安\&quot;,\&quot;age\&quot;:30,\&quot;name\&quot;:\&quot;lilei\&quot;&#125;&quot;</span></span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(str), &amp;a)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反序列化是map不需要make，反序列化封装至unmarshal函数</p>
<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>反序列化后的数据类型要和序列化之前的数据类型一致</li>
<li>如果字符串时通过程序获得的，在反序列化是不需要对双引号进行转义处理</li>
</ul>
<hr>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>传统方法：在main函数中调用函数，看看实际输出结果与预期结果是否一致</p>
<p>传统测试方法的缺点：</p>
<ul>
<li>不方便，需要在主函数中调用。如果项目正在运行则可能停止项目</li>
<li>不利于管理，当我们需要测试多个模块式，都需要卸载main函数中】</li>
</ul>
<p><strong>基本介绍：</strong>Go语言中自带有一个轻量级的<strong>测试框架testing</strong>和<strong>自带的Go test命令</strong>来实现单元测试和性能测试，testing框架和其他语言中的测试框架类似，可以基于这个框架写针对相应函数的测试用例，也可以基于该框架写相应的压力测试用例</p>
<ul>
<li>确保每个函数是可运行，并且运行结果是正确的</li>
<li>确保写出来的代码性能是好的</li>
<li>单元测试能及时的发现程序设计或实现的逻辑错误，使问题及时暴露，便于问题的定位解决，而性能测试的重点在于发现程序设计上的一些问题，让程序能够在高并发的情况下还能保持稳定</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUpper</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		res += i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAddUpper</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	res := AddUpper(<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">if</span> res != <span class="number">55</span> &#123;</span><br><span class="line">		t.Fatalf(<span class="string">&quot;AddUpper(10) error,期望=%v,实际=%v&quot;</span>, <span class="number">55</span>, res)</span><br><span class="line">	&#125;</span><br><span class="line">	t.Logf(<span class="string">&quot;AddUpper(10) true&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>测试用例文件名必须以**_test.go**结尾</li>
<li>测试用例函数必须以Test开头</li>
<li>TestAddUpper(t *testing.T)的形参类型必须是 *testing.T</li>
<li>一个测试用例文件中，可以有多个测试用例函数<ul>
<li>cmd-&gt; go test</li>
<li>cmd-&gt;go test -v</li>
</ul>
</li>
<li>当出现错误时，可以使用t.Fatalf来格式化输出错误信息</li>
<li>t.LogF方法可以输出相应的日志</li>
<li>测试用例函数并没有放在主函数中执行，这就是测试用例的方便之处</li>
<li>PASS表示测试用例运行成功，FAIL表示测试用例运行失败</li>
<li>测试单个文件一定要带上被测试的原文件（cmd）go test -v AddUpper_test.go AddUpper.go</li>
<li>测试单个方法go test -v-test.run TestAddUpper</li>
</ul>
<hr>
<h2 id="GoRoutine和Channel"><a href="#GoRoutine和Channel" class="headerlink" title="GoRoutine和Channel"></a>GoRoutine和Channel</h2><h3 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h3><p>进程和线程说明：</p>
<ul>
<li>进程就是程序在操作系统中的一次执行过程，是系统进行资源分配和调度的基本单位</li>
<li>线程是进程的一个执行实例，是程序执行的最小单元，它是比进程更小的能独立运行的基本单元</li>
<li>一个进程可以创建和销毁多个线程，同一个进程中的多个线程可以并发执行</li>
<li>一个程序至少有一个进程，一个进程至少有一个线程</li>
</ul>
<div align="center">
    <img src="/2022/02/15/Golang/进程和线程.jpg" style="zoom:30%" alt="进程和线程">
</div>


<p>并发和并行：</p>
<ul>
<li>多线程程序在<strong>单核</strong>上运行就是并发</li>
<li>多线程程序在<strong>多核</strong>上运行就是并行</li>
</ul>
<p>并发特点：从微观角度看，在一个时间节点上实际只有一个任务在执行</p>
<h3 id="Go协程和Go主线程"><a href="#Go协程和Go主线程" class="headerlink" title="Go协程和Go主线程"></a>Go协程和Go主线程</h3><p>Go主线程（有程序员直接称为线程&#x2F;也可以理解成进程）：一个Go线程上可以起多个协程，<strong>协程是轻量级的线程</strong> </p>
<p>Go协程特点：</p>
<ul>
<li>有独立的栈空间</li>
<li>共享程序堆空间</li>
<li>调度由用户控制</li>
<li>协程是轻量级线程</li>
</ul>
<div align="center">
    <img src="/2022/02/15/Golang/主线程和协程.jpg" style="zoom:30%" alt="主线程和协程">
</div>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用主线程和协程并发输出内容</span></span><br><span class="line"><span class="comment">//主线程每间隔一秒输出一个hello,golang</span></span><br><span class="line"><span class="comment">//协程没间隔一秒输出一个hello,world</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;hello,world&quot;</span> + strconv.Itoa(i))</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> test()<span class="comment">//在协程前加go开启协程</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;hello,golang&quot;</span> + strconv.Itoa(i))</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center">
    <img src="/2022/02/15/Golang/主线程和协程工作示意图.jpg" style="zoom:30%" alt="主线程和协程工作示意图">
</div>

<p>小结：</p>
<ul>
<li>主线程是一个物理线程，直接作用在CPU上的。是重量级的，非常耗费CPU资源</li>
<li>协程从主线程开启，是<strong>轻量级的线程</strong>，是逻辑态。对资源消耗相对较小</li>
<li>Golang的协程机制是重要的特点，可以轻松开启上万个协程。其他编程语言的并发机制是一般基于线程的，开启过多的线程，资源耗费大。就凸显了Golang的优势</li>
</ul>
<h3 id="MPG模式基本介绍"><a href="#MPG模式基本介绍" class="headerlink" title="MPG模式基本介绍"></a>MPG模式基本介绍</h3><ul>
<li>M：操作系统的主线程（物理线程）（三角形）</li>
<li>P：协程执行需要的上下文（四边形）</li>
<li>G：协程（圆形）</li>
</ul>
<p>状态1</p>
<div align="center">
    <img src="/2022/02/15/Golang/MPG模式运行状态1.jpg" style="zoom:30%" alt="MPG模式运行状态1">
</div>

<ol>
<li>当前程序有三个M，如果三个M都在一个CPU上运行就是并发，如果在不同的CPU上运行就是并行</li>
<li>M1，M2，M3正在执行一个G，M1的协程队列有三个，M2的协程队列有三个，M3的协程队列有两个</li>
<li>从图上可以看到：Go的协程是轻量级的线程，是逻辑态的，Go可以起上万个协程</li>
<li>其他程序C&#x2F;Java的多线程，往往是内核态，比较重量级，几千个线程可能耗光CPU</li>
</ol>
<p>状态2</p>
<div align="center">
    <img src="/2022/02/15/Golang/MPG模式运行状态2.jpg" style="zoom:30%" alt="MPG模式运行状态2">
</div>

<ol>
<li>分为两个部分看</li>
<li>原来情况是M0主线程正在执行G0协程，另外三个协程在队列等待</li>
<li>如果G0协程阻塞，比如读取文件或数据库等</li>
<li>这时救赎创建M1主线程（也可能是从已有线程池中取出M1）。并且将等待的3个协程挂到M1下开始执行，M0的主线程下的G0仍然执行文件io的读写</li>
<li>这样的MPG调度模式，可以即让G0执行，同时也不会让队列的其他协程一直阻塞，仍然可以并发&#x2F;并行执行</li>
<li>等到G0不阻塞了，M0会被放到空闲的主线程继续执行（从已有的线程池中取），同时G0又会被唤醒</li>
</ol>
<h3 id="Golang中设置运行CPU"><a href="#Golang中设置运行CPU" class="headerlink" title="Golang中设置运行CPU"></a>Golang中设置运行CPU</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> runtime</span><br><span class="line">cpuNum := runtime.NumCPU()</span><br></pre></td></tr></table></figure>

<h3 id="Golang中并发（并行）引起的资源争夺问题"><a href="#Golang中并发（并行）引起的资源争夺问题" class="headerlink" title="Golang中并发（并行）引起的资源争夺问题"></a>Golang中并发（并行）引起的资源争夺问题</h3><p>当我们使用Goroutine对全局变量进行写入操作时，如果协程较多导致多个协程同时访问某一全局变量资源时就会报错concurrent    writes</p>
<p>解决方案：对全局变量加全局互斥锁访问sync.Mutex</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//并发运算20以内数的阶乘并存入map中</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	myMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	lock  sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	res := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		res *= i</span><br><span class="line">	&#125;</span><br><span class="line">	lock.Lock()    <span class="comment">//加锁</span></span><br><span class="line">	myMap[n] = res <span class="comment">//concurrent map writes</span></span><br><span class="line">	lock.Unlock()  <span class="comment">//解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> test(i)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">	lock.Lock()</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> myMap &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;myMap[%d] = %d\n&quot;</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">	lock.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Channel管道"><a href="#Channel管道" class="headerlink" title="Channel管道"></a>Channel管道</h3><p>为什么需要channel？</p>
<p>前面使用全局变量加锁同步来解决goroutine的通讯并不完美</p>
<ol>
<li>主线程在等待所有goroutine全部完成的时间很难确定</li>
<li>如果主线程休眠时间长了，会加长等待时间；如果时间短了可能还有goroutine出于工作状态，这时也会随主线程的退出而销毁</li>
<li>通过全局变量加锁同步来实现通讯，也并没有利用多个协程对全局变量的读写操作</li>
<li>以上的需求引出新的通讯机制—channel</li>
</ol>
<p><strong>基本介绍：</strong></p>
<ul>
<li>channel本质就是一个数据结构—队列</li>
<li>数据先进先出（FIFO）</li>
<li>线程安全，多goroutine访问是不需要加锁</li>
<li>channel是有类型的，一个string的channel只能存放string</li>
</ul>
<p><strong>基本使用：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 <span class="keyword">chan</span> 数据类型</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>channel是<strong>引用类型</strong></li>
<li>channel必须初始化才能写入数据，即make后才能使用</li>
<li>管道是有类型的，intChan只能写入整数int</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">	intChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向管道写入</span></span><br><span class="line">	intChan &lt;- <span class="number">10</span></span><br><span class="line">	num := <span class="number">985</span></span><br><span class="line">	intChan &lt;- num</span><br><span class="line">	fmt.Printf(<span class="string">&quot;channel len = %v\nchannel cap = %v\n&quot;</span>, <span class="built_in">len</span>(intChan), <span class="built_in">cap</span>(intChan))</span><br><span class="line">	<span class="comment">//管道写入不可超过容量，管道不会自己扩容</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">//从管道取出</span></span><br><span class="line">	<span class="keyword">var</span> num2 <span class="type">int</span></span><br><span class="line">	num2 = &lt;- intChan</span><br><span class="line">	fmt.Printf(<span class="string">&quot;num2 = %v\n&quot;</span>, num2)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;channel len = %v\nchannel cap = %v\n&quot;</span>, <span class="built_in">len</span>(intChan), <span class="built_in">cap</span>(intChan))</span><br><span class="line">	<span class="comment">//管道在空时不可取出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>channel中只能存放指定的数据类型</li>
<li>channel的数据放满后就不能再放入</li>
<li>如果从channel取出数据后可以继续放入</li>
<li>在没有使用协程的情况下，如果channel数据取完再取就不报错（deed lock）</li>
</ul>
<h3 id="channel关闭"><a href="#channel关闭" class="headerlink" title="channel关闭"></a>channel关闭</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">close</span>(intChan)</span><br></pre></td></tr></table></figure>

<p>使用内置函数close可以关闭channel，当channel关闭后就不能再向channel写入数据，但是仍然可以从该channel中读取数据</p>
<h3 id="channel遍历"><a href="#channel遍历" class="headerlink" title="channel遍历"></a>channel遍历</h3><p>channel支持for-range的方式进行遍历：</p>
<ul>
<li>在遍历时，如果channel没有关闭，则回出现deadlock错误</li>
<li>在遍历时，如果channel已经关闭，则会正常遍历数据，遍历完后就会退出遍历</li>
</ul>
<p>不可使用普通遍历方式</p>
<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>channel可以声明为只读，或者只写性质</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">chan</span> <span class="keyword">chan</span>&lt;- <span class="type">int</span><span class="comment">//只写</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">chan</span> &lt;-<span class="keyword">chan</span> <span class="type">int</span><span class="comment">//只读</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用select可以解决从管道取数据的阻塞问题</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">  	<span class="keyword">case</span>:</span><br><span class="line"> 	<span class="keyword">case</span>:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>goroutine中使用recover，解决协程出现panic，导致程序崩溃问题</p>
<p>说明：如果我们起一个协程，但是这个协程出现panic，如果我们没有捕获这个panic，就会造成程序崩溃，这是我们可以在goroutine中使用recover来捕获panic进行处理。这样及时协程发生问题但是主线程仍然不受影响，可以继续执行</p>
</li>
</ul>
<hr>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>应用场景一：在Json序列化过程中，给结构体标签的应用</p>
<p>应用场景二：go框架的开发中，使用反射机制编写函数的适配器、桥连接</p>
<p><strong>基本介绍：</strong></p>
<ul>
<li>反射可以在运行时动态获取变量的各种信息，比如变量的类型（type），类别（kind）</li>
<li>如果是结构体变量，还可以获取到接哦固体本身的信息（包括结构体的字段、方法）</li>
<li>通过反射，可以修改变量的值，可以调用关联的方法</li>
<li>使用反射，需要import（“reflect”）</li>
</ul>
<p><strong>反射重要的函数和概念：</strong></p>
<ul>
<li>reflect.TypeOf(变量名)，获取变量的类型，返回reflect.Type类型</li>
<li>reflect.ValueOf(变量名)，获取变量的值，返回reflect.Value类型，reflect.Value是一个结构体类型</li>
<li>变量、interface{}和reflect.Value是可以相互转换的</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//专门用于作反射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">//如何将interface&#123;&#125;转成reflect.Value</span></span><br><span class="line">    rVal := reflect.ValueOf(b)</span><br><span class="line">    <span class="comment">//如何将reflect.Value转成interface&#123;&#125;</span></span><br><span class="line">    iVal := rVal.Interface&#123;&#125;</span><br><span class="line">    <span class="comment">//如何将interface&#123;&#125;转成原来的变量类型，使用类型断言</span></span><br><span class="line">    v := iVal.(<span class="keyword">type</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项和使用细节：</strong></p>
<ul>
<li>reflect.Value.Kind，获取变量的类别，返回的是一个常量</li>
<li>Type是类型，Kind是类别，Type可能是相同的也可能是不同的</li>
<li>通过反射可以在让变量在interface{}和reflect.Value之间相互转换</li>
<li>使用反射的方式来取得变量的值（并返回对应的类型），要求是据类型匹配，而不能使用其他</li>
<li>通过反射的来修改变量，注意当使用SetXxx方法来设置需要对应<strong>指针类型</strong>来完成，这样才改变传入变量的值，同时需要使用到reflect.Value.Elem()方法。rVal.Elem().SetInt()</li>
<li>reflect.Value.Elem()等价于从指针中取出数据</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num <span class="type">int</span> = <span class="number">20</span></span><br><span class="line">	testInt(&amp;num)</span><br><span class="line">	fmt.Println(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testInt</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	val := reflect.ValueOf(b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;val type = %T\n&quot;</span>, val)</span><br><span class="line">	val.Elem().SetInt(<span class="number">10</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;val = %v\n&quot;</span>, val.Elem())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例：使用反射来遍历结构体字段，调用结构体方并获取结构体标签的值</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个Monster</span></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Age   <span class="type">int</span>    <span class="string">`json:&quot;monster_age&quot;`</span></span><br><span class="line">	Score <span class="type">float32</span></span><br><span class="line">	Sex   <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法，显示s的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Monster)</span></span> Print() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;--------start--------&quot;</span>)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">	fmt.Println(<span class="string">&quot;--------end--------&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法，返回两数之和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Monster)</span></span> GetSum(n1, n2 <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法，接收四个值赋给Monster</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Monster)</span></span> Set(name <span class="type">string</span>, age <span class="type">int</span>, score <span class="type">float32</span>, sex <span class="type">string</span>) &#123;</span><br><span class="line">	s.Name = name</span><br><span class="line">	s.Age = age</span><br><span class="line">	s.Score = score</span><br><span class="line">	s.Sex = sex</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestStruct</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">//获取reflect.Type类型</span></span><br><span class="line">	typ := reflect.TypeOf(a)</span><br><span class="line">	<span class="comment">//获取reflect.Value类型</span></span><br><span class="line">	val := reflect.ValueOf(a)</span><br><span class="line">	<span class="comment">//获取到a对应类别</span></span><br><span class="line">	kd := val.Kind()</span><br><span class="line">	<span class="comment">//如果传入的不是struct就退出</span></span><br><span class="line">	<span class="keyword">if</span> kd != reflect.Struct &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;expect struct&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取到该结构体有几个字段</span></span><br><span class="line">	num := val.NumField()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;struct has %d fields\n&quot;</span>, num)</span><br><span class="line">	<span class="comment">//遍历结构体所有字段</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Field %d : %v\n&quot;</span>, i, val.Field(i))</span><br><span class="line">		<span class="comment">//获取到struct标签，注意需要通过reflect.Type来获取tag标签值</span></span><br><span class="line">		tagVal := typ.Field(i).Tag.Get(<span class="string">&quot;json&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> tagVal != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Field %d tag : %v\n&quot;</span>, i, tagVal)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取结构体的方法数量</span></span><br><span class="line">	numOfMethod := val.NumMethod()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;struct has %d method\n&quot;</span>, numOfMethod)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//var params []reflect.Value</span></span><br><span class="line">	<span class="comment">//方法排序是按照函数名的ASCII排序</span></span><br><span class="line">	val.Method(<span class="number">1</span>).Call(<span class="literal">nil</span>) <span class="comment">//获取到第二个方法，并调用</span></span><br><span class="line">	<span class="comment">//调用结构体的第一个方法Method(0)</span></span><br><span class="line">	<span class="keyword">var</span> params []reflect.Value</span><br><span class="line">	params = <span class="built_in">append</span>(params, reflect.ValueOf(<span class="number">10</span>))</span><br><span class="line">	params = <span class="built_in">append</span>(params, reflect.ValueOf(<span class="number">40</span>))</span><br><span class="line">	res := val.Method(<span class="number">0</span>).Call(params) <span class="comment">//res仍然是切片</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;res = &quot;</span>, res[<span class="number">0</span>].Int())</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//创建一个Monster</span></span><br><span class="line">	<span class="keyword">var</span> a Monster = Monster&#123;</span><br><span class="line">		Name:  <span class="string">&quot;牛&quot;</span>,</span><br><span class="line">		Age:   <span class="number">30</span>,</span><br><span class="line">		Score: <span class="number">30.2</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	TestStruct(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="网络编程—TCP-Socket编程"><a href="#网络编程—TCP-Socket编程" class="headerlink" title="网络编程—TCP Socket编程"></a>网络编程—TCP Socket编程</h2><p>Golang的主要设计目标之一就是面向大规模后端服务程序，网络通信这块是服务器程序必不可少也是至关重要的一部分</p>
<p>网络编程的基础知识：计算机间要相互通讯，必须要求网线、网卡或无线网卡</p>
<p>网络编程的两种形式：</p>
<ul>
<li><strong>TCP Socket编程：</strong>是网络编程的主流。之所以叫TCP Socket编程是因为底层基于TCP&#x2F;IP协议的</li>
<li>b&#x2F;s结构的<strong>http编程：</strong>我们使用浏览器去访问服务器时，使用的就是http协议，而http协议底层依旧是用TCP Socket实现的</li>
</ul>
<p>协议（TCP&#x2F;IP）：TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol）的简写，中文译名为传输控制协议&#x2F;因特网互联协议，又叫网络通讯协议。这个协议是Internet最基本的协议、Internet国际互联网的基础，简单的说就是有网络层的IP协议和传输层的TCP协议组成的</p>
<h3 id="网络编程的基础知识"><a href="#网络编程的基础知识" class="headerlink" title="网络编程的基础知识"></a>网络编程的基础知识</h3><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>概述：每个internet上的主机和路由器都有一个ip地址，他包括网络号和主机号，ip地址有Ipv4(32位)或者Ipv6(128位)，可以通过<strong>ipconfig</strong>查看</p>
<h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>我们这里所指的端口不是物理意义上的端口，而是特指TCP&#x2F;IP协议中的端口，是逻辑意义上的端口</p>
<p>端口的分类：</p>
<ul>
<li><p>0为保留端口</p>
</li>
<li><p>1~1024是固定端口</p>
<p>又叫有名端口，即被某些程序固定使用，一般程序员不使用。</p>
<p>7：echo服务</p>
<p>21：ftp使用</p>
<p>22：ssh远程登录协议</p>
<p>23：Telnet使用</p>
<p>25：smtp使用</p>
<p>80：iis使用</p>
</li>
<li><p>1025~65535是动态端口，程序员可用</p>
</li>
</ul>
<p>使用细节和注意事项</p>
<ul>
<li>在计算机（尤其是做服务器）要尽可能的少开端口</li>
<li>一个端口只能被一个程序监听</li>
<li>如果使用netstart -an可以查看本机有哪些端口在监听</li>
<li>可以使用netstart -anb来查看监听端口的pid，在结合任务管理器关闭不安全的端口</li>
</ul>
<h3 id="TCP-Socket编程的客户端和服务器端"><a href="#TCP-Socket编程的客户端和服务器端" class="headerlink" title="TCP Socket编程的客户端和服务器端"></a>TCP Socket编程的客户端和服务器端</h3><p>下图为Golang Socket编程中客户端和服务器的网络分布</p>
<div align="center">
    <img src="/2022/02/15/Golang/TCP Socket编程的客户端与服务器端.jpg" style="zoom:40%" alt="TCP Socket编程的客户端与服务器端">
</div>

<h4 id="服务器端的处理流程"><a href="#服务器端的处理流程" class="headerlink" title="服务器端的处理流程"></a>服务器端的处理流程</h4><ol>
<li>监听端口</li>
<li>接收客户端的TCP链接，建立客户端与服务器端的链接</li>
<li>创建Goroutine，处理该链接的请求（通常客户端会通过链接发送请求包）</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Process</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="comment">//这里循环的接收客户端发送的数据</span></span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">//创建一个切片</span></span><br><span class="line">		buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">		<span class="comment">//等待客户端通过conn发送信息，如果客户端没有writer，那么协程阻塞</span></span><br><span class="line">		<span class="comment">//fmt.Printf(&quot;服务器在等待客户端%s发送信息\n&quot;, conn.RemoteAddr().String())</span></span><br><span class="line">		n, err := conn.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;远程客户端已退出&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//显示客户端发送的内容到服务器端</span></span><br><span class="line">		fmt.Print(<span class="type">string</span>(buf[:n]))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;服务器开始监听......&quot;</span>)</span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;0.0.0.0:8888&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;监听失败&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> listen.Close() <span class="comment">//延时关闭</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//循环等待链接</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;等待客户端链接&quot;</span>)</span><br><span class="line">		conn, err := listen.Accept() <span class="comment">//等待客户端链接</span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Accept() err&quot;</span>, err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Accept() suc conn = %v, 客户端ip = %v\n&quot;</span>, conn, conn.RemoteAddr())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//这里准备一个协程为客户端服务</span></span><br><span class="line">		<span class="keyword">go</span> Process(conn)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项和使用细节：</strong></p>
<p>在conn.Read()函数使用时，所返回的n值可以限制读取的数据长度，防止切片申请过长时输出大量空格</p>
<h4 id="客户端的处理流程"><a href="#客户端的处理流程" class="headerlink" title="客户端的处理流程"></a>客户端的处理流程</h4><ol>
<li>建立与服务器的链接</li>
<li>发送数据请求，接收服务器端返回的结果数据</li>
<li>关闭链接</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;192.168.50.62:8888&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;client() err &quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;conn suc &quot;</span>, conn)</span><br><span class="line">	<span class="comment">//客户端可以发送单行数据</span></span><br><span class="line">	reader := bufio.NewReader(os.Stdin)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">//从终端读取一行用户输入，并准备发送给服务器</span></span><br><span class="line">		line, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;readerstring err &quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		line = strings.Trim(line, <span class="string">&quot; \r\n&quot;</span>)</span><br><span class="line">		<span class="comment">//如果用户输入exit就退出</span></span><br><span class="line">		<span class="keyword">if</span> line == <span class="string">&quot;exit&quot;</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;客户端退出&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将line发送给服务器</span></span><br><span class="line">		_, err = conn.Write([]<span class="type">byte</span>(line + <span class="string">&quot;\n&quot;</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;conn.Write err&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="Redis的基本介绍和操作原理"><a href="#Redis的基本介绍和操作原理" class="headerlink" title="Redis的基本介绍和操作原理"></a>Redis的基本介绍和操作原理</h3><p><strong>基本介绍：</strong></p>
<ul>
<li>Redis是NoSQL数据库，不是传统的关系型数据库。官网：<a target="_blank" rel="noopener" href="https://redis.io/%E5%92%8Chttp://www.redis.cn/">https://redis.io/和http://www.redis.cn/</a></li>
<li>Redis:Remote Dictionary Server(远程字典服务器)，Redis性能非常高，单机能够达到15w qps，通常适合做缓存，也可以持久化</li>
<li>是完全<strong>开源免费的，高性能的(key&#x2F;value)分布式内存数据库，基于内存运行并支持持久化的NoSQL数据口</strong>，是最热门的NoSQL数据库之一，也称为数据结构服务器</li>
</ul>
<p>下载后直接解压就有Redis的服务器端程序(redis-server.exe)和客户端程序(redis-cli.exe)，直接双击即可运行，并不需要安装</p>
<div align="center">
    <img src="/2022/02/15/Golang/Redis原理.jpg" style="zoom:30%" alt="Redis原理">
</div>

<p>除了通过.go程序发出指令外，还可以通过Redis自带的redis-cli.exe客户端发出指令</p>
<p><a target="_blank" rel="noopener" href="http://redisdoc.com/">Redis官方文档</a></p>
<p>说明：Redis安装好后，默认有16个数据库，初始默认使用0号库，编号为0…15</p>
<ol>
<li>添加key-val [set]</li>
<li>查看当前redis的所有key [keys *]</li>
<li>获取key对应的值 [get key]</li>
<li>切换redis数据库 [select index]</li>
<li>如何查看当前数据库的key-val数量 [dbsize]</li>
<li>清空当前数据库的key-val和清空所有数据库的key-val [flushdb]、[flushall]</li>
</ol>
<h3 id="Redis数据类型和crud操作"><a href="#Redis数据类型和crud操作" class="headerlink" title="Redis数据类型和crud操作"></a>Redis数据类型和crud操作</h3><p><strong>Redis的五大数据类型：</strong>String(字符串)、Hash(哈希)、List(列表)、Set(集合)、zset(sorted set：有序集合)</p>
<h4 id="String-字符串-介绍"><a href="#String-字符串-介绍" class="headerlink" title="String(字符串)-介绍"></a>String(字符串)-介绍</h4><p><strong>string是redis最基本的类型</strong>，一个key对应一个value</p>
<p>string类型是二进制安全的。除了普通的字符串外，也可存放图片等数据</p>
<p>redis中字符串value最大是512M</p>
<p>set指令：如果存在相当于修改，如果不存在相当于添加</p>
<p>其他指令：set、get、del</p>
<p>String-注意事项和细节说明：</p>
<ul>
<li>setex(set with expire)键秒值</li>
<li>mset[同时设置多个key-value]</li>
<li>mget[同时获取多个key-value]</li>
</ul>
<h4 id="Hash-哈希-介绍"><a href="#Hash-哈希-介绍" class="headerlink" title="Hash(哈希)-介绍"></a>Hash(哈希)-介绍</h4><p>Redis hash 是一个键值对集合</p>
<p><strong>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象</strong></p>
<p>hset指令：hset key feild value</p>
<p>其他指令：hset、hget、hdel</p>
<p>Hash-注意事项和细节说明：</p>
<ul>
<li>再给数据设置字段时可以一步一步设置，也可以使用hmset和hmget一次性设置多个field的值和返回多个field的值</li>
<li>hlen统计一个hash有几个元素</li>
<li>hexists key field查看哈希表key中field是否存在</li>
</ul>
<h4 id="List-列表-介绍"><a href="#List-列表-介绍" class="headerlink" title="List(列表)-介绍"></a>List(列表)-介绍</h4><p>列表是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表头部(左边)或者尾部(右边)</p>
<p><strong>List本质是个链表，List的元素时有序的，元素的值可以重复</strong></p>
<p>lpush指令：lpush key value1 value2…头插法插入</p>
<p>lrange指令：lrange key 0 -1全部取出，从头取出</p>
<p>返回值列表key中指定区间内的元素，区间以偏移量start和stop指定。下标(index)参数start和stop都以0为底，以0表示列表的第一个元素，以1表示列表的第二个元素，**-1表示列表的最后一个元素**，-2表示列表的倒数第二个元素</p>
<p>其他指令：lpush(从左边插入)、rpush(从右边插入)、lrange(从左边取出)、lrange(从右边取出)</p>
<p>List-注意事项和细节说明：</p>
<ul>
<li><p>lindex按照索引下标获得元素(从左到右，标号从0开始)</p>
</li>
<li><p>LLEN key</p>
<p>返回值列表key的长度，如果key不存在，则key被解释为一个空列表返回0</p>
</li>
<li><p>List的其他说明</p>
<p>List数据，可以从左或从右插入</p>
<p>如果值全部移除，对应的键也就消失了</p>
</li>
</ul>
<h4 id="Set-集合-介绍"><a href="#Set-集合-介绍" class="headerlink" title="Set(集合)-介绍"></a>Set(集合)-介绍</h4><p>Redis的Set是string类型的无需集合</p>
<p>底层是Hash Table数据结构，Set也可存放很多字符串元素，<strong>字符串元素是无序的，且元素的值不能重复</strong></p>
<p>sadd指令：sadd key value</p>
<p>其他指令：sadd、smembers(取出所有值)、sismember(判断值是否是成员)、srem(删除指定值)</p>
<h3 id="Go操作Redis"><a href="#Go操作Redis" class="headerlink" title="Go操作Redis"></a>Go操作Redis</h3><p>安装第三方开源Redis库</p>
<ol>
<li>使用第三方开源Redis库<a href="github.com/grayburd/redigo/redis">Redis开源库</a></li>
<li>在使用Redis前，先安装第三方Redis库，在GOPATH路径下执行安装指令</li>
</ol>
<p>特别说明：在安装Redis库前，去报已经安装并配置了Git，因为从Github下载Redis库需要使用Git</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;redigo-master/redigo-master/redis&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c, err := redis.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:6379&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Dial err&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> c.Close() <span class="comment">//关闭</span></span><br><span class="line">	<span class="comment">//通过Go向redis写入数据</span></span><br><span class="line">	_, err = c.Do(<span class="string">&quot;Set&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;tom&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Set err&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通过Go读取redis</span></span><br><span class="line">	r, err := redis.String(c.Do(<span class="string">&quot;Get&quot;</span>, <span class="string">&quot;name&quot;</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Get err&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//因为返回的r为interface类型，我们需要对其进行转换</span></span><br><span class="line">	fmt.Println(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对哈希进行操作时，返回值使用redis.Strings接收则最终为string类型切片</p>
<p>通过查看redis文档获取操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过Go向redis写入数据</span></span><br><span class="line">_, err = c.Do(<span class="string">&quot;HMSet&quot;</span>, <span class="string">&quot;user2&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;tom&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;HMset err&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Go读取redis</span></span><br><span class="line">r, err := redis.Strings(c.Do(<span class="string">&quot;HMGet&quot;</span>, <span class="string">&quot;user2&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;HMget err&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给数据设置有效时间</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, err := c.Do(<span class="string">&quot;expire&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>对String、Hash、List、Set操作信息见第二节及Redisdoc</p>
<h3 id="Redis连接池"><a href="#Redis连接池" class="headerlink" title="Redis连接池"></a>Redis连接池</h3><p>说明：通过Golang对Redis操作，还可以通过连接池</p>
<ol>
<li>实现初始化一定数量的连接，放入连接池</li>
<li>当Go需要操作Redis是，直接从Redis连接池取出连接即可</li>
<li>这样可以节省临时获取Redis连接的时间，从而提高效率</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pool *redis.Pool</span><br><span class="line">pool = &amp;redis.Pool&#123;</span><br><span class="line">    MaxIdle:<span class="number">8</span>,<span class="comment">//最大空闲连接数</span></span><br><span class="line">    MaxActive:<span class="number">0</span>,<span class="comment">//表示和数据库的最大连接数，0为没有限制</span></span><br><span class="line">    IdleTimeout:<span class="number">100</span>,<span class="comment">//最大空闲时间</span></span><br><span class="line">    Dial:<span class="function"><span class="keyword">func</span><span class="params">()</span></span>(redis.Conn, <span class="type">error</span>)&#123;<span class="comment">//初始化连接代码</span></span><br><span class="line">        <span class="keyword">return</span> redis.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:6379&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">c := pool.Get()<span class="comment">//从连接池中取出一个数据</span></span><br><span class="line">pool.Close()<span class="comment">//关闭连接池，一旦关闭连接池就不能再从连接池中取数据了</span></span><br></pre></td></tr></table></figure>

<p><strong>如果需要从连接池中取出连接，则需要连接池不可关闭</strong></p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Notes/">Notes</a><a class="post-meta__tags" href="/tags/Language/">Language</a><a class="post-meta__tags" href="/tags/DataBase/">DataBase</a></div><div class="post_share"><div class="social-share" data-image="http://5b0988e595225.cdn.sohucs.com/images/20190127/98d2709000f649198967eb6e91d26a1a.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2022/02/28/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"><img class="prev-cover" src="https://pic.baike.soso.com/ugc/baikepic2/4695/cut-20210930190131-1883791953_jpg_827_552_59299.jpg/1284" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">软件工程导论</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/03/14/C++/" title="C++"><img class="cover" src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/ISO_C%2B%2B_Logo.svg/1200px-ISO_C%2B%2B_Logo.svg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-14</div><div class="title">C++</div></div></a></div><div><a href="/2023/02/06/Flask/" title="Flask"><img class="cover" src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3c/Flask_logo.svg/1200px-Flask_logo.svg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-06</div><div class="title">Flask</div></div></a></div><div><a href="/2023/03/16/CMake/" title="CMake"><img class="cover" src="https://www.kitware.com/main/wp-content/uploads/2016/11/CMake-Logo-and-Text-e1540917038464.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-16</div><div class="title">CMake</div></div></a></div><div><a href="/2023/01/30/MySQL%E5%9F%BA%E7%A1%80/" title="MySQL"><img class="cover" src="https://upload.wikimedia.org/wikipedia/zh/thumb/6/62/MySQL.svg/1200px-MySQL.svg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-30</div><div class="title">MySQL</div></div></a></div><div><a href="/2023/05/11/C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="C++设计模式"><img class="cover" src="https://picx.zhimg.com/v2-f7e5e75bb391e9c74762d9dbee97f807_720w.jpg?source=172ae18b" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-11</div><div class="title">C++设计模式</div></div></a></div><div><a href="/2023/07/04/C++11/" title="C++11"><img class="cover" src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/ISO_C%2B%2B_Logo.svg/1200px-ISO_C%2B%2B_Logo.svg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-04</div><div class="title">C++11</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/day.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">santidad DAY</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">17</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/santidadday" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Go%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">Go语言的特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8"><span class="toc-number">2.</span> <span class="toc-text">Go语言的快速开发入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.1.</span> <span class="toc-text">Go语言的开发步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">Go的执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.3.</span> <span class="toc-text">Go开发注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">2.4.</span> <span class="toc-text">Go语言的转义字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go%E8%AF%AD%E8%A8%80%E6%B3%A8%E9%87%8A%EF%BC%88comment%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">Go语言注释（comment）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.5.1.</span> <span class="toc-text">注释类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E8%8C%83%E7%9A%84%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="toc-number">2.6.</span> <span class="toc-text">规范的代码风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Golang%E6%A0%87%E5%87%86%E5%BA%93API%E6%96%87%E6%A1%A3"><span class="toc-number">2.7.</span> <span class="toc-text">Golang标准库API文档</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.1.</span> <span class="toc-text">程序中 + 的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">4.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">整数类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%95%B0%E7%B1%BB%E5%9E%8B-x2F-%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">小数类型&#x2F;浮点类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.3.</span> <span class="toc-text">字符类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.4.</span> <span class="toc-text">布尔类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.5.</span> <span class="toc-text">字符串类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Golang%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">5.6.</span> <span class="toc-text">Golang的基本数据类型的默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.7.</span> <span class="toc-text">基本数据类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BAstring"><span class="toc-number">5.8.</span> <span class="toc-text">基本数据类型转换为string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.9.</span> <span class="toc-text">string转换为基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.10.</span> <span class="toc-text">指针类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.11.</span> <span class="toc-text">值类型和引用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">5.12.</span> <span class="toc-text">标识符的命名规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E7%95%99%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E9%A2%84%E5%AE%9A%E4%B9%89%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">5.13.</span> <span class="toc-text">保留关键字和预定义标识符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.</span> <span class="toc-text">运算符介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.1.</span> <span class="toc-text">算数运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.2.</span> <span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.3.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.4.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.5.</span> <span class="toc-text">其他运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">6.6.</span> <span class="toc-text">运算符的优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%B8%AD%E7%AB%AF%E8%BE%93%E5%85%A5"><span class="toc-number">7.</span> <span class="toc-text">获取用户中端输入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E8%AF%AD%E5%8F%A5"><span class="toc-number">7.1.</span> <span class="toc-text">键盘输入语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6"><span class="toc-number">8.</span> <span class="toc-text">进制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">8.1.</span> <span class="toc-text">进制介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.2.</span> <span class="toc-text">进制的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6"><span class="toc-number">8.2.1.</span> <span class="toc-text">其他进制转十进制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%85%B6%E4%BB%96%E8%BF%9B%E5%88%B6"><span class="toc-number">8.2.2.</span> <span class="toc-text">十进制转其他进制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%85%B6%E4%BB%96%E8%BF%9B%E5%88%B6"><span class="toc-number">8.2.3.</span> <span class="toc-text">二进制转其他进制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="toc-number">8.2.4.</span> <span class="toc-text">其他进制转二进制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E7%A0%81-%E5%8E%9F%E7%A0%81-%E8%A1%A5%E7%A0%81"><span class="toc-number">8.3.</span> <span class="toc-text">反码 原码 补码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9C%A8%E8%BF%90%E7%AE%97%E4%B8%AD%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-number">8.3.1.</span> <span class="toc-text">二进制在运算中的说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81"><span class="toc-number">8.3.2.</span> <span class="toc-text">原码、反码、补码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">8.4.</span> <span class="toc-text">位运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">程序流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.1.</span> <span class="toc-text">顺序控制介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E6%8E%A7%E5%88%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.2.</span> <span class="toc-text">分支控制介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%88%86%E6%94%AF"><span class="toc-number">9.2.1.</span> <span class="toc-text">单分支</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%88%86%E6%94%AF"><span class="toc-number">9.2.2.</span> <span class="toc-text">双分支</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%88%86%E6%94%AF"><span class="toc-number">9.2.3.</span> <span class="toc-text">多分支</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%88%86%E6%94%AF"><span class="toc-number">9.2.4.</span> <span class="toc-text">嵌套分支</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="toc-number">9.2.5.</span> <span class="toc-text">switch分支结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.3.</span> <span class="toc-text">循环控制介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.3.1.</span> <span class="toc-text">循环介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-number">9.3.2.</span> <span class="toc-text">for循环控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#while%E5%92%8Cdo%E2%80%A6while%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.3.3.</span> <span class="toc-text">while和do…while的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-number">9.4.</span> <span class="toc-text">多重循环控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">9.5.</span> <span class="toc-text">跳转控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Break"><span class="toc-number">9.5.1.</span> <span class="toc-text">Break</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#continue"><span class="toc-number">9.5.2.</span> <span class="toc-text">continue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#goto"><span class="toc-number">9.5.3.</span> <span class="toc-text">goto</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#return"><span class="toc-number">9.5.4.</span> <span class="toc-text">return</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">10.</span> <span class="toc-text">函数和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">10.1.</span> <span class="toc-text">函数的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">10.2.</span> <span class="toc-text">包的介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">10.3.</span> <span class="toc-text">函数-调用机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#return%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.3.1.</span> <span class="toc-text">return语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8"><span class="toc-number">10.4.</span> <span class="toc-text">函数的递归调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#init%E5%87%BD%E6%95%B0"><span class="toc-number">10.5.</span> <span class="toc-text">init函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">10.6.</span> <span class="toc-text">匿名函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">10.7.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%AD%E2%80%94%E2%80%94defer"><span class="toc-number">10.8.</span> <span class="toc-text">函数中——defer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F"><span class="toc-number">10.9.</span> <span class="toc-text">函数参数的传递方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">10.10.</span> <span class="toc-text">变量作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0"><span class="toc-number">10.11.</span> <span class="toc-text">字符串中常用的系统函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">10.12.</span> <span class="toc-text">时间和日期相关函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-number">10.13.</span> <span class="toc-text">内置函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">10.14.</span> <span class="toc-text">Go错误处理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF"><span class="toc-number">10.15.</span> <span class="toc-text">自定义错误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87"><span class="toc-number">11.</span> <span class="toc-text">数组和切片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">11.1.</span> <span class="toc-text">数组介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">11.2.</span> <span class="toc-text">数组定义和内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86"><span class="toc-number">11.3.</span> <span class="toc-text">数组遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%BD%BF%E7%94%A8"><span class="toc-number">11.4.</span> <span class="toc-text">数组使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slice%E5%88%87%E7%89%87"><span class="toc-number">11.5.</span> <span class="toc-text">slice切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">11.6.</span> <span class="toc-text">切片使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E9%81%8D%E5%8E%86"><span class="toc-number">11.7.</span> <span class="toc-text">切片遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%92%8Cslice"><span class="toc-number">11.8.</span> <span class="toc-text">string和slice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">11.9.</span> <span class="toc-text">二维数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map"><span class="toc-number">12.</span> <span class="toc-text">map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">12.1.</span> <span class="toc-text">map的使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-number">12.2.</span> <span class="toc-text">map的增删改查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E9%81%8D%E5%8E%86"><span class="toc-number">12.3.</span> <span class="toc-text">map遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E5%88%87%E7%89%87"><span class="toc-number">12.4.</span> <span class="toc-text">map切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E6%8E%92%E5%BA%8F"><span class="toc-number">12.5.</span> <span class="toc-text">map排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%E5%92%8C%E9%99%B7%E9%98%B1"><span class="toc-number">12.6.</span> <span class="toc-text">map的使用细节和陷阱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E2%80%9D%E5%AF%B9%E8%B1%A1%E2%80%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">13.</span> <span class="toc-text">面向”对象“编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">13.1.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%A3%B0%E6%98%8E%E5%92%8C%E6%98%AF%E7%94%A8%E7%BC%BA%E9%99%B7"><span class="toc-number">13.2.</span> <span class="toc-text">结构体声明和是用缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E5%92%8C%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5"><span class="toc-number">13.3.</span> <span class="toc-text">创建结构体变量和访问结构体字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">13.4.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%A3%B0%E6%98%8E%EF%BC%88%E5%AE%9A%E4%B9%89%EF%BC%89"><span class="toc-number">13.5.</span> <span class="toc-text">方法的声明（定义）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB"><span class="toc-number">13.6.</span> <span class="toc-text">方法和函数区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%BA%94%E7%94%A8"><span class="toc-number">13.7.</span> <span class="toc-text">面向对象编程应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%AD%A5%E9%AA%A4"><span class="toc-number">13.7.1.</span> <span class="toc-text">面向对象步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E8%B5%8B%E5%80%BC"><span class="toc-number">13.7.2.</span> <span class="toc-text">结构体赋值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">13.8.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E6%8A%BD%E8%B1%A1"><span class="toc-number">13.9.</span> <span class="toc-text">面向对象编程思想-抽象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%88%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81%EF%BC%89"><span class="toc-number">13.10.</span> <span class="toc-text">面向对象编程的三大特性（封装、继承、多态）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">13.10.1.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">13.10.2.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%EF%BC%88interface%EF%BC%89"><span class="toc-number">13.10.3.</span> <span class="toc-text">接口（interface）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.10.4.</span> <span class="toc-text">接口和继承的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">13.10.5.</span> <span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">13.11.</span> <span class="toc-text">类型断言</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">14.</span> <span class="toc-text">文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">14.1.</span> <span class="toc-text">常用的文件操作函数和方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-number">14.2.</span> <span class="toc-text">读取文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">14.3.</span> <span class="toc-text">写文件操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-number">14.4.</span> <span class="toc-text">判断文件是否存在</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">14.5.</span> <span class="toc-text">文件拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%9C%A8%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">14.6.</span> <span class="toc-text">统计在文件中的字符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">15.</span> <span class="toc-text">命令行参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#flag%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">15.1.</span> <span class="toc-text">flag解析命令行参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Json%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">16.</span> <span class="toc-text">Json基本介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">16.1.</span> <span class="toc-text">JSON数据格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">16.2.</span> <span class="toc-text">JSON序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">16.3.</span> <span class="toc-text">JSON反序列化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">17.</span> <span class="toc-text">单元测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GoRoutine%E5%92%8CChannel"><span class="toc-number">18.</span> <span class="toc-text">GoRoutine和Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Goroutine"><span class="toc-number">18.1.</span> <span class="toc-text">Goroutine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go%E5%8D%8F%E7%A8%8B%E5%92%8CGo%E4%B8%BB%E7%BA%BF%E7%A8%8B"><span class="toc-number">18.2.</span> <span class="toc-text">Go协程和Go主线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MPG%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">18.3.</span> <span class="toc-text">MPG模式基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Golang%E4%B8%AD%E8%AE%BE%E7%BD%AE%E8%BF%90%E8%A1%8CCPU"><span class="toc-number">18.4.</span> <span class="toc-text">Golang中设置运行CPU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Golang%E4%B8%AD%E5%B9%B6%E5%8F%91%EF%BC%88%E5%B9%B6%E8%A1%8C%EF%BC%89%E5%BC%95%E8%B5%B7%E7%9A%84%E8%B5%84%E6%BA%90%E4%BA%89%E5%A4%BA%E9%97%AE%E9%A2%98"><span class="toc-number">18.5.</span> <span class="toc-text">Golang中并发（并行）引起的资源争夺问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel%E7%AE%A1%E9%81%93"><span class="toc-number">18.6.</span> <span class="toc-text">Channel管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#channel%E5%85%B3%E9%97%AD"><span class="toc-number">18.7.</span> <span class="toc-text">channel关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#channel%E9%81%8D%E5%8E%86"><span class="toc-number">18.8.</span> <span class="toc-text">channel遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">19.</span> <span class="toc-text">反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E2%80%94TCP-Socket%E7%BC%96%E7%A8%8B"><span class="toc-number">20.</span> <span class="toc-text">网络编程—TCP Socket编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">20.1.</span> <span class="toc-text">网络编程的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80"><span class="toc-number">20.1.1.</span> <span class="toc-text">IP地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3"><span class="toc-number">20.1.2.</span> <span class="toc-text">端口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-Socket%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="toc-number">20.2.</span> <span class="toc-text">TCP Socket编程的客户端和服务器端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">20.2.1.</span> <span class="toc-text">服务器端的处理流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">20.2.2.</span> <span class="toc-text">客户端的处理流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-number">21.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E5%92%8C%E6%93%8D%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">21.1.</span> <span class="toc-text">Redis的基本介绍和操作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8Ccrud%E6%93%8D%E4%BD%9C"><span class="toc-number">21.2.</span> <span class="toc-text">Redis数据类型和crud操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E4%BB%8B%E7%BB%8D"><span class="toc-number">21.2.1.</span> <span class="toc-text">String(字符串)-介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash-%E5%93%88%E5%B8%8C-%E4%BB%8B%E7%BB%8D"><span class="toc-number">21.2.2.</span> <span class="toc-text">Hash(哈希)-介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List-%E5%88%97%E8%A1%A8-%E4%BB%8B%E7%BB%8D"><span class="toc-number">21.2.3.</span> <span class="toc-text">List(列表)-介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set-%E9%9B%86%E5%90%88-%E4%BB%8B%E7%BB%8D"><span class="toc-number">21.2.4.</span> <span class="toc-text">Set(集合)-介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go%E6%93%8D%E4%BD%9CRedis"><span class="toc-number">21.3.</span> <span class="toc-text">Go操作Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">21.4.</span> <span class="toc-text">Redis连接池</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="Linux网络编程"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux网络编程"/></a><div class="content"><a class="title" href="/2023/12/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="Linux网络编程">Linux网络编程</a><time datetime="2023-11-30T16:00:00.000Z" title="Created 2023-12-01 00:00:00">2023-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/03/ROS/" title="ROS基础"><img src="https://d2908q01vomqb2.cloudfront.net/ca3512f4dfa95a03169c5a670a4c91a19b3077b4/2018/11/26/ros-logo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ROS基础"/></a><div class="content"><a class="title" href="/2023/11/03/ROS/" title="ROS基础">ROS基础</a><time datetime="2023-11-02T16:00:00.000Z" title="Created 2023-11-03 00:00:00">2023-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/04/C++11/" title="C++11"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/ISO_C%2B%2B_Logo.svg/1200px-ISO_C%2B%2B_Logo.svg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++11"/></a><div class="content"><a class="title" href="/2023/07/04/C++11/" title="C++11">C++11</a><time datetime="2023-07-03T16:00:00.000Z" title="Created 2023-07-04 00:00:00">2023-07-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" title="Linux系统编程"><img src="https://file.rymooc.com/SuperLargeCover/200303ae51194686d43e" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux系统编程"/></a><div class="content"><a class="title" href="/2023/06/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" title="Linux系统编程">Linux系统编程</a><time datetime="2023-06-19T16:00:00.000Z" title="Created 2023-06-20 00:00:00">2023-06-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/11/C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="C++设计模式"><img src="https://picx.zhimg.com/v2-f7e5e75bb391e9c74762d9dbee97f807_720w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++设计模式"/></a><div class="content"><a class="title" href="/2023/05/11/C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="C++设计模式">C++设计模式</a><time datetime="2023-05-10T16:00:00.000Z" title="Created 2023-05-11 00:00:00">2023-05-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2025 By santidad DAY</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">welcome  to  my  <a  target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>