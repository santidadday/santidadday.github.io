<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>微型计算机原理及接口技术 | DAY's Blog</title><meta name="keywords" content="Notes"><meta name="author" content="santidad DAY"><meta name="copyright" content="santidad DAY"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="微型计算机原理和接口技术是计算机科学中的一个重要分支，它主要研究微型计算机的基本原理、结构和工作方式，以及微型计算机与外界设备之间的接口技术。">
<meta property="og:type" content="article">
<meta property="og:title" content="微型计算机原理及接口技术">
<meta property="og:url" content="https://santidadday.github.io/2022/03/12/%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/index.html">
<meta property="og:site_name" content="DAY&#39;s Blog">
<meta property="og:description" content="微型计算机原理和接口技术是计算机科学中的一个重要分支，它主要研究微型计算机的基本原理、结构和工作方式，以及微型计算机与外界设备之间的接口技术。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://image.zhihuishu.com/zhs/createcourse/course/202002/cb6922bdce6847ec90051acdadb791da_s1.png">
<meta property="article:published_time" content="2022-03-11T16:00:00.000Z">
<meta property="article:modified_time" content="2023-03-14T13:28:00.000Z">
<meta property="article:author" content="santidad DAY">
<meta property="article:tag" content="Notes">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image.zhihuishu.com/zhs/createcourse/course/202002/cb6922bdce6847ec90051acdadb791da_s1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://santidadday.github.io/2022/03/12/%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '微型计算机原理及接口技术',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-14 21:28:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/day.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">17</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">DAY's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">微型计算机原理及接口技术</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">Created</span><time datetime="2022-03-11T16:00:00.000Z" title="Created 2022-03-12 00:00:00">2022-03-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="微型计算机原理及接口技术"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="微型计算机基础"><a href="#微型计算机基础" class="headerlink" title="微型计算机基础"></a>微型计算机基础</h2><p><strong>计算机中的信息表示</strong></p>
<ul>
<li>数值数据：数制、数值编码</li>
<li>非数值数据：字符编码</li>
</ul>
<p><strong>微型计算机系统的基本组成</strong></p>
<ul>
<li>系统组成</li>
<li>硬件结构和工作过程：CPU、总线、存储器、IO接口、IO设备</li>
</ul>
<h3 id="计算机中的数值"><a href="#计算机中的数值" class="headerlink" title="计算机中的数值"></a>计算机中的数值</h3><p><strong>常用计数值：</strong></p>
<ul>
<li>十进制数：0~9，基数为10，编程时使用（D）</li>
<li>二进制数：计算机内部信息存储、运算和输入输出都是二进制数（B）</li>
<li>十六进制数：人们最常用的是十进制数，但是计算机中为了物理实现方便采用二进制数，我们通过数字及字母组合而成十六进制数</li>
</ul>
<p><strong>数值转换：</strong></p>
<ul>
<li><p>二、八、十六进制数转十进制数</p>
<p>算法：每位的代码和该为的权值相乘，再求累加和</p>
</li>
<li><p>二进制数转十六进制数</p>
<p>算法：四位二进制数为一组，每组用等值的十六进制数代换</p>
</li>
<li><p>十六进制数转二进制数</p>
<p>算法：一位十六进制数用等值的四位二进制数代换</p>
</li>
<li><p>十进制数转二进制数</p>
<p>算法：每次除二直到商为零，余数倒排</p>
</li>
<li><p>十进制数纯小数转二进制数</p>
<p>算法：乘二取整，直到乘积的小数部分 为零为止，整数部分顺排</p>
</li>
<li><p>十进制带小数转二进制数</p>
<p>算法：整数、纯小数分别计算再合并</p>
</li>
</ul>
<h3 id="计算机中的信息表示"><a href="#计算机中的信息表示" class="headerlink" title="计算机中的信息表示"></a>计算机中的信息表示</h3><p>数据：数值数据（无符号数、有符号数）、非数值数据（字符、图形等）</p>
<p><strong>字符的编码—ASCII码</strong></p>
<p>计算机常用的输入&#x2F;输出设备（键盘、显示器、打印机）处理的数都是字符</p>
<p>采用美国标准信息交换码（ACSII）对字符进行编码</p>
<p>采用七位二进制编码来表示一个字符，该编码方案中共有128个字符，八位时最高位恒为零</p>
<p><strong>十进制数的二进制编码—BCD码</strong></p>
<p>采用二进制数对每一位十进制数字进行编码所得到的数叫做二 十进制数，简称BCD码</p>
<p>BCD码有多种形式，最常用的是8421BCD码，它是用四位二进制数对一个十进制数进行编码，这四位二进制码的值就是被编码为一位十进制数的值</p>
<p>BCD码在计算机中的存储分为紧凑型和非紧凑型</p>
<p><strong>有符号数的编码—原、反、补码</strong></p>
<p>计算机只能识别0和1组成的数或代码，所以有符号数的符号也只能用0和1来表示，即符号数值化，并作为数的一部分参与运算</p>
<p>真值：一个数的数值用“+”表示正数，用“-”表示负数</p>
<p>机器数：用符号为的0和1表示数的正负</p>
<p>字长：是计算机在同一时间内处理二进制数的位数。是CPU的一个主要的技术指标</p>
<p>对有符号数来讲，是包括符号位在内的一个二进制有符号数占有的位数</p>
<p>由于机器数的数值部分的表示方法不同，有符号数可有三种表示方法（即机器数有三种形式），分别叫做：原码、反码、补码</p>
<p>原码：最高位为符号位，数值部分就是该数的绝对值</p>
<p>反码：正数的反码与其原码相同，负数的反码是其除符号位外按位取反</p>
<p>补码：正数的补码与其原码反码相同，负数的补码是在其反码的基础上加1</p>
<p><strong>无符号数</strong></p>
<p>某些处理的数据都是正数，最小数为0。可以取消符号位，机器数的最高位是数值位</p>
<h3 id="整数补码运算"><a href="#整数补码运算" class="headerlink" title="整数补码运算"></a>整数补码运算</h3><p><strong>“模”的概念</strong></p>
<p>一个计量器的最大容量称为该计量器的“模”</p>
<p>四位的加法器的有模运算（由四个全加器组成）模&#x3D;16</p>
<p>在机器内部使用补码运算，符号位参加运算</p>
<p>定字长的机器表示的数值是有范围的，超出范围时的数据表示出错</p>
<p><strong>溢出和进位</strong></p>
<p>进位：运算后，最高位想更高位的进位值</p>
<p>溢出：运算结果超出了运算器所能表示的范围</p>
<p><strong>溢出判断</strong></p>
<ul>
<li>如果参与运算的数是无符号数，则判进位标志，进位标志（CF）&#x3D;1，表示溢出错</li>
<li>如果参与运算的数是有符号数，则判溢出标志，溢出标志（OF）&#x3D;1，表示溢出错</li>
</ul>
<h3 id="微型计算机系统的基本组成"><a href="#微型计算机系统的基本组成" class="headerlink" title="微型计算机系统的基本组成"></a>微型计算机系统的基本组成</h3><p><strong>计算机系统组成</strong></p>
<p>按照冯诺依曼的计算机体系逻辑结构思想</p>
<p>硬件：存储器、控制器、运算器、输入、输出</p>
<p>软件：系统软件、应用软件</p>
<p><strong>微型计算机的硬件结构</strong></p>
<p>以CPU为核心通过三条总线连接存储器、I&#x2F;O接口，构成微型计算机以其为主体，配上系统软件和外设，构成微型计算机系统</p>
<p>CPU：即微处理器，是超大规模集成电路，内部集成了运算器、控制器、寄存器组…</p>
<p>存储器：指系统的主存储器，简称为内存或主存。用来存放程序、数据</p>
<p>I&#x2F;O接口：是CPU和外部设备交换信息的“中转站”</p>
<p>外部设备不能直接与CPU交换信息，必须通过接口</p>
<p>地址总线：传输CPU访问存储器，访问I&#x2F;O端口的地址信号</p>
<p>数据总线：传输CPU读&#x2F;写内存，读写I&#x2F;O时的数据</p>
<p>控制总线：CPU发出的控制命令，或外部向CPU提出的请求</p>
<p><strong>计算机工作过程</strong></p>
<p>存储程序：</p>
<ul>
<li>程序由多条有逻辑关系的指令组成，指令的长度不等（一般为1~4字节），指令是程序员发出的，计算机能识别的，通知CPU执行某种操作的命令</li>
<li>计算机的工作就是逐条执行由指令构成的程序</li>
<li>程序和数据均以二进制代码的形式不加区别地存放在存储器中，存放位置由地址指定，地址码也是二进制形式</li>
</ul>
<p>程序控制：</p>
<ul>
<li>计算机按程序的流程自动地连续取出指令并执行</li>
<li>为实现自动连续执行程序，控制器设置一程序计数器PC，它根据指令的长度自动增量（总是指向下一条指令）。只要给出程序中第一条指令的地址，控制器就可以依据存储程序中的指令顺序周而复始地取指令、译码、执行，直到完成全部指令操作位置，即控制器通过指令流的串行驱动实现程序控制</li>
</ul>
<h3 id="存储器基本概念"><a href="#存储器基本概念" class="headerlink" title="存储器基本概念"></a>存储器基本概念</h3><p><strong>基本术语</strong></p>
<p>存储元：存储器的最小组成单位，用以存储1位二进制代码</p>
<p>存储单元：是CPU访问存储器基本单位，由若干个具有相同操作属性的存储元组成</p>
<p>存储体：存储单元的集合，是存放二进制信息的地方</p>
<p>单元地址：在存储器中用以表识存储单元的唯一编号，CPU通过该编号访问相应的存储单元</p>
<p>存储器：存储体和地址译码电路、读写控制电路等一起构成存储器</p>
<p><strong>存储器的分类</strong></p>
<p>按存储介质分：半导体存储器、磁表面存储器</p>
<p>按存储器的读写功能分：只读存储器（ROM）、随机读写存储器（RAM）</p>
<p>按在计算机系统中的作用分：主存储器、辅助存储器、高速缓冲存储器、控制存储器等</p>
<p><strong>存储器在计算机中的作用</strong></p>
<p>RAM：随机存储器，是“内存”的重要组成部分，CPU执行指令可对器进行“读”、“写”操作</p>
<p>静态RAM：集成度低，信息稳定，读写速度快</p>
<p>动态RAM：集成度高，容量大，缺点是信息存储不稳定，只能保持几个毫秒，为此要不断进行“信息再生”</p>
<p>高速缓冲存储器Cache：Cache位于CPU与主存储器之间，由高速静态RAM组成。容量较小，为提高整机运新速度而设置，应用程序之间不能访问Cache，CPU内部也有Cache</p>
<p>ROM：只读存储器，所有信息只能读出，不能写入</p>
<p>ROM&#x2F;EPROM：在微机系统中的应用</p>
<ul>
<li>存放“基本输入&#x2F;输出系统程序”（简称BIOS）</li>
<li>BIOS是计算机最底层的系统管理程序，操作系统和用户程序均可调用</li>
</ul>
<hr>
<h2 id="80x86微处理器"><a href="#80x86微处理器" class="headerlink" title="80x86微处理器"></a>80x86微处理器</h2><p>intel微处理器发展概况：微处理器常用术语、inter微处理器的发展</p>
<p>32位微处理器的内部结构：内部结构、编程结构（基本结构寄存器）</p>
<p>32位微处理器的工作模式：处理器的地址空间、实地址模式（物理地址的形成）、保护模式、虚拟8086模式</p>
<h3 id="80x86微处理器发展与内部结构"><a href="#80x86微处理器发展与内部结构" class="headerlink" title="80x86微处理器发展与内部结构"></a>80x86微处理器发展与内部结构</h3><p><strong>intel微处理器发展概况</strong></p>
<p>常用术语：</p>
<ul>
<li>字长：字长是微处理器一次可以直接处理的二进制数码的位数。通常取决于微处理器内部通用寄存器的位数和数据总线的宽度</li>
<li>寻址能力：指CPU能直接存取数据的内存地址的范围，它有CPU的地址总线的数目决定</li>
<li>主频：也叫时钟频率，用来表示微处理器的运行速度，主频越高表明微处理器运行越快</li>
<li>MIPS：用来表示微处理器的性能（运算速度）</li>
<li>微处理器的集成度：指微处理器芯片上集成的晶体管的密度</li>
</ul>
<p>8086微处理器的基本功能模块：</p>
<ul>
<li>总线接口单元BIU（寄存器组）</li>
<li>执行单元EU（运算器和控制器、寄存器组）</li>
</ul>
<p>80286内部结构：具备8086&#x2F;8088最基本的功能外还增加了虚拟存储、特权保护、任务管理等功能，支持多用户和多任务系统</p>
<p>微处理的功能扩展模块：存储管理（分页、分段部件）、指令和数据流水线、指令和数据Cache等</p>
<p>Pentium采用了多项领先的技术：CISC和RISC相结合技术、超标量流水线技术、分支预测技术</p>
<p><strong>32位微处理器内部结构</strong></p>
<p>486内部寄存器分为4类：基本结构寄存器、浮点寄存器、系统级寄存器、调试测试寄存器</p>
<p>应用程序只能访问基本结构寄存器和浮点寄存器</p>
<p>通用寄存器：AX（累加器）、BX（基址寄存器）、CX（计数器）、DX（数据寄存器）、IP（指令指针）、SP（堆栈指针）、BP（基址指针）、SI（源变址寄存器）、DI（目的变址寄存器）、EFLAGS（标志寄存器）</p>
<p>AX、BX、CX、DX共同特点：</p>
<ul>
<li>既可作为16位寄存器来用又可作为两个8位寄存器（高低位）来用</li>
<li>都是用于暂存操作数，或是运算的中间结果或其他一些信息</li>
<li>指令&#x3D;操作码+操作数</li>
</ul>
<p>标志寄存器提供两类标志：状态标志、控制标志</p>
<p>段寄存器：CS（代码）、DS（数据）、ES（附加）、SS（堆栈）、FS、GS</p>
<ul>
<li>寻址程序（指令）：CS+IP</li>
<li>寻址数据：（DS或ES）+（SI或DI、BX、BP）</li>
<li>寻址堆栈：SS+（SP或BP）</li>
</ul>
<h3 id="32位微处理器工作模式"><a href="#32位微处理器工作模式" class="headerlink" title="32位微处理器工作模式"></a>32位微处理器工作模式</h3><p><strong>32位微处理器地址空间</strong></p>
<p>存储空间：</p>
<ul>
<li>物理空间（物理存储器地址空间）：程序的运行空间，即主存空间</li>
<li>虚拟空间（虚拟存储器地址空间）：编程空间<ul>
<li>虚拟存储器是一项硬件和软件结合的技术</li>
<li>CPU内部的存储管理部件把主存（物理存储器）和辅存（磁盘）看做是一个整体，即虚拟存储器</li>
<li>允许变成空间为64T，程序员可在此范围内编程，大大超过物理空间。该空间对应的地址称为虚拟地址或逻辑地址</li>
<li>程序运行时，操作系统从虚拟空间取出一部分代码载入物理空间运行</li>
</ul>
</li>
<li>线性空间：<ul>
<li>当程序从虚拟空间调入物理空间时，要进行地址转换</li>
<li>分段部件首先把虚拟地址（编程地址）转换为线性地址</li>
<li>如果不分页的话，线性地址就是物理地址</li>
<li>如果分页的话，则由分页部件把线性地址转换为物理地址</li>
</ul>
</li>
<li>I&#x2F;O空间：<ul>
<li>I&#x2F;O地址空间不分段</li>
<li>I&#x2F;O地址空间与存储空间不重叠</li>
<li>基于intel微处理器的系统机，实际上只使用低10位地址线，寻址1024个I&#x2F;O端口</li>
</ul>
</li>
</ul>
<p><strong>32位微处理器工作模式</strong></p>
<p>实地址模式（实模式）</p>
<ul>
<li>加电、复位之后486自动工作在实模式，系统在DOS管理下</li>
<li>在实模式下，486只能访问第一个1M内存</li>
<li>存储管理部件对存储器只进行分段管理，没有分页功能，每一逻辑段的最大容量为64K</li>
<li>在实模式下，段寄存器中存放段基址</li>
</ul>
<p>保护虚拟地址模式（保护模式）</p>
<ul>
<li>在保护模式下，486支持多任务操作系统</li>
<li>在保护模式下，486可以访问4G物理存储空间，存储器用虚拟地址空间、线性地址空间和物理地址空间三种方式进行描述，虚拟地址就是逻辑地址</li>
<li>CPU内部的存储管理部件对存储器采用分段和分页管理</li>
<li>既能进行16位运算，也能进行32位运算</li>
</ul>
<p>虚拟86模式是保护模式下的一种特殊工作模式，可运行实模式程序</p>
<p>在操作系统管理下，486可以分尸地运行多个实模式程序</p>
<p>不能从实模式直接进入虚拟86模式，也不能从虚拟86模式直接回到实模式</p>
<h3 id="32位微处理器实地址模式下20位物理地址的形成"><a href="#32位微处理器实地址模式下20位物理地址的形成" class="headerlink" title="32位微处理器实地址模式下20位物理地址的形成"></a>32位微处理器实地址模式下20位物理地址的形成</h3><p><strong>实模式下的物理地址和逻辑地址</strong></p>
<p>物理空间对应物理地址：1MB存储区域中的某一单元地址，地址信息是20位的二进制代码</p>
<p>编程空间（虚拟空间）对应的逻辑地址：编程程序应采用逻辑地址。程序是分段的，逻辑地址由段基址和偏移地址组成</p>
<ul>
<li>在一个逻辑段中，各单元的短地址是相同的，偏移地址是该单元相对于段首的地址偏移量</li>
<li>所有段都是起始于16字节的边界，段起始物理地址为XXXX0H</li>
<li>物理地址为12345H的单元，逻辑地址可能为1000H:2345H，也可能为其他</li>
<li>实模式下，把1M字节的存储器分为任意数量的段，其中每一段最大长度为64K字节</li>
<li>段的起始地址的高16位地址称为该段的段基址。段内再由16位二进制数寻址，段内寻址的16位二进制数地址是存储单元到段起始地址的距离，称为段偏移</li>
</ul>
<p>20位物理地址的计算由BIU中的地址加法器完成</p>
<p>注意：物理地址是唯一的，不同的逻辑地址可得到相同的物理地址</p>
<p>实地址模式下各逻辑段物理地址的形成：</p>
<ul>
<li>代码段：CS*16+IP&#x3D;指令单元的物理地址，一条指令的一个字节取出后，IP自动加1，指向下一字节</li>
<li>堆栈段：SS*16+SP&#x3D;栈顶单元的物理地址</li>
<li>数据段：DS*16+偏移地址&#x3D;数据单元的物理地址</li>
</ul>
<hr>
<h2 id="汇编语言指令集"><a href="#汇编语言指令集" class="headerlink" title="汇编语言指令集"></a>汇编语言指令集</h2><p>指令概述：指令的构成和书写格式、指令在内存中的存放方式</p>
<p>操作数：通用寄存器操作数、段寄存器和程序指针、标志寄存器</p>
<p>寻址方式：立即寻址、寄存器寻址、存储器操作数寻址（直接寻址、寄存器间接寻址、基址寻址、变址寻址、基址加变址寻址）</p>
<p>汇编语言语法：概述（汇编语句类型和格式）、伪指令（字节&#x2F;字&#x2F;双字&#x2F;多字节定义，等值，等号伪指令）、运算符（算数&#x2F;关系&#x2F;$&#x2F;SEG&#x2F;OFFSET&#x2F;PTR&#x2F;方括号运算符）</p>
<p>汇编语言基本指令集：传送类指令、算术运算指令、逻辑运算指令、转移和调用指令、串操作指令、处理机控制指令</p>
<h3 id="指令概述"><a href="#指令概述" class="headerlink" title="指令概述"></a>指令概述</h3><p><strong>指令：</strong>是CPU操作的基本单位，每条指令执行一个特定的操作。可以理解为：指令通知CPU执行某操作的“命令”</p>
<p><strong>指令分类：</strong></p>
<ul>
<li>机器指令：二进制格式编码的序列（一串0,1代码书写）。硬件只能识别、存储、运行机器指令</li>
<li>符号指令：用字符串形式的序列（包括字符串形式的操作码以及操作数助记符）表示</li>
</ul>
<p><strong>指令的组成：</strong></p>
<ul>
<li>操作码：计算机要执行的操作</li>
<li>操作数：执行操作过程所要操作的数</li>
<li>标号：标号又称符号地址，代表该指令的逻辑地址</li>
<li>注解：以“；”开头，不执行</li>
</ul>
<p><strong>指令的长度：</strong>指令在存储器中占用的字节数称为指令长度。80x86指令长度（机器指令长度）为1~16字节</p>
<p><strong>指令的地址：</strong>多字节指令占用连续的内存单元，存放指令第一字节的内存单元地址，称为“指令地址”</p>
<p><strong>指令的存放：</strong>首先存放操作码，然后存放操作数</p>
<h3 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h3><p>32位CPU标志寄存器为32位，实际使用15位</p>
<p>15为标志分为两类：状态标志和控制标志</p>
<ul>
<li>状态标志记录了当前指令执行后的状态信息</li>
<li>控制标志用来控制微处理器操作</li>
</ul>
<p> <strong>C标志—进位&#x2F;借位标志</strong></p>
<p>字节加&#x2F;减，最高位（D7）产生进位&#x2F;借位时：C标志置1，否则置0</p>
<p>字加&#x2F;减，最高位（D15）产生进位&#x2F;借位时：C标志置1，否则置0</p>
<p>双字节加&#x2F;减，最高位（D31）产生进位&#x2F;借位时：C标志置1，否则置0</p>
<p><strong>A标志—辅助进位&#x2F;辅助借位标志</strong></p>
<p>字节、字、双字加&#x2F;减，D3为产生进位&#x2F;借位时：A标志置1，否则置0</p>
<p> <strong>S标志—符号标志</strong></p>
<p>字节运算后，结果的最高位D7为1：S标志置1，否则置0</p>
<p>字运算后，结果的最高位D15为1：S标志置1，否则置0</p>
<p>双字节运算后，结果的最高位D31为1：S标志置1，否则置0</p>
<p><strong>Z标志—零标志</strong></p>
<p>运算结果为全0时，Z标志置1，否则置0</p>
<p><strong>P标志—奇偶标志（实际上是偶标志）</strong></p>
<p>运算结果的低8位中，若“1”的个数为偶数个，则P标志置1，否则置0</p>
<p><strong>O标志—溢出标志</strong></p>
<p>则加数与被加数的最高位相同，却与结果的最高位相异，则O标志置1，否则置0</p>
<p>由于溢出的操作数的性质有关，而操作数的性质是由程序员定义的。CPU只能默认一种选择，即CPU一律默认操作数是有符号补码数，并以此来设置溢出标志</p>
<p>有符号数运算，判断O标志，O标志为1，有溢出</p>
<p>无符号数加&#x2F;减，判C标志，C标志为1，有溢出</p>
<h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p><strong>操作数寻址方式</strong></p>
<p>操作数是指令的操作对象，寻址方式就是在指令中，使用特定的助记符（地址表达式），告知CPU如何计算出操作数的地址，从而正确地取出操作数进行后继的指令操作</p>
<p>“寻址方式”：通俗的讲，就是通知CPU本条指令的操作数在哪？或者说什么方式才能得到操作数</p>
<p>操作数分类：</p>
<ul>
<li>操作数包含在指令中，这种操作数称为立即数</li>
<li>操作数存放在CPU的某个寄存器中，这种操作数称为寄存器操作数</li>
<li>操作数存放在存储器中，这种操作数称为存储器操作数（内存操作数）</li>
<li>操作数存放在I&#x2F;O端口中，这种操作数称为I&#x2F;O端口操作数</li>
</ul>
<p><strong>立即寻址</strong></p>
<p>立即寻址方式所提供的操作数直接放在指令中，紧跟在操作码的后面，与操作码一起放在代码段区域中，立即数可以是8、16、32位</p>
<p>操作数是指令的一部分，完整地取出该条指令，也就获得了操作数</p>
<p><strong>寄存器寻址</strong></p>
<p>操作数在CPU的某个寄存器中，符号指令中直接写出寄存器名称</p>
<p><strong>存储器寻址</strong></p>
<ul>
<li>在读写内存操作数之前，CPU必须知道相关存储单元的物理地址</li>
<li>由于CPU对存储器采用分段管理，因此指令格式中只能写出存放操作数的内存单元的“逻辑地址”</li>
<li>程序员的责任仅在于正确书写逻辑地址表达式，然后由CPU自动运算以求出物理地址</li>
</ul>
<p><strong>直接寻址：</strong></p>
<ul>
<li>地址表达式格式1：段寄存器:[偏移地址]</li>
<li>地址表达式格式2：段寄存器:变量名</li>
</ul>
<p>格式一很少使用，因为通常情况下，程序员不知道某单元的偏移地址</p>
<p>汇编语言允许为某单元起一个“名字”，这个名字就成为该单元的“变量名”，经汇编之后，变量名有段基址和偏移量两种属性</p>
<p><strong>寄存器间接寻址：</strong></p>
<p>又称为间接寻址，间址。操作数在内存单元，该单元的段基址在段寄存器中，偏移地址在间址寄存器中，CPU首先进行地址计算</p>
<ul>
<li>间接寻址的地址表达式：段寄存器:[间址寄存器]</li>
<li>访问约定的逻辑段，间接寻址的地址表达式简化为：[间址寄存器]</li>
</ul>
<p><strong>基址寻址：</strong></p>
<p>该寻址方式的偏移地址由两部分组成。一部分在基址寄存器中，另一部分为常量</p>
<ul>
<li>基址寻址的地址表达式：段寄存器:[基址寄存器+位移量]</li>
<li>访问约定的逻辑段，简化的地址表达式：[基址寄存器+位移量]</li>
</ul>
<p><strong>变址寻址：</strong></p>
<ul>
<li>有比例因子的变址寻址其地址表达式为：段寄存器:[比例因子*变址寄存器+位移量]</li>
<li>没有比例因子的变址寻址其地址表达式为：段寄存器:[变址寄存器+位移量]</li>
<li>按约定的逻辑段可简化为：[变址寄存器+位移量]</li>
</ul>
<p><strong>基址加变址寻址：</strong></p>
<p>存储单元的偏移地址由三部分组成</p>
<ul>
<li><p>有比例因子的基址加变址的地址表达式为：段寄存器:[基址寄存器+比例因子*变址寄存器+位移量]</p>
<p>访问约定的逻辑段其地址表达式简化为：[基址寄存器+比例因子*变址寄存器+位移量]</p>
</li>
<li><p>无比例因子的基址加变址的地址表达式为：段寄存器:[基址寄存器+变址寄存器+位移量]</p>
<p>访问约定的逻辑段其地址表达式简化为：[基址寄存器+变址寄存器+位移量]</p>
</li>
</ul>
<h3 id="汇编语言语句类型和格式"><a href="#汇编语言语句类型和格式" class="headerlink" title="汇编语言语句类型和格式"></a>汇编语言语句类型和格式</h3><p>汇编语言源程序包括的语句类型为：指令性语句和指示性语句</p>
<p>指令性语句即为通常所说的符号指令</p>
<p>指示性语句包括伪指令和宏指令</p>
<p>伪指令：是非机器指令，是在汇编链接期间进行操作的。为汇编程序，链接程提供汇编链接信息</p>
<table>
<thead>
<tr>
<th align="center">语句类型</th>
<th align="center">符号指令（机器指令）</th>
<th align="center">伪指令</th>
</tr>
</thead>
<tbody><tr>
<td align="center">执行者</td>
<td align="center">CPU</td>
<td align="center">汇编链接工具</td>
</tr>
<tr>
<td align="center">功能</td>
<td align="center">完成某个特定的CPU操作</td>
<td align="center">为汇编链接工具提供信息</td>
</tr>
</tbody></table>
<ul>
<li><p>指令性语句（符号指令）的格式为：</p>
<p>标号：| 操作码助记符 | 空格 | 操作数助记符（多个操作数之间用，隔开）| ；注释</p>
</li>
<li><p>指示性语句（伪指令）的格式为</p>
<p>变量 | 空格 | 伪指令助记符 | 空格 | 操作数项（多个操作数之间用，隔开）| ；注释</p>
</li>
</ul>
<h3 id="常用伪指令"><a href="#常用伪指令" class="headerlink" title="常用伪指令"></a>常用伪指令</h3><p><strong>数据定义伪指令</strong></p>
<ul>
<li><p>字节定义伪指令DB</p>
<p>变量名DB一个或多个用逗号间隔的单字节数</p>
<p>通知汇编程序把DB后跟的单字节数，依次存入变量名开始的单元</p>
</li>
<li><p>字定义伪指令DW</p>
<p>变量名DW一个或多个用逗号间隔的双字节数</p>
<p>通知汇编程序把DW后跟的双字节数，依次存入变量名开始的单元，存放时满足小端法规则</p>
</li>
<li><p>双字定义伪指令DD</p>
<p>变量名DD一串用逗号间隔的四字节数</p>
<p>通知汇编程序把DD后跟的数存入变量名开始的单元，每一个数占4个字节，存放满足小端法</p>
</li>
<li><p>多字节定义伪指令DF&#x2F;DQ&#x2F;DT</p>
<p>变量名DF一串用逗号间隔的六字节数</p>
<p>变量名DQ一串用逗号间隔的八字节数</p>
<p>变量名DT一串用逗号间隔的十字节数</p>
</li>
</ul>
<p><strong>符号定义伪指令</strong></p>
<ul>
<li><p>等值伪指令EQU</p>
<p>符号常数EQU表达式</p>
</li>
<li><p>等号伪指令&#x3D;</p>
<p>符号常数&#x3D;表达式</p>
</li>
</ul>
<p>EQU定义的符号常数在后继语句中不能修改，用&#x3D;定义的符号常数在后继语句中可以修改</p>
<h3 id="常用的运算符"><a href="#常用的运算符" class="headerlink" title="常用的运算符"></a>常用的运算符</h3><p><strong>$运算符</strong></p>
<p>汇编程序对源程序进行逐行汇编的，$运算符可以返回汇编地址计数器的当前值</p>
<p>$运算符紧跟在DB、DW、DD伪指令之后，统计字符串的长度</p>
<p><strong>SEG运算符</strong></p>
<p>格式：SEG 段名或变量名或标号名</p>
<p>计算某一逻辑段的段基址</p>
<p><strong>OFFSET运算符</strong></p>
<p>格式：OFFSET 变量名或标号名</p>
<p>运算逻辑段中某个变量或标号名所在单元相对于段首的偏移地址</p>
<p><strong>PTR运算符</strong></p>
<p>格式：类型说明符 PTR 地址表达式（内存单元5种寻址方式或子程序名称）</p>
<p>使用规则：</p>
<ul>
<li>指令的操作数至少有一个类型属性要确定，否则必须用PTR运算符说明其中的内存操作数的类型</li>
<li>若两个操作数的类型属性都确定，则必须保持一致。否则必须用PTR运算符改变其中的额内存操作数的类型，以保持前后属性一致</li>
</ul>
<p>类型属性确定的操作数：寄存器、用变量名直接寻址的内存操作数</p>
<p>类型属性不确定的操作数：立即数、非变量名直接寻址的内存操作数</p>
<p>使用方法：</p>
<p>在双操作数指令中（如：MOV、ADD、SUB等）:</p>
<ul>
<li>源操作数为立即数，目标操作数为非变量名立即寻址的内存操作数，则必须用PTR说明内存操作数的属性</li>
<li>源操作数，目标操作数中有一方为立即寻址的内存操作数，但二者类型属性不一致，必须用PTR临时修改其中的内存操作数的属性，使得源目操作数类型属性一致</li>
</ul>
<p>在单操作数指令中（如：INC、DEC等）：</p>
<ul>
<li>操作数为非变量名直接寻址的内存操作数，必须用PTR说明其属性</li>
</ul>
<h3 id="基本指令集"><a href="#基本指令集" class="headerlink" title="基本指令集"></a>基本指令集</h3><p>80x86指令集分类：传送类指令、算数运算类指令、转移和调用类指令、逻辑运算类指令、串操作类指令、处理控制机类指令</p>
<p>总说明：</p>
<ul>
<li>对于双操作数指令（如：MOV、ADD、CMP等）<ul>
<li>源、目操作数不可同为内存操作数</li>
<li>源、目操作数属性一致（长度相同）</li>
<li>当源操作数为立即数，目标操作数为非变量名直接寻址的内存操作数，则目标操作数必须用PTR说明类型</li>
</ul>
</li>
<li>对于单操作数指令（如：INC、DEC等）<ul>
<li>若操作数为非变量名直接寻址的内存操作数，则必须用PTR说明类型</li>
</ul>
</li>
<li>汇编语言指令集分6类，为方便使用<ul>
<li>N代表立即数</li>
<li>R代表寄存器操作数</li>
<li>M代表内存操作数</li>
<li>S代表段寄存器</li>
</ul>
</li>
</ul>
<p><strong>通用传送类指令</strong></p>
<p>传送类指令执行后，不影响状态标志，主要包括通用传送类指令和堆栈操作指令</p>
<p>通用传送类指令：</p>
<ul>
<li><p>数据传送指令：MOV</p>
<p>功能：源-&gt;目，源不变</p>
<p>说明：不能向段寄存器写入立即数；CS不能做目标寄存器</p>
</li>
<li><p>符号扩展&#x2F;零扩展传送指令：MOVSX&#x2F;MOVZX</p>
<p>功能：源-&gt;目，源不变</p>
<p>说明：源操作数不变；源操作数字长要小于或等于目标寄存器字长；MOVSX源操作数符号位向高位扩展；MOVZX源操作数高位补零</p>
</li>
<li><p>有效地址传送指令：LEA</p>
<p>功能：计算内存单元的有效地址（不是其中的操作数）-&gt;目标</p>
</li>
<li><p>交换传送指令：XCHG</p>
<p>功能：完成2个操作数互换</p>
<p>说明：段寄存器、立即数不能参加互换；2个内存操作数不能互换，源、目的类型一致</p>
</li>
</ul>
<p><strong>堆栈操作类指令</strong></p>
<p>堆栈—计算机中的堆栈是认为设置的一片连续内存区，用来存放数据，所存数据按先进后出规律存取</p>
<p>栈顶：栈区的低地址</p>
<p>栈底：栈区的高地址</p>
<ul>
<li>堆栈段寄存器SS：存放堆栈段段基址</li>
<li>堆栈指针ESP（SP）：存放栈顶单元的偏移地址</li>
<li>SS、ESP（SP）初值，由程序员赋值或DOS系统自动赋值</li>
</ul>
<p>堆栈指针SP的初值决定了堆栈的大小，SP始终指向堆栈的顶部，即始终指向最后压入堆栈的信息所在单元</p>
<p>进栈指令：PUSH 源操作数</p>
<p>出栈指令：POP 目标操作数</p>
<p>说明：非直接寻址的内存操作数，必须用PTR说明属性</p>
<ul>
<li><p>16位寄存器通用指令：PUSHA</p>
<p>功能：依次把AX、CX、DX、BX、SP、BP、SI、DI压栈</p>
</li>
<li><p>16位寄存器进栈&#x2F;出栈指令：POPA</p>
<p>功能：从栈顶弹出2*8字节此依次存放入DI、SI、BP、SP、BX、DX、CX、AX</p>
</li>
<li><p>16位标志寄存器入栈指令：PUSHF</p>
<p>功能：将16位标志寄存器Flag的内容压入堆栈保存</p>
</li>
<li><p>16位标志寄存器出栈指令：POPF</p>
<p>功能：把栈中内容弹出至16位标志寄存器Flag</p>
</li>
<li><p>32位标志寄存器入栈指令：PUSHFD</p>
<p>功能：将32位标志寄存器EFlag的内容压入堆栈保存</p>
</li>
<li><p>32位标志寄存器出栈指令：POPFD</p>
<p>功能：把栈中内容弹出至32位标志寄存器EFlag</p>
</li>
</ul>
<p><strong>运算类指令</strong></p>
<table>
<thead>
<tr>
<th align="center">分类</th>
<th align="left">名称</th>
<th>格式</th>
<th>功能</th>
<th align="center">O S Z A P C</th>
</tr>
</thead>
<tbody><tr>
<td align="center">加法指令</td>
<td align="left">加法指令</td>
<td>ADD DST,SRC</td>
<td>加法（字、字节）</td>
<td align="center">O S Z A P C</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">带进位加法指令</td>
<td>ADC DST,SRC</td>
<td>带进位加法（字、字节）</td>
<td align="center">O S Z A P C</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">加1指令</td>
<td>INC OPRD</td>
<td>加1（字、字节）</td>
<td align="center">O S Z A P</td>
</tr>
<tr>
<td align="center">减法指令</td>
<td align="left">减法指令</td>
<td>SUB DST,SRC</td>
<td>减法（字、字节）</td>
<td align="center">O S Z A P C</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">带错位减法指令</td>
<td>SBB DST,SRC</td>
<td>带错位减法（字、字节）</td>
<td align="center">O S Z A P C</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">减1指令</td>
<td>DEC OPRD</td>
<td>减1（字、字节）</td>
<td align="center">O S Z A P</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">比较指令</td>
<td>CMP DST,SRC</td>
<td>比较（字、字节）</td>
<td align="center">O S Z A P C</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">求补指令</td>
<td>NEG OPRD</td>
<td>求补码</td>
<td align="center">O S Z A P C</td>
</tr>
<tr>
<td align="center">乘法指令</td>
<td align="left">无符号乘法</td>
<td>MUL SRC</td>
<td>不带符号数乘法（字、字节）</td>
<td align="center">O C</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">带符号乘法</td>
<td>IMUL SRC</td>
<td>带符号数乘法（字、字节）</td>
<td align="center">O C</td>
</tr>
<tr>
<td align="center">除法指令</td>
<td align="left">无符号除法</td>
<td>DIV SRC</td>
<td>不带符号数除法（字、字节）</td>
<td align="center">没有定义</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">带符号除法</td>
<td>IDIV SRC</td>
<td>带符号数除法（字、字节）</td>
<td align="center">没有定义</td>
</tr>
</tbody></table>
<ul>
<li><p>二进制加法：ADD 目标操作数，源操作数</p>
<p>功能：ADD：源+目-&gt;目</p>
</li>
<li><p>二进制减法：SUB 目标操作数，源操作数</p>
<p>功能：SUB：源-目-&gt;目</p>
</li>
<li><p>二进制加进位：ADC 目标操作数，源操作数</p>
<p>功能：ADC：源+目+上一条指令执行后C标-&gt;目</p>
</li>
<li><p>二进制减进位：SBB 目标操作数，源操作数</p>
<p>功能：SBB：源-目-上一条指令执行后C标-&gt;目</p>
<p>注：此四种操作都影响A、C、O、P、S、Z</p>
<p>说明：源、目操作数的属性（长度）要一致</p>
</li>
<li><p>二进制加1：INC 目标操作数</p>
<p>影响A、O、P、S、Z</p>
</li>
<li><p>二进制减1：DEC 目标操作数</p>
<p>不影响C标</p>
<p>对于非直接寻址的内存操作数，要用PTR明确说明属性</p>
</li>
<li><p>二进制求补：NEG 目标操作数</p>
<p>功能：0-目-&gt;目</p>
<p>影响A、C、O、P、S、Z</p>
<p>应用：求出目标操作数的负值</p>
</li>
<li><p>比较指令：CMP 目标操作数，源操作数</p>
<p>功能：源-目，产生A、C、O、P、S、Z6个状态标志，不破坏源、目。该指令一般后跟条件转移指令</p>
</li>
<li><p>无符号二进制乘法：MUL 乘数</p>
</li>
<li><p>有符号二进制乘法：IMUL 乘数</p>
<table>
<thead>
<tr>
<th align="center">MUL&#x2F;IMUL</th>
<th align="center">被乘数默认在</th>
<th align="center">乘数为</th>
<th align="center">高位积在</th>
<th align="center">低位积在</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节相乘</td>
<td align="center">AL</td>
<td align="center">R8&#x2F;M8</td>
<td align="center">AH</td>
<td align="center">AL</td>
</tr>
<tr>
<td align="center">字相乘</td>
<td align="center">AX</td>
<td align="center">R16&#x2F;M16</td>
<td align="center">DX</td>
<td align="center">AX</td>
</tr>
<tr>
<td align="center">双字相乘</td>
<td align="center">EAX</td>
<td align="center">R32&#x2F;M32</td>
<td align="center">EDX</td>
<td align="center">EAX</td>
</tr>
</tbody></table>
<p>MUL默认乘数、被乘数、乘积为无符号二进制数</p>
<p>IMUL默认乘数、被乘数、乘积为有符号二进制数</p>
<p>高位积为0，则C标、O标&#x3D;0，否则为1</p>
<p>乘数、被乘数等长，乘积为双倍长</p>
<p>其他格式的有符号乘法：IMUL 目，源；IMUL 目，源，立即数</p>
</li>
<li><p>无符号二进制除法：DIV 除数</p>
</li>
<li><p>有符号二进制除法：IDIV 除数</p>
<table>
<thead>
<tr>
<th align="center">DIV&#x2F;IDIV</th>
<th align="center">除数由指令格式指定</th>
<th align="center">被除数默认在</th>
<th align="center">商值在</th>
<th align="center">余数在</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节除法</td>
<td align="center">R8&#x2F;M8</td>
<td align="center">AX</td>
<td align="center">AL</td>
<td align="center">AH</td>
</tr>
<tr>
<td align="center">字除法</td>
<td align="center">R16&#x2F;M16</td>
<td align="center">DX&#x3D;高16位；AX&#x3D;低16位</td>
<td align="center">AX</td>
<td align="center">DX</td>
</tr>
<tr>
<td align="center">双字除法</td>
<td align="center">R32&#x2F;M32</td>
<td align="center">EDX&#x3D;高32位；EAX&#x3D;低32位</td>
<td align="center">EAX</td>
<td align="center">EDX</td>
</tr>
</tbody></table>
<p>DIV默认的除数、被除数、商、余数均为无符号数</p>
<p>IDIV默认的除数、被除数、商、余数均为有符号数</p>
<p>被除数应为除数的双倍长</p>
<p>如果除数太小，使商值超出范围，屏幕显示：Divided overflow然后自动返回DOS</p>
</li>
</ul>
<p><strong>BCD码调整指令</strong></p>
<p>组合&#x2F;未组合BCD码数（即压缩&#x2F;未压缩BCD码数）</p>
<p>组合BCD码：一字节中含有两位BCD码</p>
<p>未组合BCD码：一字节中含有一位BCD码（高4位为0）</p>
<ul>
<li><p>BCD码数的加减运算</p>
<p>BCD码数用4位二进制数代表1位十进制数，运算法则应是：逢十进一，借一当十</p>
</li>
<li><p>如果实现BCD码的四则运算</p>
<p>指令系统中没有实现BCD码数运算的指令，只能借用二进制运算指令，再根据运算结果进行十进制调整（06H、60H、66H）</p>
</li>
<li><p>BCD码调整指令：</p>
<ul>
<li><p>加法DAA（组合）</p>
<p>功能：默认操作对象为AL，并且根据具体情况对AL中的高&#x2F;低4位进行修正</p>
<p>应用：紧跟在以AL为目标寄存器的ADD&#x2F;ADC之后，但AL中必须是组合BCD码数之和</p>
</li>
<li><p>AAA（未组合）</p>
</li>
<li><p>减法DAS（组合）</p>
<p>功能：默认操作对象为AL，对AL中的组合BCD差值进行修正</p>
<p>若被减数≥减数，调整后，C标&#x3D;0，AL&#x3D;组合BCD码差值</p>
<p>若被减数＜减数，调整后，C标&#x3D;1，AL&#x3D;差值相对于模（100）10的“补数”                                                                                                </p>
</li>
<li><p>AAS（未组合）</p>
</li>
<li><p>乘法AAM（未组合）</p>
</li>
<li><p>除法AAD（未组合）</p>
</li>
</ul>
</li>
</ul>
<p><strong>转移类指令</strong></p>
<p>按照转移条件分：无条件转移和有条件转移</p>
<p>按照转移范围分：段内转移和段间转移</p>
<p>按照获取转移地址的方法分：直接转移和间接转移</p>
<ul>
<li><p>无条件转移</p>
<p>功能：无条件转移，执行指定标号处的指令</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th>直接</th>
<th>间接</th>
</tr>
</thead>
<tbody><tr>
<td align="center">段内</td>
<td>JMP标号，JMP SHORT标号</td>
<td>JMP寄存器操作数，JMP内存操作数</td>
</tr>
<tr>
<td align="center">段间</td>
<td>JMP标号</td>
<td>JMP内存操作数</td>
</tr>
</tbody></table>
<p>标号数转移地址标号</p>
<p>SHORT是端转移，其转移分为相对于指令地址而言在+129~-126个单元之间</p>
</li>
<li><p>有条件转移</p>
<p>一般格式：操作码助记符 转移地址标号</p>
<p>应用：CMP 目，源</p>
<p>转移范围：转移到代码段任何位置</p>
<p>说明：操作码助记符隐含了转移条件</p>
</li>
</ul>
<p><strong>调用类指令</strong></p>
<p>CALL&lt;调用地址&gt;</p>
<p>RET</p>
<p>子程序：能完成一定功能的相对独立的程序段</p>
<p>汇编语言的过程定义语句</p>
<p>格式：过程名 PROC 属性</p>
<p>​			过程名 ENDP</p>
<ul>
<li><p>过程名：子程序名，以字母开头，长度≤31。经汇编之后，过程名就是子程序第一条指令</p>
</li>
<li><p>PROC&#x2F;ENDP是子程序的定界语句</p>
</li>
<li><p>属性有两种描述</p>
<p>NEAR（或缺省）代表近过程，即该子程序和调用它的哪条指令在同一代码段</p>
<p>FAR代表原过程，即该子程序和调用它的哪条指令不在同一代码段</p>
</li>
<li><p>RET子程序返回指令</p>
</li>
</ul>
<p>段内调用CALL指令</p>
<ul>
<li><p>段内直接调用 CALL 过程名</p>
</li>
<li><p>段内间接调用 CALL 寄存器操作数</p>
<p>​						CALL 内存操作数</p>
<p>功能：断点偏移地址-&gt;堆栈</p>
<p>子程序入口的偏移地址-&gt;IP从而转子程序</p>
</li>
</ul>
<p>段内&#x2F;段间返回RET指令</p>
<p>有NEAR属性的RET指令，从栈顶弹出2字节-&gt;IP</p>
<p>有FAR属性的RET指令，从栈顶弹出4字节-&gt;IP,CS</p>
<p>如果栈顶是断口地址，则能返回断点，否则不能</p>
<p>RET N 指令，首先完成RET功能，然后把堆栈指针再下调N个字节</p>
<p><strong>逻辑运算类指令</strong></p>
<ul>
<li><p>取反 NOT 目</p>
<p>功能：实现操作数的按位取反</p>
</li>
<li><p>与 AND 目，源</p>
<p>功能：实现两个操作数的按位与运算</p>
</li>
<li><p>或 OR 目，源</p>
<p>功能：实现两个操作数的按位或运算</p>
</li>
<li><p>异或 XOR 目，源</p>
<p>功能：实现两个操作数的按位异或运算</p>
</li>
<li><p>测试 TEST 目，源</p>
<p>功能：实现连个操作数的按位与运算，结果不保存，只影响标志位</p>
</li>
</ul>
<p>目标操作数：R&#x2F;M，源操作数：与目标操作数等长的R&#x2F;M&#x2F;N</p>
<table>
<thead>
<tr>
<th align="center">分类</th>
<th align="center">名称</th>
<th align="center">格式</th>
<th align="center">功能</th>
<th align="center">O S Z A P C</th>
</tr>
</thead>
<tbody><tr>
<td align="center">逻辑运算指令</td>
<td align="center">逻辑与指令</td>
<td align="center">AND DST,SRC</td>
<td align="center">与（字、字节）</td>
<td align="center">O S Z A P C</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">逻辑或指令</td>
<td align="center">OR DST,SRC</td>
<td align="center">或（字、字节）</td>
<td align="center">O S Z P C</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">逻辑非指令</td>
<td align="center">NOT OPRD</td>
<td align="center">非（字、字节）</td>
<td align="center">不影响</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">逻辑异或指令</td>
<td align="center">XOR DST,SRC</td>
<td align="center">异或（字、字节）</td>
<td align="center">O S Z P C</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">测试指令</td>
<td align="center">TEST DST,SRC</td>
<td align="center">测试（字、字节）</td>
<td align="center">O S Z P C</td>
</tr>
</tbody></table>
<p><strong>移位类指令</strong></p>
<p>开环移位指令</p>
<ul>
<li>算数左移：SAL 操作数，移位次数</li>
<li>算数右移：SAR 操作数，移位次数</li>
<li>逻辑左移：SHL 操作数，移位次数</li>
<li>逻辑右移：SHR 操作数，移位次数</li>
</ul>
<p>移位指令作用：移位指令通常用来做乘2或除2的操作。左移乘2，右移除2</p>
<p>算数移位用于带符号数运算</p>
<p>逻辑移位用于无符号数运算</p>
<p>闭环移位指令</p>
<ul>
<li>含进位的循环左移：RCL 操作数，移位次数</li>
<li>含进位的循环右移：RCR 操作数，移位次数</li>
<li>不含进位的循环左移：ROL 操作数，移位次数</li>
<li>不含进位的循环右移：ROR 操作数，移位次数</li>
</ul>
<p>以上指令的操作数为R&#x2F;M，移位次数可以是立即数或CL</p>
<p><strong>串操作类指令</strong></p>
<p>串定义为：由若干相同类型的元素构成的序列。在汇编语言中常用的元素类型有三种：字节、字和双字</p>
<p>如果处理元素类型设定为字节，称为字节串</p>
<p>如果处理元素类型设定为字，称为字串</p>
<p>如果处理元素类型设定为双字，称为双字串</p>
<p>80x86有6条串操作指令，它们分别是串传送、串比较、串搜索、串装入、串存储和I&#x2F;O串操作</p>
<p>源串和目标串的存储及寻址方式都有隐含规定，即：源串要放在数据段，目标串要放在ES附加段</p>
<p>在16位寻址操作下，CPU自动用SI间址访问数据段，用DI间址访问ES附加段、用CX作为串计数器</p>
<ul>
<li><p>串传送指令</p>
<p>格式：字节串传送 MOVSB</p>
<p>​			字串传送 MOVSW</p>
<p>​			双字串传送 MOVSD</p>
<p>功能：把DS:[SI]的一个元素-&gt;ES:[DI]的若干单元</p>
<p>说明：</p>
<ul>
<li><p>关于“元素”的概念</p>
<p>在字节串传送指令中，一个元素就是1个字节</p>
<p>在字串传送指令中，一个元素就是2个字节</p>
<p>在双字串传送指令中，一个元素就是4个字节</p>
</li>
<li><p>指令执行前的准备工作</p>
<p>源串的首地址&#x2F;末地址-&gt;DS:SI；目串的首地址&#x2F;末地址-&gt;DS:DI</p>
<p>D标志置0&#x2F;置1</p>
</li>
<li><p>该指令传送一个元素后，CPU自动修改SI，DI</p>
<p>当D标志为0时，SI、DI增量修改</p>
<p>当D标志为1时，SI、DI减量修改</p>
</li>
</ul>
</li>
<li><p>串装入指令</p>
<p>LODSB；DS[SI]的1个字节-&gt;AL，自动修改SI</p>
<p>LODSW；DS[SI]的2个字节-&gt;AX，自动修改SI</p>
<p>LODSD；DS[SI]的4个字节-&gt;EAX，自动修改SI</p>
<p>准备工作：串首址&#x2F;末址-&gt;DS:SI,0&#x2F;1-&gt;D标</p>
</li>
<li><p>串存储指令</p>
<p>STDSB；AL-&gt;ES:[DI]的1个单元，自动修改DI</p>
<p>STDSW；AX-&gt;ES:[DI]的2个单元，自动修改DI</p>
<p>STDSD；EAX-&gt;ES:[DI]的4个单元，自动修改DI</p>
<p>准备工作：目标去首址&#x2F;末址-&gt;ES:DI,0&#x2F;1-&gt;D标</p>
<p>有重复前缀时：在基本指令前加RET</p>
<p>准备工作：同基本型；欲存储的元素个数-&gt;CX</p>
</li>
<li><p>串比较指令</p>
<p>字节串比较 CMPSB</p>
<p>字串比较 CMPSW</p>
<p>双字串比较 CMPSD</p>
<p>准备工作：源串首址&#x2F;末址-&gt;DS:SI</p>
<p>​					目串首址&#x2F;末址-&gt;ES:DI,0&#x2F;1-&gt;D标</p>
<p>有重复前缀时：在基本指令前加REPE或REPNE</p>
<p>准备工作：同基本型；串元素的个数-&gt;CX</p>
</li>
<li><p>串搜索指令</p>
<p>在ES:[DI]的目标区，搜索是否有规定的“关键字”</p>
<p>字节串搜索 SCASB</p>
<p>字串搜索 SCASW</p>
<p>双字串搜索 SCASD</p>
<p>准备工作：目标区首址&#x2F;末址-&gt;ES:DI,0&#x2F;1-&gt;D标</p>
<p>​					关键字-&gt;AL&#x2F;AX&#x2F;EAX</p>
<p>功能：比较AL&#x2F;AX&#x2F;EAX&#x3D;ES:[DI]</p>
<p>​			若ES:[DI]&#x3D;关键字，则Z置1，否则Z置0，修改DI</p>
<p>有重复前缀时：在基本指令前加REPE或REPNE</p>
<p>准备工作：同基本型；串元素的个数-&gt;CX</p>
</li>
</ul>
<hr>
<h2 id="汇编语言程序设计"><a href="#汇编语言程序设计" class="headerlink" title="汇编语言程序设计"></a>汇编语言程序设计</h2><p>汇编语言程序的结构：方式选择伪指令、段定义语句、段约定语句、汇编结束语句</p>
<p>汇编源程序的编程格式：EXE文件的编程格式、COM文件的编程格式、汇编语言程序的开发过程</p>
<p>系统功能调用：DOS功能调用（INT 21H）、BIOS功能调用（INT 16H键盘功能调用、INT 10H文本显示功能调用）</p>
<p>汇编语言程序的设计防范方法：程序设计方法（顺序程序设计、分支程序设计、循环程序设计、子程序设计、宏指令程序设计）、程序设计举例（代码转换、数据处理）</p>
<h3 id="汇编语言程序结构"><a href="#汇编语言程序结构" class="headerlink" title="汇编语言程序结构"></a>汇编语言程序结构</h3><p><strong>完整的源程序结构</strong></p>
<p>一个完整的汇编语言源程序在结构上必须做到：</p>
<ul>
<li>用方式选择伪指令说明执行该程序的微处理器类型</li>
<li>用段定义语句定义每一个逻辑段</li>
<li>用ASSUME语句说明段约定</li>
<li>用汇编结束语句说明源程序结束</li>
</ul>
<p>注意：目前汇编语言源程序框架有完整段定义格式和简化段定义格式两种，MASM5.0版本开始支持了简化的段定义语句</p>
<p><strong>方式选择伪指令</strong></p>
<p>功能：通知汇编程序，源程序经过汇编链接后生成哪一种CPU类型的机器指令</p>
<p>应用：源程序第一条指令，指令以句号开头</p>
<p>说明：不设置方式选择伪指令与设置.8086是等价的</p>
<p><strong>段定义语句</strong></p>
<p>格式：段名 SEGMENT 定位参数 链接参数 ‘分类名’ 段长度</p>
<p>​			段体</p>
<p>​			段名 ENDS</p>
<p>功能：是逻辑段的定界语句，源程序中每一个逻辑段都必须用段定义语句定界</p>
<p>段名：命名规则和变量名及标号名一样，它不能代表段体的性质，但为了方便阅读，习惯上总根据段体的性质起一个适当的段名。常用DATA作为数据段的段名，用STACK做为堆栈段的段名，CODE为代码段的段名</p>
<p>段长度：有两种描述方式供选择</p>
<ul>
<li>USE16：表示该逻辑段长度最大允许64K，单元的有效地址为16位，访问该逻辑段采用16位寻址方式</li>
<li>USE32：表示该逻辑段长度可以超过64K，单元的有效地址为32位，访问该逻辑段采用32位寻址方式</li>
</ul>
<p>说明：</p>
<ul>
<li>模块化程序中才有必要考虑各模块之间同名段的定位方式和链接方式。对于单一模块的程序不需要考虑这些问题</li>
<li>单一模块的程序，如果有堆栈段的话，堆栈段的链接属性应为STACK（因为只有STACK属性才表示该段是堆栈段），分类名应为用’STACK’，且不能省略。其他的逻辑段，前三个属性参数都选用缺省方式</li>
<li>DOS环境下运行的程序选用USE16做段长度</li>
</ul>
<p><strong>段约定语句</strong></p>
<p>格式：ASSUME 段寄存器：段名，……，段寄存器：段名</p>
<p>功能：ASSUME语句通知汇编程序，寻址逻辑段使用哪一个段寄存器</p>
<p>说明：ASSUME语句是非执行语句，要求放在代码段之中，执行寻址操作之前。习惯上，把ASSUME语句作为代码段的第一条语句。ASSUME语句，仅仅是约定了对某个逻辑段进行寻址操作时使用哪一个段寄存器，而段寄存器的初值还必须在程序中用指令设置</p>
<p><strong>汇编结束语句</strong></p>
<p>格式1：END 程序的启动地址标号</p>
<p>功能：通知汇编程序，源程序到此结束，用BEGIN作标号的指令是程序的启动指令</p>
<p>注意：在单一模块的源程序中，以及在模块化程序的主模块中必须用此</p>
<p>格式2：END</p>
<p>功能：通知汇编程序，源程序到此结束。在模块化程序的子模块中，必须用此格式作为源程序的最后一条语句</p>
<p><strong>返回DOS语句</strong></p>
<p>程序在完成预定任务之后，必须返回DOS。返回DOS最常用的方法是使用DOS系统4CH功能，即连续执行一下两条指令：MOV AH,4CH</p>
<p>​				INT 21H</p>
<h3 id="汇编源程序的编程格式"><a href="#汇编源程序的编程格式" class="headerlink" title="汇编源程序的编程格式"></a>汇编源程序的编程格式</h3><p><strong>汇编源程序两种编程格式</strong></p>
<ul>
<li>EXE文件的编程格式：只能生成扩展为EXE的可执行文件</li>
<li>COM文件的编程格式：可以生成扩展为COM的可执行文件</li>
</ul>
<p>说明：COM文件的执行级别高于EXE文件，同名的BAT（批处理）文件执行级别最低</p>
<p><strong>EXE文件的编程格式</strong></p>
<p>此格式允许源程序使用多个逻辑段（包括数据段、堆栈段、代码段及其他逻辑段）；在实模式下，每个逻辑段的目标不超过64K；适合编写大型程序</p>
<p><strong>COM文件的编程格式</strong></p>
<ul>
<li><p>源程序只允许使用一个逻辑段，即代码段，不允许设置堆栈段</p>
<p>代码段目标小于64K，适合编写中小型程序</p>
<p>程序使用的数据，可以集中设置在代码段的开始或末尾</p>
</li>
<li><p>需使用定位ORG伪指令将程序的启动指令存放在代码段偏移地址为100H的单元</p>
<p>格式：ORG 表达式</p>
<p>功能：用于通知汇编程序将下一条指令或数据存放在表达式给出的段内起始偏移地址</p>
</li>
</ul>
<p><strong>汇编语言的开发过程</strong></p>
<p>编辑程序—&gt;.ASM文件—&gt;汇编程序—&gt;.OBJ文件—&gt;连接程序—&gt;.EXE文件</p>
<p>MASM汇编语言开发步骤：</p>
<ol>
<li>汇编程序，设保存该源程序文件名为a.asm</li>
<li>汇编源程序a.asm	ml&#x2F;c a.asm</li>
<li>链接目标程序a.obj	link a.obj</li>
<li>运行可执行文件a.exe</li>
</ol>
<p>TASM汇编语言开发步骤：</p>
<ol>
<li>编辑程序，设保存该源程序文件名为a.asm</li>
<li>汇编源程序a.asm	tasm a.asm</li>
<li>链接目标程序a.obj	tlink a.obj</li>
<li>运行可执行文件a.exe</li>
</ol>
<h3 id="DOS-x2F-BIOS功能调用"><a href="#DOS-x2F-BIOS功能调用" class="headerlink" title="DOS&#x2F;BIOS功能调用"></a>DOS&#x2F;BIOS功能调用</h3><p><strong>DOS&#x2F;BIOS调用</strong></p>
<p>DOS的4个组成部分中IBMBIO.COM是DOS系统的核心模块，为基本I&#x2F;O设备处理程序，与BIOS一起完成数据输入和数据输出的基本操作</p>
<p>DOS和BIOS均有若干子功能可以被用户程序调用，称为“DOS调用”和“BIOS调用”</p>
<p><strong>DOS&#x2F;BIOS调用模式</strong></p>
<p>MOV AH，功能号</p>
<p>设置入口参数</p>
<p>INT n</p>
<p>分析出口参数</p>
<p>说明：</p>
<ul>
<li>其中n值因子程序不同而可能不同，比如：ROM BIOS有n&#x3D;5 ~ 1FH，DOS有n&#x3D;20H，21H，23 ~ 2AH，2EH，2FH，33H和67H等几种情况。有的n只对应一个子程序，有的n对应很多子程序</li>
<li>调用结束后一般都有出口参数，这些出口参数常放在寄存器中，通过出口参数可以知道功能调用的成功与否</li>
<li>在DOS功能子程序调用中，我们把通过INT21H来实现的子程序调用称为DOS系统功能调用</li>
</ul>
<p><strong>DOS功能调用模式</strong></p>
<p>MOV AH，功能号</p>
<p>设置入口参数</p>
<p>INT 21H</p>
<p>分析出口参数</p>
<p>功能号种类：01H、02H、07H、08H、09H、0AH</p>
<p><strong>BIOS键盘输入功能调用</strong></p>
<p>主板EPROM中固化有基本I&#x2F;O系统程序—BIOS，它是最接近硬件的驱动程序，BIOS中的许多子程序可被用户程序调用，调用这些子程序称为BIOS功能调用</p>
<p>MOV AH，功能号</p>
<p>设置入口参数</p>
<p>INT 16H</p>
<p>分析出口参数</p>
<p>功能号种类：00H、01H</p>
<p><strong>BIOS文本显示功能调用</strong></p>
<p>MOV AH，功能号</p>
<p>设置入口参数</p>
<p>INT 10H</p>
<p>分析出口参数</p>
<p>功能号种类：00H、0EH、13H</p>
<h3 id="分支程序设计"><a href="#分支程序设计" class="headerlink" title="分支程序设计"></a>分支程序设计</h3><p>汇编语言编程属性结构化程序设计</p>
<p>按照自上而下的设计方法，设计一个汇编程序的步骤：</p>
<ul>
<li>分析题意，确定算法</li>
<li>根据算法画出程序框架图</li>
<li>根据框架图编写程序</li>
<li>上机调试程序</li>
<li>执行程序</li>
</ul>
<p>从结构上来讲，一般的汇编程序可分为：顺序程序、分支程序、循环程序、子程序、宏程序</p>
<p>转移指令可用来实现分支程序设计，分支程序分三种：简单分支、复合分支、多分支</p>
<h3 id="循环程序设计"><a href="#循环程序设计" class="headerlink" title="循环程序设计"></a>循环程序设计</h3><p><strong>循环程序的组成</strong></p>
<ul>
<li>循环初始化部分：是进入循环操作之前的准备工作，如循环计数器的设置；缓冲区偏移地址的设置。通常使用寄存器或内存单元做循环计数器</li>
<li>循环体：重复执行的程序代码，是循环程序的核心部分，完成具体的、重复执行的工作以及为进入下次循环而进行的挑中工作，如对循环次数的修改，缓冲区偏移地址的修改</li>
<li>循环控制部分：判断循环条件是否成立，如果为未满足，则继续循环，否则退出循环</li>
</ul>
<h3 id="子程序设计"><a href="#子程序设计" class="headerlink" title="子程序设计"></a>子程序设计</h3><p>子程序是常用的程序设计方法。当程序中要多次完成某一操作时，为了简化整体程序，增强程序可读性，常常把“完成某一操作”的程序片断设计成一个子程序，供主程序调用</p>
<p><strong>子程序参数传递的方式</strong></p>
<p>主程序向子程序传送参数主要有三种方式：</p>
<ul>
<li>利用寄存器传送参数</li>
<li>利用堆栈传送参数</li>
<li>利用某个内存单元传送参数</li>
</ul>
<h3 id="宏指令程序设计"><a href="#宏指令程序设计" class="headerlink" title="宏指令程序设计"></a>宏指令程序设计</h3><p>子程序调用可以简化程序，但是如果子程序的参数太多，调用时太麻烦，汇编语言提供了另一种简化的途径—宏指令</p>
<ul>
<li>宏指令是汇编语言提供的伪指令。是用户自行定义的若干指令的集合</li>
<li>宏指令的定义可以不在任何逻辑段之中，习惯上放在源程序首部</li>
<li>宏指令应该先定义后调用</li>
</ul>
<p><strong>无参数宏指令定义语句</strong></p>
<p>宏指令名 MACRO</p>
<p>宏体</p>
<p>ENDM</p>
<p>说明：宏体经过定义之后，宏指令的名称就是一条宏指令，在代码段中放置一条宏指令就是宏调用。编译时汇编程序用宏体替换宏指令</p>
<p><strong>有参数宏指令定义语句</strong></p>
<p>宏指令 MACRO 哑元表</p>
<p>宏体</p>
<p>ENDM</p>
<p>调用：宏指令名 实元表</p>
<ul>
<li>实元表是一串用逗号（或空格）间隔的立即数，寄存器操作数或者是没有PTR说明符的存储器操作数</li>
<li>汇编时，汇编程序自动地把实元一一对应的赋给哑元</li>
</ul>
<p><strong>LOCAL伪指令</strong></p>
<p>格式：LOCAL 用逗号间隔的标号名</p>
<p>说明：</p>
<ul>
<li>LOCAL伪指令要放在宏定义之中，是MACRO定界语句以下的第一条语句</li>
<li>宏体中出现的标号称为局部标号，使用LOCAL伪指令后的局部标号允许和源程序中的其他标号、变量重名</li>
</ul>
<p><strong>子程序与宏指令的比较</strong></p>
<p>共同点：</p>
<ul>
<li>宏指令与子程序都可以简化程序设计，增强程序的可读性</li>
</ul>
<p>不同点：</p>
<ul>
<li>子程序调用是由CPU完成的，宏指令调用是在汇编过程中由汇编程序完成的</li>
</ul>
<hr>
<h2 id="输入-x2F-输出系统"><a href="#输入-x2F-输出系统" class="headerlink" title="输入&#x2F;输出系统"></a>输入&#x2F;输出系统</h2><p>总线概述：32位微处理器的外部引脚，总线和总线标准</p>
<p>输入&#x2F;输出系统概述：硬件概念（接口电路、端口、端口地址）、软件操作（I&#x2F;O指令）</p>
<p>微机系统与外设交换信息的方式：无条件传送、查询方式、中断方式、DMA方式</p>
<h3 id="总线概述"><a href="#总线概述" class="headerlink" title="总线概述"></a>总线概述</h3><p><strong>32位微处理器的外部引脚</strong></p>
<ul>
<li><p>数据线及控制信号</p>
<ul>
<li>D63 ~ D0：共64位</li>
<li>BE7 ~ BE0：字节允许信号（存储体选中信号）</li>
<li>DP7 ~ DP0：奇偶校验信号</li>
<li>PCHK：读校验出错</li>
<li>PEN：奇偶校验允许信号</li>
</ul>
</li>
<li><p>地址线及控制信号</p>
<ul>
<li><p>A31 ~ A3：高29位地址线</p>
</li>
<li><p>外围电路对BE7 ~ BE0译码以产生A2 ~ A0信号</p>
<p>32位微处理器的物理寻址空间有4GB</p>
</li>
<li><p>ADS：地址状态输出信号</p>
</li>
</ul>
</li>
<li><p>总线周期控制信号</p>
<p>CPU通过总线与存储器、I&#x2F;O交换一个数据所需要的时间称为总线周期</p>
<p>M&#x2F;IO：&#x3D;1，CPU与存储器交换信息</p>
<p>​			 &#x3D;0，CPU与I&#x2F;O接口交换信息</p>
<p>W&#x2F;R：&#x3D;1，CPU进行写操作</p>
<p>​		   &#x3D;0，CPU进行读操作</p>
<p>D&#x2F;C：&#x3D;1，传输的是数据</p>
<p>​		  &#x3D;0，传输的是指令代码</p>
</li>
<li><p>系统控制信号</p>
<p>CLK：系统时钟信号</p>
<p>INTP：可屏蔽中断请求信号</p>
<p>NMI：非屏蔽中断请求信号</p>
</li>
<li><p>总线仲裁信号</p>
<p>HOLD：总线请求信号（输入）</p>
<p>HLDA：总线请求相应信号（输出）</p>
</li>
</ul>
<p><strong>总线与总线标准</strong></p>
<ul>
<li><p>总线的类型</p>
<p>按总线的连接对象和所处系统的层次分：芯片级总线、系统总线、局部总线、外部总线</p>
</li>
<li><p>典型总线标准</p>
<p>PC系列机主板上的总线标准有：AT（ISA）总线、EISA总线、VESA总线、PCI总线</p>
<ul>
<li>AT（ISA）总线：是IBM的标准兼容总线</li>
<li>PCI总线：是Inte公司为奔腾微处理器的开发使用而设计的局部总线</li>
</ul>
</li>
<li><p>通用外部总线标准：并行I&#x2F;O标准接口IDE（ATA）、SATA、通用串行总线USB</p>
</li>
<li><p>32位微型计算机总线结构：CPU总线、系统总线、局部总线</p>
</li>
</ul>
<h3 id="输入-x2F-输出系统概述"><a href="#输入-x2F-输出系统概述" class="headerlink" title="输入&#x2F;输出系统概述"></a>输入&#x2F;输出系统概述</h3><p><strong>输入&#x2F;输出接口的概念</strong></p>
<ul>
<li><p>接口电路的作用</p>
<p>CPU&lt;—输入接口电路&lt;—输入设备数据</p>
<p>CPU数据—&gt;输出接口电路—&gt;输出设备</p>
<p>接口：是CPU与外部设备交换信息的中转站</p>
</li>
<li><p>接口电路的功能</p>
<ul>
<li>应具有数据暂存功能</li>
<li>应有端口地址译码器（便于使用IN，OUT指令读写数据）</li>
<li>与外设之间有联络功能</li>
<li>有中断管理能力</li>
<li>有数据转换功能（并-&gt;串，串-&gt;并）</li>
</ul>
</li>
</ul>
<p><strong>端口的概念和编址方式</strong></p>
<ul>
<li><p>“端口”是接口电路中，能与CPU交换信息（使用IN，OUT）的寄存器</p>
</li>
<li><p>端口的分类：</p>
<ul>
<li>数据口：存放CPU向外设输出或外设输入的数据</li>
<li>控制口：存放控制信息—控制接口电路、外设的工作</li>
<li>状态口：存放状态信息—反映外设的状态</li>
</ul>
<p>接口电路必须具有数据口</p>
<p>每个端口系统都为它编了一个地址，系统只要给出某个地址，通过译码电路，就能找到相应的I&#x2F;O接口电路中的端口寄存器</p>
</li>
<li><p>端口的编址方式</p>
<ul>
<li>存储器映像方式：把端口和存储器单元等同看待，统一编址</li>
<li>I&#x2F;O端口独立编址：I&#x2F;O端口和存储器分别使用两个地址空间，单独编址</li>
</ul>
</li>
<li><p>PC系列机的端口编址：PC系列机采用端口独立编址，寻址能力65536个</p>
</li>
</ul>
<p><strong>常用的I&#x2F;O指令</strong></p>
<ul>
<li>直接寻址的I&#x2F;O指令</li>
<li>DX间址的I&#x2F;O指令</li>
</ul>
<h3 id="微机系统与外设交换信息的方式"><a href="#微机系统与外设交换信息的方式" class="headerlink" title="微机系统与外设交换信息的方式"></a>微机系统与外设交换信息的方式</h3><p>微机系统与I&#x2F;O设备的信息交换有四种方式：无条件传送方式、查询方式、中断控制方式、DMA方式</p>
<p><strong>无条件传送方式</strong></p>
<p>输入接口：执行IN指令之前，要求外设数据已经准备好</p>
<p>输出接口：执行OUT指令之前，须保证输出设备空闲</p>
<p><strong>查询方式</strong></p>
<p>用查询方式交换信息，必须先了解外设的状态</p>
<p><strong>中断控制方式</strong></p>
<ul>
<li>在有多个外设的系统中，多个外设要求CPU为它服务是随机的</li>
<li>若采用查询方式工作，就补能保证系统实时地对外设的请求作出响应</li>
<li>为了提高CPU的效率，是系统有实时性能，导致了中断处理技术的产生</li>
</ul>
<p>特点：</p>
<ul>
<li>在外设没有做好数据传送准备时，CPU可执行与传送数据无关的其他指令</li>
<li>当外设做好传送准备后，主动向CPU请求中断</li>
<li>若CPU相应这一请求，则暂停正在运行的程序，转入中断服务程序，完成数据传送</li>
<li>待服务完毕后，自动返回原来运行的程序</li>
</ul>
<p><strong>直接存储器存取（DMA）方式</strong></p>
<p>DMA是直接存储器存取，习惯上称DMA传送</p>
<p>DMA传送：利用硬件完成高速外设与系统RAM之间的信息交换</p>
<p>DMAC是DMA控制器，它是实现DMA传送的核心芯片</p>
<ul>
<li>DMA读传送：在DMAC控制下，读取RAM的内容传送至I&#x2F;O</li>
<li>DMA写传送：I&#x2F;O端口信息传送至系统RAM某单元</li>
</ul>
<p>DMA传送与中断方式的比较：</p>
<ul>
<li>响应时间：CPU接到“中断请求”后要等到当前指令执行完毕才响应，而CPU接到DMAC的“总线请求”后只要当前指令的当前总线周期执行完毕就响应</li>
<li>数据传送速度：DMAC传送速度要比中断传送块</li>
</ul>
<p>中断传送是由软件完成的，执行一次中断服务程序就完成一字节I&#x2F;O传送</p>
<p>DMA传送是由硬件完成的，每传送一字节只占用CPU的一个总线周期</p>
<p>DMA请求的方式分为两种：硬件DMA请求和软件DMA请求</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">无条件传送方式</td>
<td>可以直接使用输入缓冲器或锁存器与数据线相连，程序设计简单</td>
<td>传送不能太频繁（保证传送设备都处在就绪状态）</td>
</tr>
<tr>
<td align="center">查询方式</td>
<td>比无条件传送方式可靠</td>
<td>降低了CPU的工作效率，不具有实时性</td>
</tr>
<tr>
<td align="center">中断控制方式</td>
<td>提高了CPU的工作效率，具备实时性，可并行工作，不用反复查询外设的工作状态</td>
<td>每次进行数据传输都要保存现场</td>
</tr>
<tr>
<td align="center">DMA方式</td>
<td>按数据块传输，不经过CPU，不需要保护现场</td>
<td>硬件复杂（DMA控制器）</td>
</tr>
</tbody></table>
<hr>
<h2 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h2><p>中断的基本概念：中断接口电路、中断源、中断分类、中断类型码、中断向量、中断向量表、中断响应处理的过程、中断服务子程序的结构</p>
<p>多级中断管理：中断优先级、禁止&#x2F;屏蔽中断、中断嵌套、中断系统的基本功能</p>
<p>80x86的中断指令：开中断STI、关中断CLI、软件中断INT n、中断返回IRET、中断溢出INTO</p>
<p>中断控制器8259A：内部结构和外部引脚、响应可屏蔽中断的过程、中断管理方式、编程控制方式</p>
<p>PC系列机中的中断系统：非屏蔽中断、可屏蔽中断</p>
<p>微型计算机系统中用到的中断及应用举例：日时钟中断、键盘中断、实时时钟中断、用户中断</p>
<p>硬件中断和软件中断的区别：相同点、不同点</p>
<h3 id="中断的基本概念"><a href="#中断的基本概念" class="headerlink" title="中断的基本概念"></a>中断的基本概念</h3><p>中断：CPU在执行程序的过程中，由于某种外部或内部事件的作用，使CPU停止当前正在执行的程序而转去为该事件服务，待事件服务结束后，又能自动返回到被中止了的程序中继续执行的过程</p>
<ul>
<li>被中断的原程序称为主程序</li>
<li>中断处理程序称为中断服务子程序</li>
<li>主程序被中止的地方，称为断点，也就是下一条指令所在内存的地址</li>
</ul>
<p><strong>中断源及中断分类</strong></p>
<p>中断源是指能够引发CPU中断的信息源</p>
<ul>
<li>外部中断源（硬件中断源）：I&#x2F;O设备、数据通道、时钟、故障源</li>
<li>内部中断源（软件中断源）：执行INT软件中断指令、CPU指令执行产生的异常</li>
</ul>
<p>中断分类：根据中断源不同，中断分为外部中断和内部中断</p>
<ul>
<li><p>外部中断：由外部事件引发的中断，即由CPU以外的设备发出，并由CPU的中断请求信号引脚输入所引发的中断称为外部中断，也成为了硬件中断</p>
</li>
<li><p>内部中断：由CPU内部事件，即由CPU硬件故障或程序执行中的时间所引发的中断称为内部中断。内部中断可以进一步分为软件中断和异常</p>
<p>执行有定义的INT n指令而引发的中断，称为软件中断。软件中断可分为BIOS中断、DOS中断。DOS中断，又分为DOS专用中断、DOS保留中断、用户可调用的DOS中断及保留给用户开发的中断</p>
<p>由于CPU本身故障、程序故障等引发的中断，称为异常</p>
</li>
<li><p>异常：除法错中断、单步或陷阱中断、断点中断、溢出中断</p>
</li>
</ul>
<h3 id="中断向量及中断向量表"><a href="#中断向量及中断向量表" class="headerlink" title="中断向量及中断向量表"></a>中断向量及中断向量表</h3><p><strong>中断类型码</strong></p>
<p>为了区别各种不同的中断，微机系统给每一个中断分配了一个中断号n，即中断类型码，其取值范围是0 ~ 255</p>
<p>微机系统可以处理256种中断，在这256个中断中，intel在它各种微处理器中都保留了前32个（0-31）为系统所专用，后224个可由用户设定</p>
<p><strong>中断向量</strong></p>
<p>中断向量是实模式下，中断服务子程序的入口地址</p>
<p>两部分组成：</p>
<ul>
<li>服务程序所在代码段的段基址：2字节</li>
<li>服务程序入口的偏移地址：2字节</li>
</ul>
<p><strong>中断向量表</strong></p>
<p>中断类型码通过一个地址指针表与中断服务程序的入口地址相联系：</p>
<p>实模式下：该表称为中断向量表</p>
<p>保护模式下：该表称为中断描述符表</p>
<ul>
<li><p>中断向量表的设置：</p>
<p>CPU规定：在实模式下，中断向量表需设置在系统的RAM最低端的1K单元</p>
</li>
<li><p>中断向量表的表地址与中断类型的关系（n型中断向量）</p>
<p>n型服务程序入口的偏移地址：4n+0 ~ 4n+1</p>
<p>n型服务程序入口的段基址：4n+2 ~ 4n+3</p>
</li>
<li><p>中断向量表的初始化</p>
<ul>
<li>由BIOS设计的中断服务程序（如：INT 16H、INT 10H…）其中断向量在加电时由BIOS负责写入中断向量表</li>
<li>由DOS设计的中断服务程序（如：INT 21H）其中断向量是在启动DOS时，由DOS负责写入中断向量表</li>
<li>用户程序开发的中断服务程序，由用户程序写入其中断向量</li>
</ul>
</li>
</ul>
<h3 id="中断响应及处理"><a href="#中断响应及处理" class="headerlink" title="中断响应及处理"></a>中断响应及处理</h3><p><strong>中断响应和处理过程</strong></p>
<p>微机系统各种类型中断的响应和处理过程不完全相同，主要区别在于中断类型码的获得方式不同，当CPU获得了中断类型码后的处理过程基本类似</p>
<ul>
<li>对于非屏蔽硬件中断请求，CPU内部会自动产生中断类型码2</li>
<li>对于可屏蔽硬件中断请求，当CPU出于开中断状态时，由外部中断控制器将响应的中断类型码送给CPU</li>
<li>对于异常，中断类型码也是自动形成的</li>
<li>对于INT n指令，中断类型码即为指令中给定的n</li>
</ul>
<p>CPU获得了中断类型码n后，中断的处理过程如下：</p>
<ul>
<li><p>F寄存器-&gt;栈（保存中断处理之前的F状态）</p>
<p>使F中的T标志置0—禁止单步操作</p>
<p>​			  I标志置0—CPU处于关中断状态</p>
</li>
<li><p>断点地址-&gt;栈</p>
<p>先：断点基地址（CS）-&gt;栈</p>
<p>后：断点偏移地址（IP）-&gt;栈</p>
</li>
<li><p>CPU从4n ~ 4n+3单元取出n型服务程序入口地址-&gt;IP：CS，从而转入n型中断服务程序</p>
</li>
<li><p>服务程序执行完毕，执行中断返回指令。中断返回指令的功能是按顺序恢复断点处的IP值、CS值和之前保护的响应中断前的标志寄存器内容-&gt;标志寄存器。CPU根据恢复后的CS：IP返回断点，继续执行主程序</p>
</li>
</ul>
<h3 id="多级中断管理"><a href="#多级中断管理" class="headerlink" title="多级中断管理"></a>多级中断管理</h3><p><strong>中断优先与中断分级</strong></p>
<p>当有多个中断源在同一时刻提出请求时，CPU对众怒单响应的次序称中断优先级</p>
<p>中断响应的次序是用排队器硬件实现的，中断优先级如下所示。为了根据需要，可以由程序控制改变实际的中断处理次序</p>
<p>除法错中断（最高）—&gt;软件中断INT n—&gt;断点中断—&gt;溢出中断INTO—&gt;NMI中断—&gt;INTR中断—&gt;单步中断（最低）</p>
<p><strong>禁止中断与中断屏蔽</strong></p>
<p>禁止中断：产生中断请求后，CPU不能中断现行程序的执行</p>
<p>中断屏蔽：用程序有选择地封锁部分中断，而允许其余部分任可得到响应</p>
<p><strong>中断嵌套</strong></p>
<p>中断嵌套：在执行中断服务程序时，仍可再响应中断申请</p>
<p><strong>中断系统应具备的基本功能</strong></p>
<ul>
<li>对于硬件中断，接口电路应具备“屏蔽”和“开放”的功能，这种功能由程序员通过软件去控制</li>
<li>能实现中断判优（中断排队），当有多个中断源提出请求时，应能优先响应高级别的中断源</li>
<li>能够实现中断嵌套</li>
<li>响应中断后，能自动转入中断处理，处理完毕能自动返回断点</li>
</ul>
<h3 id="80x86中断指令"><a href="#80x86中断指令" class="headerlink" title="80x86中断指令"></a>80x86中断指令</h3><ul>
<li><p>开中断指令STI</p>
<p>功能：使F寄存器中I标志置1，CPU处于开中断状态</p>
</li>
<li><p>关中断指令CLI</p>
<p>功能：使F寄存器中I标志置0，CPU处于关中断状态</p>
</li>
<li><p>软件中断指令INT n</p>
<p>n为中断类型码，n为0 ~ 255之间有定义的无符号整数</p>
<p>功能：无条件转向n型中断服务子程序</p>
</li>
<li><p>中断返回指令IRET</p>
<p>功能：依次从栈顶弹出6个元素-&gt;IP，CS，F</p>
<p>如果栈顶是INT n的断口地址，则执行IRET后，返回断点，否则不能</p>
</li>
<li><p>溢出中断指令INTO</p>
<p>功能：先判别F寄存器中O标志位是否为1，如是则直接调用类型为4的中断子程序，用以处理溢出中断</p>
</li>
</ul>
<h3 id="中断控制器8259A功能"><a href="#中断控制器8259A功能" class="headerlink" title="中断控制器8259A功能"></a>中断控制器8259A功能</h3><p><strong>8259A功能</strong></p>
<p>intel 8259A是可编程的中断控制器：</p>
<ul>
<li>1片8259A中断控制器可以管理8级中断，通过级联，采用1注8从的方式，可扩展管理64级中断</li>
<li>每一级中断都可以通过设置内部屏蔽字进行屏蔽或允许</li>
<li>在中断响应周期，8259A可以向CPU提供相应的中断类型码</li>
<li>8259A是很复杂的中断控制器，可以通过编程从中断触发方式、中断屏蔽方式、中断优先级管理方式、中断结束方式和总线连接5个方面对中断进行管理</li>
</ul>
<p><strong>8259A主从级联</strong></p>
<p>1片8259A中断控制器可以管理8级中断</p>
<p>2片8259A通过级联，采用1主1从的方式，可管理15级中断</p>
<p>通过级联，采用1主8从的方式，可扩展管理64级中断</p>
<h3 id="中断控制器8259A内部结构"><a href="#中断控制器8259A内部结构" class="headerlink" title="中断控制器8259A内部结构"></a>中断控制器8259A内部结构</h3><ul>
<li><p>中断请求寄存器（IRR）：寄存器引脚IR0 ~ IR7的中断请求信号，IRRi位置1，表明IRi引脚上有了中断请求信号</p>
</li>
<li><p>中断屏蔽寄存器（IMR）：寄存程序员写入的中断屏蔽字，屏蔽字某位&#x3D;1（IMRi位&#x3D;1），则与该为对应的中断请求信号（IRRi位）就不能送到中断优先权电路</p>
</li>
<li><p>优先权电路：</p>
<ul>
<li>比较同时送达优先权电路中断请求，哪一个级别最高</li>
<li>比较CPU正为之服务的中断源和刚进入优先权电路的中断源，哪一个级别更高</li>
</ul>
<p>通过判优“选中”其中级别最高的中断源，然后通过控制电路，从INT端向CPU提出中断请求</p>
</li>
<li><p>中断控制电路：</p>
<ul>
<li>寄存一组初始化命令字和操作命令字，通过译码产生内部控制信号</li>
<li>当判优电路选中一个中断源时向CPU提众怒单请求（INT）</li>
<li>通过INTA接收CPU送来的中断响应信号，中断响应信号是2个连续的脉冲</li>
</ul>
</li>
<li><p>中断服务寄存器（ISR）：8位寄存器，ISRi位与IRRi位一一对应</p>
<p>功能：记录CPU正为之服务的是哪一个中断源</p>
</li>
<li><p>数据总线缓冲器：</p>
<ul>
<li>完成与CPU数据线配接</li>
<li>接收初始化命名字，操作命名字</li>
<li>当收到第二个中断脉冲响应脉冲时，通过他们向CPU送出被选中的中断源的中断类型码n</li>
</ul>
</li>
<li><p>读&#x2F;写控制模块</p>
<p>功能：接收片选信号CS、端口选择信号A0和读写控制信号RD、WR</p>
<p>1片8259A在系统中占用两个口地址，用末位地址线A0选择端口，其他地址线通过译码产生8259A的片选信号</p>
</li>
<li><p>级联&#x2F;缓冲比较器</p>
<p>1片8259A可以管理8级中断，2片8259A“级联”可以管理15级中断，级联&#x2F;缓冲比较器是为完成多片8259A级联设置的模块</p>
</li>
</ul>
<h3 id="中断控制器8259A外部引脚"><a href="#中断控制器8259A外部引脚" class="headerlink" title="中断控制器8259A外部引脚"></a>中断控制器8259A外部引脚</h3><p>IR0 ~ IR7：外部中断请求信号输入</p>
<p>INT：输出，提供CPU的INTR端</p>
<p>INTA：输入，几首CPU发来的中断响应</p>
<p>D0 ~ D7：输入&#x2F;输出u，数据总线</p>
<p>CS：片选信号</p>
<p>A0：地址线A0，用于选择内部端口</p>
<p>WR、RD：读&#x2F;写控制信号</p>
<p>CAS0 ~ CAS2：用于8259级联</p>
<p>SP&#x2F;EN：用于8259级联</p>
<table>
<thead>
<tr>
<th align="center">CS</th>
<th align="center">A0</th>
<th align="center">RD</th>
<th align="center">WD</th>
<th align="center">奇地址&#x2F;偶地址</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">偶地址</td>
<td>写ICW1、ICW2、ICW3</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">偶地址</td>
<td>读查询字、IRR、ISR</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">奇地址</td>
<td>写ICW2、ICW3、ICW4、OCW4</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">奇地址</td>
<td>读IMR</td>
</tr>
<tr>
<td align="center">X</td>
<td align="center">X</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center"></td>
<td>数据总线为高阻态</td>
</tr>
</tbody></table>
<p><strong>8259A的中断过程</strong>—CPU响应可屏蔽硬件中断的过程</p>
<ul>
<li>首先由中断请求寄存器寄存加到引脚IR0 ~ IR7上的中断请求</li>
<li>在中断屏蔽寄存器的管理下，没有被屏蔽的中断请求被送到优先权电路判优</li>
<li>经过优先权电路的判别，选中当前级别最高的中断源，然后从引脚INT向CPU发出中断请求信号</li>
<li>CPU满足一定条件后，向8259A发出2个中断响应信号（负脉冲）</li>
<li>8259A从引脚INTA收到第1个中断响应信号之后，立即使中断服务寄存器中与被选中的中断源对应的那一位置1，同时把中断请求寄存器中的相应位清0</li>
<li>从引脚INTA收到第2个中断响应信号后，8259A把选中的中断源类型码n，通过数据线送往CPU</li>
<li>在实模式下，CPU从4 * n ~ 4 * n + 3单元取出该中断源的中断向量-&gt;IP、CS，从而引导CPU执行该中断源的中断服务程序</li>
</ul>
<p><strong>8259A的中断管理方式</strong></p>
<ul>
<li>中断触发方式：边沿触发、电平触发</li>
<li>中断屏蔽方式：常规屏蔽方式、特殊屏蔽方式</li>
<li>中断优先级管理方式：完全嵌套方式、特殊嵌套方式、优先级循环方式（常规EOI循环方式、自动EOI循环方式、特殊EOI循环方式）</li>
<li>中断结束方式：自动EOI方式、非自动EOI凡是（常规EOI方式、特殊EOI方式）</li>
<li>总线连接方式：缓冲方式、非缓冲方式</li>
</ul>
<h3 id="PC系列机中断管理方式"><a href="#PC系列机中断管理方式" class="headerlink" title="PC系列机中断管理方式"></a>PC系列机中断管理方式</h3><p><strong>PC系列机中断管理方式</strong></p>
<p>8259A中断控制器是中断系统的核心器件，对系统8259A的初始化编程是在微机启动之后由BIOS自动完成的，设定的中断管理方式为：</p>
<ul>
<li>系统8259A，中断触发方式为边沿触发</li>
<li>中断屏蔽方式采用常规屏蔽方式</li>
<li>中断源为固定优先级</li>
<li>采用常规中断结束方式</li>
</ul>
<p><strong>PC系列机中8259的编程</strong></p>
<p>286以上的微机，对8259A的编程，分两步进行：</p>
<ul>
<li><p>对8259A进行初始化编程—系统加点后，由BIOS完成</p>
</li>
<li><p>对8259A进行应用编程—编写中断程序时完成，有2项内容：</p>
<p>需要时，向8259A中断屏蔽寄存器写入屏蔽字</p>
<p>每一个硬件中断服务程序结束前必须向8259A送中断结束命令字，通知8259A本次中断结束，否则8259A不能响应同一中断源的下次中断</p>
</li>
</ul>
<p><strong>非屏蔽中断</strong></p>
<p>输入到NMI引脚的中断请求信号，引发的中断</p>
<p>响应非屏蔽中断的条件：</p>
<ul>
<li>有非屏蔽中断请求，没有DMA请求</li>
<li>一条指令执行完</li>
</ul>
<p>CPU响应非屏蔽中断过程：CPU在每一条指令的最后一个时钟周期，检测NMI引脚。处理器不屏蔽来自NMI的中断请求。处理器在响应NMI中断时，不从外部硬件接收中断向量信号。在80x86中，非屏蔽中断所对应的中断向量号固定为2。为了非屏蔽中断的嵌套，每当接收到一个NMI中断，处理器就在内部屏蔽了再次响应NMI，每当接收一个NMI中断，处理器就在内部屏蔽了再次响应NMI，这一屏蔽过程直到执行中断返回指令IRET后彩结束。所以，NMI处理程序应以IRET指令结束</p>
<h3 id="PC系列机中可屏蔽中断"><a href="#PC系列机中可屏蔽中断" class="headerlink" title="PC系列机中可屏蔽中断"></a>PC系列机中可屏蔽中断</h3><p><strong>PC系列机中可屏蔽中断</strong></p>
<p>可屏蔽中断：输入到INTR引脚的中断请求信号，引发的中断</p>
<p>硬件中断的级别：DMA请求级别高于非屏蔽中断高于可屏蔽中断</p>
<p><strong>响应可屏蔽中断的条件</strong></p>
<ul>
<li>有可屏蔽中断请求，没有DMA请求，没有非屏蔽中断请求</li>
<li>CPU一条指令执行完毕</li>
<li>CPU出于开中断状态（I标&#x3D;1）</li>
</ul>
<p><strong>CPU响应可屏蔽中断的过程</strong></p>
<p>CPU在每一条指令的最后一个时钟周期，检测INTR引脚，当检测到有可屏蔽中断请求时，在满足上述条件的前提下，通过总线控制器向系统8259A发出中前段响应信号（2个负脉冲）。获取8259A送来的中断类型码之后，在实模式下查询中断向量表，从而转向相应的中断源的中断服务程序</p>
<p>使用2片8259级联管理15级中断</p>
<table>
<thead>
<tr>
<th>主8259</th>
<th>中断源</th>
<th>中断类型</th>
<th>从8259</th>
<th>中断源</th>
<th>中断类型</th>
</tr>
</thead>
<tbody><tr>
<td>IR0</td>
<td>日时钟</td>
<td>08H</td>
<td>IR0</td>
<td>实时时钟</td>
<td>70H</td>
</tr>
<tr>
<td>IR1</td>
<td>键盘</td>
<td>09H</td>
<td>IR1</td>
<td>用户中断</td>
<td>71H改向0AH</td>
</tr>
<tr>
<td>IR2</td>
<td>从8259</td>
<td></td>
<td>IR2</td>
<td>保留</td>
<td>72H</td>
</tr>
<tr>
<td>IR3</td>
<td>辅串口</td>
<td>0BH</td>
<td>IR3</td>
<td>保留</td>
<td>73H</td>
</tr>
<tr>
<td>IR4</td>
<td>主串口</td>
<td>0CH</td>
<td>IR4</td>
<td>保留</td>
<td>74H</td>
</tr>
<tr>
<td>IR5</td>
<td>并行口2</td>
<td>0DH</td>
<td>IR5</td>
<td>协处理器</td>
<td>75H</td>
</tr>
<tr>
<td>IR6</td>
<td>软盘</td>
<td>0EH</td>
<td>IR6</td>
<td>硬盘</td>
<td>76H</td>
</tr>
<tr>
<td>IR7</td>
<td>并行口1</td>
<td>0FH</td>
<td>IR7</td>
<td>保留</td>
<td>77H</td>
</tr>
</tbody></table>
<h3 id="系统日时钟中断"><a href="#系统日时钟中断" class="headerlink" title="系统日时钟中断"></a>系统日时钟中断</h3><p><strong>日时钟中断源</strong></p>
<p>系统8254 0#计数器</p>
<p>BIOS对系统8254 0#计数器初始化，使系统8254 0#计数器每55ms产生一次中断请求</p>
<p><strong>日时钟中断类型</strong></p>
<p>日时钟的中断请求接至系统主8259A的IR0</p>
<p>日时钟中断的中断类型是：08H</p>
<p><strong>日时钟中断处理流程</strong></p>
<p>CPU转入8型中断后，完成下列工作：</p>
<ul>
<li>开中断，保护现场（DS…压栈）</li>
<li>40H-&gt;DS，对“日时钟计数器”加1</li>
<li>测算软驱马达关闭时间</li>
<li>执行INT 1CH</li>
<li>向主8259送中断结束命令</li>
<li>恢复现场，IRET</li>
</ul>
<p><strong>系统日时钟中断开发应用</strong></p>
<ul>
<li><p>置换中断向量</p>
<p>CPU响应日时钟中断后，自动转向“08H型”服务程序。根据BIOS设计的08H型中断服务程序处理流程，可以知道，用户自行设计定时中断服务程序类型可以是“08H”，也可以是1CH</p>
</li>
<li><p>用户中断服务程序结束</p>
</li>
<li><p>中断服务程序的执行时间</p>
</li>
<li><p>避免DOS重入</p>
</li>
</ul>
<h3 id="系统键盘中断"><a href="#系统键盘中断" class="headerlink" title="系统键盘中断"></a>系统键盘中断</h3><p><strong>键盘中断源</strong></p>
<p>系统键盘中断源是主板键盘接口电路</p>
<p><strong>键盘中断类型</strong></p>
<p>键盘中断的中断请求接至系统主8259A和IR1</p>
<p>键盘中断的中断类型是：09H</p>
<p><strong>键盘中断处理流程</strong></p>
<p>BIOS设计的09H型中断服务程序处理流程如下：</p>
<ul>
<li>开中断、保护现场</li>
<li>从键盘接口电路（口地址60H）读取按键扫描码</li>
<li>分析、处理按键扫描码，生成相应的键代码存入键盘缓冲区</li>
<li>向主8259A发常规中断结束命令</li>
<li>恢复现场，执行IRET命令</li>
</ul>
<p><strong>键盘中断的开发应用</strong></p>
<ul>
<li><p>键盘缓冲区</p>
<p>BIOS规定：系统RAM 40:1EH ~ 40:3DH为键盘缓冲区共32个单元，实际使用30个单元，存放15个键的键代码。键盘缓冲区是以“先进先出”的规则存取</p>
<p>由9型服务程序写入键代码，用户用INT 16H访问键盘缓冲区，所以键盘缓冲区是9型硬中断和INT 16H软中断之间交换信息的缓冲区</p>
</li>
<li><p>键盘状态字节</p>
<p>系统RAM 40:17H单元为键盘状态单元，用来记录控制键和切换键的状态</p>
</li>
<li><p>读取键盘缓冲区</p>
<p>有两种方式可以读取键盘缓冲区中的内容：</p>
<ul>
<li>直接从60H端口中读取键盘扫描码，在应用程序中分析键盘输入的是字符还是控制符、切换符等</li>
<li>利用BIOS提供的众怒单INT 16H</li>
</ul>
</li>
</ul>
<h3 id="系统实时时钟中断"><a href="#系统实时时钟中断" class="headerlink" title="系统实时时钟中断"></a>系统实时时钟中断</h3><p><strong>实时时钟中断源</strong></p>
<p>系统实时时钟的中断源是主板上的实时时钟电路</p>
<p>实时时钟中断源包括周期中断和报警中断。这两种中断中的任何一种中断请求都将引发实时时钟中断</p>
<p><strong>实时时钟中断类型</strong></p>
<p>系统实时时钟中断的中断请求接至系统从8259A的IR0</p>
<p>系统实时时钟中断的中断类型是：70H</p>
<p><strong>实时时钟中断处理流程</strong></p>
<p>BISO设计的70型中断服务程序处理流程如下：</p>
<ul>
<li>开中断，保护现场</li>
<li>读取状态寄存器，判断是否是周期中断</li>
<li>判断是否是报警中断</li>
<li>向主、从8259A发出常规结束命令</li>
<li>恢复现场，执行IRET命令</li>
</ul>
<h3 id="系统用户中断"><a href="#系统用户中断" class="headerlink" title="系统用户中断"></a>系统用户中断</h3><p><strong>系统用户中断源</strong></p>
<p>系统用户中断的中断源是：系统的ISA总线B4端子（IRQ9）引入的中断请求信号</p>
<p><strong>系统用户中断类型</strong></p>
<p>系统用户中断请求接至系统从8259A的IR1</p>
<p>系统用户中断的中断类型是：71H</p>
<p><strong>系统用户中断处理流程</strong></p>
<p>BIOS设计的71H型中断服务程序处理流程如下：</p>
<ul>
<li>开中断，保护现场</li>
<li>向从8259A发出中断结束命令</li>
<li>执行INT 0AH，转向0AH服务程序</li>
</ul>
<p><strong>系统用户中断开发应用</strong></p>
<p>用户中断时微机系统为用户开发可屏蔽中断预备的中断口。在用户中断程序的设计中，需采取一下措施：</p>
<ul>
<li>把外扩中断源的中断请求（由低电平到高电平的跃变）接入ISA总线B4端子</li>
<li>开放用户中断</li>
<li>置换中断向量</li>
<li>用户中断服务程序结束，向8259A写结束字</li>
</ul>
<h3 id="硬件中断和软件中断的区别"><a href="#硬件中断和软件中断的区别" class="headerlink" title="硬件中断和软件中断的区别"></a>硬件中断和软件中断的区别</h3><p><strong>硬件中断和软件中断的相同点</strong></p>
<ul>
<li>都会引起程序中止</li>
<li>CPU获得中断类型码n后，自动从4 * n ~ 4 * n + 3单元取出该中断源的中断向量-&gt;IP、CS，从而执行该中断源的中断服务程序</li>
</ul>
<p><strong>硬件中断和软件中断的区别</strong></p>
<ul>
<li><p>中断的引发方式不同</p>
<p>硬件中断是由CPU以外的设备发出的接到引脚INTR和NMI上的中断请求信号而引发的。而软件中断是由CPU执行INT n指令而引发的</p>
</li>
<li><p>CPU获取中断类型码的方式不同</p>
<p>可屏蔽硬件中断，中断类型码是由中断控制器8259A提供</p>
<p>非屏蔽硬件中断类型码是自动产生的</p>
<p>软件中断，中断类型码是由软件中断指令INT n本身提供的</p>
</li>
<li><p>CPU响应时间不同</p>
<p>可屏蔽硬件中断时可以被屏蔽的，只有在CPU开中断时，才能响应</p>
<p>非屏蔽硬件中断和软件中断不能被屏蔽</p>
</li>
<li><p>中断处理程序的结束方式不同</p>
<p>在硬件可屏蔽中断服务程序中，中断处理结束后，首先需要向8259A发出中断结束命令，然后执行IRET指令，中断返回</p>
<p>而在软件中断服务程序中，中断处理结束后只需要执行IRET命令</p>
</li>
</ul>
<hr>
<h2 id="微型计算机系统串行通信"><a href="#微型计算机系统串行通信" class="headerlink" title="微型计算机系统串行通信"></a>微型计算机系统串行通信</h2><p>串行通信技术：计算机通信方式、串行数据传输方式、串行异步通信协议</p>
<p>可编程串行异步通信接口芯片8250:8250的内部结构、8250的端口寄存器、8250的初始化编程</p>
<p>串行通信程序设计：串行通信的外部环境、串行通信程序设计举例</p>
<h3 id="串行通信基础"><a href="#串行通信基础" class="headerlink" title="串行通信基础"></a>串行通信基础</h3><p><strong>串行通信类型</strong></p>
<p>CPU与外部的信息交换称为通信</p>
<p>通信：</p>
<ul>
<li>并行通信：数据所有位同时被传输</li>
<li>串行通信：数据被逐位顺序传输（串行异步通信、串行同步通信）</li>
</ul>
<p>串行异步通信：指一帧字符用起始位和停止位来完成收发同步</p>
<p>串行同步通信：靠同步字符来完成收发双方同步，要求严格的时钟同步</p>
<p>数据传送速度：并行通信&gt;串行同步通信&gt;串行异步通信</p>
<p><strong>串行数据传输方式</strong></p>
<ul>
<li><p>串行数据通信系统模型</p>
<p>计算机—MODEM—信道（传输线路）—MODEM—计算机或终端</p>
<p>必须考虑的问题：信道的带宽和数据的传输速率、信号的调制与解调、串行通信的信号格式等</p>
</li>
<li><p>串行数据传输方式：</p>
<ul>
<li>单工方式：只允许数据按照一个固定方向传送</li>
<li>半双工方式：要求收发双方具备接收和发送数据的能力，由于只有一条信道，数据不能同时在两个方向上传送</li>
<li>全双工方式：在全双工方式中，收发双方可同时进行数据传送</li>
</ul>
</li>
</ul>
<p><strong>串行异步通信协议</strong></p>
<ul>
<li><p>标准数据格式</p>
<p>起始位|（低）5-8个数据位（高）|可选的奇偶校验位|1、1.5、2个停止位</p>
<p>奇偶校验位（可有可无）：</p>
<ul>
<li>奇校验：数据位与校验位中”1“的个数为奇数</li>
<li>偶校验：数据位与校验位中“1”的个数为偶数</li>
<li>通信双方约定采用一致的奇偶校验的方式，由发送方设置校验位，由接收方负责校验</li>
</ul>
</li>
<li><p>一帧数据发送时序</p>
<p>异步通信时，一帧字符以起始位“0”开始，紧跟着是数据位（先发送最低位，再是最高位）、奇偶校验位，最后以停止位结束。无数据传送时，通信线路时间逻辑“1”，即停止位</p>
</li>
<li><p>通信速率（传输速率）</p>
<p>数据信号速率，又称波特率，表示每秒传送的0、1代码个数（包括起始位、校验位、停止位），单位为“波特”</p>
<p>接下来所涉及的串行数据通信均使用二进制信号传输，所说的通信速率实际是指数据信号速率</p>
<p>异步通信传送中，收发双发的约定：收发双方的帧数据格式一致、收发双方的通信速率一致</p>
</li>
<li><p>信号的调制与解调</p>
<p>数据通信传输的是数字信号，要求传送线的频带很宽，但长距离通信时会利用电话线传送，而电话线的带宽为300 ~ 3000Hz，因此若直接传送数字信号，信号就要发生畸变</p>
<p>因此，需用调制器将数字信号转换成模拟信号—传输—再用调制器将其转换成数字信号</p>
</li>
<li><p>串行通信接口标准—RS-232C标准</p>
<p>要进行串行通信，还有解决一个问题：计算机与MODEM怎样连接？—通过接口电路（串行接口电路）连接</p>
<p>这个接口的机械特性、电气特性、功能特性都要遵循一定的规范，也就是要有一个标准</p>
<p>目前计算机通信使用最普遍的的RS-232C标准。它对两方面作了规定：信号的电平标准和控制信号的定义</p>
</li>
</ul>
<h3 id="可编程串行异步通信接口芯片8250"><a href="#可编程串行异步通信接口芯片8250" class="headerlink" title="可编程串行异步通信接口芯片8250"></a>可编程串行异步通信接口芯片8250</h3><p>8250的特点：</p>
<ul>
<li>实现串行数据、并行数据的转换，实现全双工异步通信</li>
<li>支持异步通信协议，数据格式、通信速率等由初始化编程设定</li>
<li>内部由MODEM控制器，可直接和MODEM相连</li>
<li>内部有中断机制，CPU可查询、中断方式与之交换信息</li>
</ul>
<p>PC机中有2个串行口：主串口3FXH、辅串口2FXH</p>
<p>高档微机中，8250的功能被一些多功能芯片取代</p>
<p><strong>8250的内部结构及引脚功能</strong></p>
<p>数据总线缓冲器、选择和控制逻辑；内部数据总线；接收缓冲存储器、接收移位寄存器、通信线控制寄存器、通信线状态寄存器、除数锁存器（低、高）、波特率发生器、发送保持寄存器、发送移位寄存器、MODEM控制寄存器、MODEM状态寄存器、MODEM逻辑控制、中断允许寄存器、中断识别寄存器、中断控制逻辑</p>
<p>串行数据发送过程：CPU执行OUT指令，将待发送的数据发送到发送保存寄存器暂存，当发送移位寄存器空闲时自动装入，后者在发送器时钟控制下将并行数据添加起始位、校验位、停止位，一位一位发出</p>
<p>串行数据接收过程：在接收器时钟控制下，接收移位寄存器一位一位地接收串行数据，自动的去掉起始位、校验位、停止位，并转换成并行数据发送至接收缓冲寄存器暂存，在接收过程中对一帧数据自动进行校验</p>
<p><strong>8250的内部寄存器</strong></p>
<ul>
<li><p>发送保持寄存器（3F8H&#x2F;2F8H）</p>
<p>该寄存器保存CPU传送来的并行数据，并转移至发送移位寄存器</p>
<p>注：只有在发送保存寄存器空闲时，CPU才能写入下一个数据</p>
</li>
<li><p>接收缓冲寄存器（3F8H&#x2F;2F8H）</p>
<p>接收移位寄存器将接收到的数据去掉起始位、校验位和停止位，转换成并行数据，转换后的并行数据存入接收缓冲寄存器，等待CPU接收</p>
<p>注：只有当一帧数据收完后，CPU才能用IN指令读接收缓冲寄存器</p>
</li>
<li><p>通信线状态寄存器（3FDH&#x2F;2FDH）</p>
<p>该寄存器提供数据传输的状态信息</p>
<ul>
<li>D0：接收数据准备好（接收缓冲器满）标志位</li>
<li>D1：溢出错标志位</li>
<li>D2：奇偶错标志位</li>
<li>D3：接收格式错标志位</li>
<li>D4：线路间断标志位</li>
<li>D5：发送保持寄存器空闲标志位</li>
<li>D6：发送移位寄存器空闲标志位</li>
</ul>
<p>只有当D0为1时，CPU才能读数据</p>
<p>只有当D5或D6为1时，CPU才能写数据</p>
</li>
<li><p>中断允许寄存器（3F9H&#x2F;2F9H）</p>
<p>8250有4级中断：</p>
<ul>
<li>接收线路状态中断（接收数据错OE、PE、FE、BI置1产生中断）</li>
<li>接收缓冲器满</li>
<li>发送缓冲器空</li>
<li>MODEM状态中断（MODEM应答联络信号状态变化产生中断）</li>
</ul>
<p>当上述4中类型中断有一种或多种出现时，8250便输出INTRPT信号</p>
</li>
<li><p>中断识别寄存器（3FAH&#x2F;2FAH）</p>
<p>由于8250仅能向CPU发出一个总的中断请求信号，为了识别是哪一个中断源引起的中断，应当在转入中断服务程序之后，读取中断识别寄存器的内容进行判断，然后再转入相应的处理程序</p>
</li>
<li><p>MODEM控制寄存器（3FCH&#x2F;2FCH）</p>
<p>D0、D1位直接控制RS232C的DTR和RTS引脚，向外部表明了8250是否做好的收&#x2F;发的准备</p>
</li>
<li><p>除数寄存器（高8位3F9H&#x2F;2F9H、低8位3F8H&#x2F;2F8H）</p>
<p>存放初始化编程时写入的分频信息</p>
<p>8250内部的波特率发生器是软件控制的可编程的分频器</p>
</li>
<li><p>通信线控制寄存器（3FBH&#x2F;2FBH）</p>
<p>该寄存器主要用于指定串行异步通信的数据格式</p>
</li>
<li><p>MODEM状态寄存器（3FEH&#x2F;2FEH）</p>
<p>该寄存器反映8250与通信设备（如MODEM）之间联络信号的当前状态以及这些信号地变化情况</p>
</li>
</ul>
<p><strong>8250的初始化编程</strong></p>
<ul>
<li><p>直接对8250端口操作</p>
<ul>
<li><p>确定波特率—设置除数寄存器</p>
</li>
<li><p>确定数据格式—设计通信线路控制寄存器</p>
</li>
<li><p>若使用中断方式—需设置中断允许寄存器的相应位（置“1”）</p>
</li>
<li><p>设置MODEM控制寄存器</p>
<p>通常该寄存器的值设置为03H—使8250输出RTS、DTR两个MODEM控制信号，及时系统中不用这两个信号，也不会带来问题</p>
</li>
</ul>
</li>
<li><p>利用BIOS通信软件</p>
<p>BIOS通过INT 14H向用户提供了4个中断子程序，分别完成：串口初始化编程、发送数据、接收数据、测试通信线状态</p>
<p>调用注意事项：</p>
<ul>
<li>调用INT 14H的0号子功能初始化串行口，通信波特率只有8中选择，奇偶校验也只有3中选择</li>
<li>从执行流程可以看出，使用0号功能初始化之后，8250的内部中断将被禁止，只能采用查询方式发送和接收数据</li>
<li>如果在0号子功能初始化之后，在对中断允许寄存器和MODEM控制寄存器写入相应的命令字，仍然能使其工作在中断方式</li>
</ul>
</li>
</ul>
<h3 id="串行通信的外部环境"><a href="#串行通信的外部环境" class="headerlink" title="串行通信的外部环境"></a>串行通信的外部环境</h3><p><strong>RS-232C引脚的连接方式</strong></p>
<p>使用BIOS通信软件，在发送和接收之前都要使用联络线与对端联络，只有联络畅通，才允许发送或接收数据</p>
<p>当使用BIOS通信程序发送和接收数据时，必须具备相应的外部环境，所谓外部环境就是RS-232C引脚的连接方式</p>
<p>RS-232C怎样连接，与串口的通信方式（单工、半双工、全双工）有关，与编程时使用的编程手段（对端口直接操作、用BIOS1#、2#）有关</p>
<ul>
<li><p>外环自发自收（有联络线、无联络线）</p>
<p>无联络线：仅能对端口直接操作编程</p>
<p>有联络线：对端口直接操作编程、调用BIOS通信软件、调用INT 21H的4#、3#（发、收）</p>
</li>
<li><p>短距离（无MODEM）点—点全双工</p>
<p>无联络线3线方式：仅能对端口直接操作编程</p>
<p>有联络线7线方式：对端口直接操作、调用BIOS通信软件、调用INT 21H的4#、3#（发、收）—只能用主串口</p>
</li>
<li><p>短距离单工通信</p>
<p>无联络线：仅能对端口直接操作编程</p>
<p>有联络线：对端口直接操作、调用BIOS通信软件、调用INT 21H的4#、3#（发、收）—只能用主串口</p>
</li>
</ul>
<p>注意：调用BIOS通信软件实现通信时，在初始化阶段应使发送方的DTR&#x3D;0，接收方的RTS&#x3D;DTR&#x3D;0</p>
<h3 id="串行通信方式设计"><a href="#串行通信方式设计" class="headerlink" title="串行通信方式设计"></a>串行通信方式设计</h3><p>设计考虑：</p>
<ul>
<li>题型：单端自发自收、点—点通信（全双工、单工）</li>
<li>CPU与串口交换信息的方式：查询、中断</li>
<li>编程手段：对端口直接编程、调用BIOS通信软件</li>
<li>根据题目要求组织相应的外部环境</li>
</ul>
<hr>
<h2 id="并行I-x2F-O接口"><a href="#并行I-x2F-O接口" class="headerlink" title="并行I&#x2F;O接口"></a>并行I&#x2F;O接口</h2><p>可编程并行I&#x2F;O接口芯片8255A：8255A的内部结构和外部引脚、8255A的工作方式（基本型输入输出、选通行输入输出、双向数据传送）、8255A的控制字和初始化编程</p>
<h3 id="8255A的内部结构和外部引脚"><a href="#8255A的内部结构和外部引脚" class="headerlink" title="8255A的内部结构和外部引脚"></a>8255A的内部结构和外部引脚</h3><p><strong>8255A的内部结构</strong></p>
<p>8255A是intel公司的产品，可编程的并行接口芯片</p>
<ul>
<li>与CPU的接口：数据总线缓冲器、读&#x2F;写控制逻辑</li>
<li>内部逻辑：A组控制、B组控制</li>
<li>外设接口：A组A口、A组C口上半部、B组C口下半部、B组B口</li>
</ul>
<p><strong>8255A的外部引脚</strong></p>
<ul>
<li>24根端口数据线—连接外设</li>
<li>8根系统数据线—连接CPU数据总线</li>
<li>电源线：+5V，地线</li>
<li>6根输入控制线</li>
</ul>
<p><strong>8255A的端口编址读&#x2F;写操作</strong></p>
<p>端口编址：</p>
<ul>
<li>00：A口数据寄存器</li>
<li>01：B口数据寄存器</li>
<li>10：C口数据寄存器</li>
<li>11：控制口寄存器</li>
</ul>
<h3 id="8255A的工作方式"><a href="#8255A的工作方式" class="headerlink" title="8255A的工作方式"></a>8255A的工作方式</h3><ul>
<li>基本型输入输出，使用于A口、B口、C口</li>
<li>选通行输入输出，适用于A口、B口</li>
<li>双向传输，只适用于A口</li>
</ul>
<p><strong>基本型输入</strong>（以B口为例）</p>
<p>8255A的数据总线缓冲器D7到D0引脚接数据总线</p>
<p>PB7到PB0是B口的端口数据线和外设相连</p>
<p>当B口定义为基本型输入时，相当于一个输入缓冲器</p>
<p>对B口执行一条IN指令，就把外设通过PB7到PB0送来的输入数据传送给CPU</p>
<p><strong>基本型输出</strong>（以A口为例）</p>
<p>当A口定义为基本型输出时，相当于一个输出缓冲器</p>
<p>CPU对A口执行一条OUT指令，把数据锁存在端口当中</p>
<p>注意：工作在基本型输入输出时，8255A和外设之间没有联络信号，相当于无条件传送</p>
<p><strong>选通行输入</strong>（以A口为例）</p>
<p>A口定义为选通行输入时，端口和外设之间有两类信号线：数据线、联络线</p>
<p>当外设把数据放在端口线上时必须伴随一个选通信号</p>
<p>端口在收到数据后，通过IBF状态告知CPU可读</p>
<p>IBF&#x3D;1，通知外设输入缓冲器已满，无法传送数据</p>
<p>IBF&#x3D;0，外设才能写入数据</p>
<p><strong>选通行输出</strong>（以B口为例）</p>
<p>B口定义为选通行输入时，端口和外设之间有两类信号线：数据线、联络线</p>
<h3 id="8255A控制字与初始化编程"><a href="#8255A控制字与初始化编程" class="headerlink" title="8255A控制字与初始化编程"></a>8255A控制字与初始化编程</h3><p><strong>8255A控制字</strong></p>
<p>8255A有两个控制字，方式选择控制字和C口按位置0&#x2F;置1控制字，控制字必须写入控制口才能有效</p>
<p><strong>8255A的初始化编程</strong></p>
<ul>
<li><p>方式选择控制字-&gt;控制口</p>
<p>目的：选择某一口的工作方式</p>
</li>
<li><p>根据需要把C口按位置0&#x2F;置1控制字-&gt;控制口</p>
<p>目的：禁止&#x2F;允许某一口提出中断请求</p>
</li>
</ul>
<p>完成初始化编程后，CPU可以用IN指令&#x2F;OUT指令通过8255A和外设交换信息</p>
<hr>
<h2 id="可编程定时-x2F-计数器"><a href="#可编程定时-x2F-计数器" class="headerlink" title="可编程定时&#x2F;计数器"></a>可编程定时&#x2F;计数器</h2><p>可编程定时&#x2F;计数器芯片8254概述：内部结构和端口寄存器、外部引脚和连接方式</p>
<p>8254的工作方式：六种工作方式、两种启动方式</p>
<p>8254的控制字和编程：控制字、编程（初始换编程、读取计数器）</p>
<p>8254的应用：8254在微型计算器系统中的应用、微型计算机系统的总线上外扩8254的应用</p>
<h3 id="8254概述"><a href="#8254概述" class="headerlink" title="8254概述"></a>8254概述</h3><p><strong>8254的内部结构和端口寄存器</strong></p>
<p>计算机中的定时和延时控制、对外部时间或信号的技术方法：软件定时、硬件定时</p>
<p>计算机系统中采用可编程定时&#x2F;计数器I8253和I8254</p>
<ul>
<li><p>8254内部结构</p>
<p>8254内部集成了3个16位的计数器，每个计数器有6种工作方式，计数初值可设定为二进制或BCD码</p>
<p>最高工作频率10兆</p>
<ul>
<li>数据总线缓冲器：完成和系统数据线的配接</li>
<li>读写控制模块：选择芯片内部的控制寄存器和计数器，在读写命令的控制下对选中的端口进行读写操作</li>
<li>控制寄存器：寄存CPU对其初始化编程时写入的控制字，以决定计数器的工作方式</li>
<li>计数器：每个计数器对外有3条线（GATE、CLK、OUT）</li>
</ul>
</li>
<li><p>8254内部寄存器&#x2F;计数器口地址</p>
<p>00：0#计数器</p>
<p>01：1#计数器</p>
<p>10：2#计数器</p>
<p>11：控制寄存器</p>
</li>
</ul>
<p><strong>8254的外部引脚和连接方法</strong></p>
<h3 id="8254的工作方式"><a href="#8254的工作方式" class="headerlink" title="8254的工作方式"></a>8254的工作方式</h3><p>每个计数器有6种工作方式，均在CLK下降沿计数一次</p>
<p>主要区别：</p>
<ul>
<li>输出波形不同</li>
<li>启动计数器的触发方式不同：软件启动、硬件启动</li>
<li>计数过程中门控信号GATE对计数操作的影响不同</li>
</ul>
<p>方式0：计数结束OUT引脚输出正跃变信号——软件启动</p>
<p>方式1：（可重触发的）硬件启动的单脉冲发生器——硬件启动</p>
<p>方式2：分频器（脉冲发生器）——软件启动</p>
<p>方式3：方波发生器（奇数、偶数）——软件启动</p>
<p>方式4：软件触发的单脉冲发生器——软件启动</p>
<p>方式5：硬件触发的单脉冲发生器——硬件启动</p>
<h3 id="8254的控制字和编程"><a href="#8254的控制字和编程" class="headerlink" title="8254的控制字和编程"></a>8254的控制字和编程</h3><p><strong>8254的控制字&#x2F;状态字</strong></p>
<ul>
<li><p>方式控制字</p>
<p>计数器选择 | 读写方式选择 | 工作选择方式 | 数制选择</p>
<p>功能：选择一个计数器，确定工作方式，并规定初值的写入顺序和计数初值（一串0,1代码）的数值</p>
</li>
<li><p>锁存命令字</p>
<p>当方式控制字中D5 D4 &#x3D; 00 标志该命令字为“锁存命令”</p>
</li>
<li><p>读出控制字</p>
<p>D7 D6 D0 &#x3D; 110 是读出命令</p>
<p>读出控制是多通道的锁存命令，一条命令可以锁存3个计数器的计数值、计数器状态</p>
</li>
<li><p>状态字</p>
<p>D7位为OUT引脚的电平</p>
<p>D6位为计数器初值是否装入</p>
</li>
</ul>
<p><strong>8254的编程</strong></p>
<ul>
<li><p>8254的初始化编程</p>
<p>对8254一个计数器的初始化编程步骤：</p>
<ul>
<li><p>向控制寄存器写入方式控制字</p>
<p>目的：选择一个计数器，并确定其工作方式和计数器（计数初值）的读&#x2F;写顺序</p>
</li>
<li><p>向选择地计数器写入计数初值</p>
<p>注意：如果方式控制字D0&#x3D;0，则初值应是二进制，否则初值应是BCD码</p>
</li>
</ul>
</li>
<li><p>读取当前计数值</p>
<p>读操作有以下3种形式，当初始化编程规定的读&#x2F;写方式为先低8位后高8位时</p>
<ul>
<li><p>使GATE&#x3D;0，停止计数，然后对应的计数器端口进行两次读操作，第一次读出的是低8位计数值，第二次读出的是高8位计数值</p>
</li>
<li><p>在计数过程中，先向8254控制寄存器写入一个D7D6&#x3D;计数器编号，D5D4&#x3D;00的控制字，锁存相应的计数器的当前值，然后再对相应的计数器端口进行两次读操作，依次读出计数器的低8位和高8位</p>
</li>
<li><p>在计数过程中，向8254控制寄存器写入读写命令，三种情况</p>
<p>如果读出命令仅锁存相应计数器的状态信息，则对相应计数器端口进行一次读操作，即可读出信息</p>
<p>如果读出命令仅锁存相应计数器的计数值，则对相应计数器端口进行两次读操作，依次读出计数值的低8位和高8位</p>
<p>如果读出命令同时锁存计数器的计数值和状态信息，则要对相应计数器端口执行三次读操作，第一次读出的是状态信息，第二次读出的是当前计数值的低8位，第三次读出的是当前计数值的高8位</p>
</li>
</ul>
</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Notes/">Notes</a></div><div class="post_share"><div class="social-share" data-image="https://image.zhihuishu.com/zhs/createcourse/course/202002/cb6922bdce6847ec90051acdadb791da_s1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/30/MySQL%E5%9F%BA%E7%A1%80/"><img class="prev-cover" src="https://upload.wikimedia.org/wikipedia/zh/thumb/6/62/MySQL.svg/1200px-MySQL.svg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">MySQL</div></div></a></div><div class="next-post pull-right"><a href="/2022/02/28/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"><img class="next-cover" src="https://pic.baike.soso.com/ugc/baikepic2/4695/cut-20210930190131-1883791953_jpg_827_552_59299.jpg/1284" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">软件工程导论</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/02/27/Docker/" title="Docker"><img class="cover" src="https://www.ondat.io/hubfs/Docker.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-27</div><div class="title">Docker</div></div></a></div><div><a href="/2023/03/14/C++/" title="C++"><img class="cover" src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/ISO_C%2B%2B_Logo.svg/1200px-ISO_C%2B%2B_Logo.svg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-14</div><div class="title">C++</div></div></a></div><div><a href="/2023/02/06/Flask/" title="Flask"><img class="cover" src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3c/Flask_logo.svg/1200px-Flask_logo.svg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-06</div><div class="title">Flask</div></div></a></div><div><a href="/2023/03/16/CMake/" title="CMake"><img class="cover" src="https://www.kitware.com/main/wp-content/uploads/2016/11/CMake-Logo-and-Text-e1540917038464.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-16</div><div class="title">CMake</div></div></a></div><div><a href="/2023/01/30/Git/" title="Git GitHub"><img class="cover" src="https://editor.analyticsvidhya.com/uploads/18288git.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-30</div><div class="title">Git GitHub</div></div></a></div><div><a href="/2023/02/17/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="Linux"><img class="cover" src="https://tools.wingzero.tw/assets/upload/1639016963439_0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-17</div><div class="title">Linux</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/day.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">santidad DAY</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">17</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/santidadday" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">微型计算机基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%95%B0%E5%80%BC"><span class="toc-number">1.1.</span> <span class="toc-text">计算机中的数值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.2.</span> <span class="toc-text">计算机中的信息表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E8%A1%A5%E7%A0%81%E8%BF%90%E7%AE%97"><span class="toc-number">1.3.</span> <span class="toc-text">整数补码运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="toc-number">1.4.</span> <span class="toc-text">微型计算机系统的基本组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.</span> <span class="toc-text">存储器基本概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#80x86%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">80x86微处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#80x86%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%91%E5%B1%95%E4%B8%8E%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">80x86微处理器发展与内部结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E4%BD%8D%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">32位微处理器工作模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E4%BD%8D%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%A8%A1%E5%BC%8F%E4%B8%8B20%E4%BD%8D%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BD%A2%E6%88%90"><span class="toc-number">2.3.</span> <span class="toc-text">32位微处理器实地址模式下20位物理地址的形成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">3.</span> <span class="toc-text">汇编语言指令集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">指令概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">标志寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">寻址方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%AD%E5%8F%A5%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">汇编语言语句类型和格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-number">3.5.</span> <span class="toc-text">常用伪指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.6.</span> <span class="toc-text">常用的运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">3.7.</span> <span class="toc-text">基本指令集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.</span> <span class="toc-text">汇编语言程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">汇编语言程序结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E6%BA%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">汇编源程序的编程格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOS-x2F-BIOS%E5%8A%9F%E8%83%BD%E8%B0%83%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">DOS&#x2F;BIOS功能调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.4.</span> <span class="toc-text">分支程序设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.5.</span> <span class="toc-text">循环程序设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.6.</span> <span class="toc-text">子程序设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E6%8C%87%E4%BB%A4%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.7.</span> <span class="toc-text">宏指令程序设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5-x2F-%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.</span> <span class="toc-text">输入&#x2F;输出系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">总线概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5-x2F-%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">5.2.</span> <span class="toc-text">输入&#x2F;输出系统概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%A4%96%E8%AE%BE%E4%BA%A4%E6%8D%A2%E4%BF%A1%E6%81%AF%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">微机系统与外设交换信息的方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.</span> <span class="toc-text">中断系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">中断的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E5%8F%8A%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8"><span class="toc-number">6.2.</span> <span class="toc-text">中断向量及中断向量表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%93%8D%E5%BA%94%E5%8F%8A%E5%A4%84%E7%90%86"><span class="toc-number">6.3.</span> <span class="toc-text">中断响应及处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86"><span class="toc-number">6.4.</span> <span class="toc-text">多级中断管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#80x86%E4%B8%AD%E6%96%AD%E6%8C%87%E4%BB%A4"><span class="toc-number">6.5.</span> <span class="toc-text">80x86中断指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A88259A%E5%8A%9F%E8%83%BD"><span class="toc-number">6.6.</span> <span class="toc-text">中断控制器8259A功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A88259A%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">6.7.</span> <span class="toc-text">中断控制器8259A内部结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A88259A%E5%A4%96%E9%83%A8%E5%BC%95%E8%84%9A"><span class="toc-number">6.8.</span> <span class="toc-text">中断控制器8259A外部引脚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PC%E7%B3%BB%E5%88%97%E6%9C%BA%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">6.9.</span> <span class="toc-text">PC系列机中断管理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PC%E7%B3%BB%E5%88%97%E6%9C%BA%E4%B8%AD%E5%8F%AF%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%AD"><span class="toc-number">6.10.</span> <span class="toc-text">PC系列机中可屏蔽中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%97%A5%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD"><span class="toc-number">6.11.</span> <span class="toc-text">系统日时钟中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E9%94%AE%E7%9B%98%E4%B8%AD%E6%96%AD"><span class="toc-number">6.12.</span> <span class="toc-text">系统键盘中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD"><span class="toc-number">6.13.</span> <span class="toc-text">系统实时时钟中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%94%A8%E6%88%B7%E4%B8%AD%E6%96%AD"><span class="toc-number">6.14.</span> <span class="toc-text">系统用户中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E4%B8%AD%E6%96%AD%E5%92%8C%E8%BD%AF%E4%BB%B6%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.15.</span> <span class="toc-text">硬件中断和软件中断的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1"><span class="toc-number">7.</span> <span class="toc-text">微型计算机系统串行通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80"><span class="toc-number">7.1.</span> <span class="toc-text">串行通信基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%BC%96%E7%A8%8B%E4%B8%B2%E8%A1%8C%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E8%8A%AF%E7%89%878250"><span class="toc-number">7.2.</span> <span class="toc-text">可编程串行异步通信接口芯片8250</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1%E7%9A%84%E5%A4%96%E9%83%A8%E7%8E%AF%E5%A2%83"><span class="toc-number">7.3.</span> <span class="toc-text">串行通信的外部环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.4.</span> <span class="toc-text">串行通信方式设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8CI-x2F-O%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.</span> <span class="toc-text">并行I&#x2F;O接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8255A%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E5%92%8C%E5%A4%96%E9%83%A8%E5%BC%95%E8%84%9A"><span class="toc-number">8.1.</span> <span class="toc-text">8255A的内部结构和外部引脚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8255A%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">8.2.</span> <span class="toc-text">8255A的工作方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8255A%E6%8E%A7%E5%88%B6%E5%AD%97%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BC%96%E7%A8%8B"><span class="toc-number">8.3.</span> <span class="toc-text">8255A控制字与初始化编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%BC%96%E7%A8%8B%E5%AE%9A%E6%97%B6-x2F-%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">9.</span> <span class="toc-text">可编程定时&#x2F;计数器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8254%E6%A6%82%E8%BF%B0"><span class="toc-number">9.1.</span> <span class="toc-text">8254概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8254%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">9.2.</span> <span class="toc-text">8254的工作方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8254%E7%9A%84%E6%8E%A7%E5%88%B6%E5%AD%97%E5%92%8C%E7%BC%96%E7%A8%8B"><span class="toc-number">9.3.</span> <span class="toc-text">8254的控制字和编程</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="Linux网络编程"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux网络编程"/></a><div class="content"><a class="title" href="/2023/12/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="Linux网络编程">Linux网络编程</a><time datetime="2023-11-30T16:00:00.000Z" title="Created 2023-12-01 00:00:00">2023-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/03/ROS/" title="ROS基础"><img src="https://d2908q01vomqb2.cloudfront.net/ca3512f4dfa95a03169c5a670a4c91a19b3077b4/2018/11/26/ros-logo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ROS基础"/></a><div class="content"><a class="title" href="/2023/11/03/ROS/" title="ROS基础">ROS基础</a><time datetime="2023-11-02T16:00:00.000Z" title="Created 2023-11-03 00:00:00">2023-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/04/C++11/" title="C++11"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/ISO_C%2B%2B_Logo.svg/1200px-ISO_C%2B%2B_Logo.svg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++11"/></a><div class="content"><a class="title" href="/2023/07/04/C++11/" title="C++11">C++11</a><time datetime="2023-07-03T16:00:00.000Z" title="Created 2023-07-04 00:00:00">2023-07-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" title="Linux系统编程"><img src="https://file.rymooc.com/SuperLargeCover/200303ae51194686d43e" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux系统编程"/></a><div class="content"><a class="title" href="/2023/06/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" title="Linux系统编程">Linux系统编程</a><time datetime="2023-06-19T16:00:00.000Z" title="Created 2023-06-20 00:00:00">2023-06-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/11/C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="C++设计模式"><img src="https://picx.zhimg.com/v2-f7e5e75bb391e9c74762d9dbee97f807_720w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++设计模式"/></a><div class="content"><a class="title" href="/2023/05/11/C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="C++设计模式">C++设计模式</a><time datetime="2023-05-10T16:00:00.000Z" title="Created 2023-05-11 00:00:00">2023-05-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2025 By santidad DAY</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">welcome  to  my  <a  target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>