<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux网络编程 | DAY's Blog</title><meta name="keywords" content="Notes,DataBase"><meta name="author" content="santidad DAY"><meta name="copyright" content="santidad DAY"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="网络基础协议的概念什么是协议从应用角度出发，协议可理解为”规则”，是数据传输和数据解释的规则 假设A、B双方欲传输文件，规定：  第一次：传输文件名，接收方接受到的文件名应答OK给传输方 第二次：发送文件的尺寸，接收方接收到数据应答一个OK给传输方 第三次：传输文件内容，接收方接收到数据完成后应答OK表示文件内容接受成功  由此，无论A、B之间传递何种文件，都是通过三次数据传输来完成。A、B之间形">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux网络编程">
<meta property="og:url" content="https://santidadday.github.io/2023/12/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="DAY&#39;s Blog">
<meta property="og:description" content="网络基础协议的概念什么是协议从应用角度出发，协议可理解为”规则”，是数据传输和数据解释的规则 假设A、B双方欲传输文件，规定：  第一次：传输文件名，接收方接受到的文件名应答OK给传输方 第二次：发送文件的尺寸，接收方接收到数据应答一个OK给传输方 第三次：传输文件内容，接收方接收到数据完成后应答OK表示文件内容接受成功  由此，无论A、B之间传递何种文件，都是通过三次数据传输来完成。A、B之间形">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-11-30T16:00:00.000Z">
<meta property="article:modified_time" content="2023-12-01T09:38:19.417Z">
<meta property="article:author" content="santidad DAY">
<meta property="article:tag" content="Notes">
<meta property="article:tag" content="DataBase">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://santidadday.github.io/2023/12/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux网络编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-01 17:38:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/day.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">17</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">DAY's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Linux网络编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">Created</span><time datetime="2023-11-30T16:00:00.000Z" title="Created 2023-12-01 00:00:00">2023-12-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux网络编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><h3 id="协议的概念"><a href="#协议的概念" class="headerlink" title="协议的概念"></a>协议的概念</h3><h4 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h4><p>从应用角度出发，协议可理解为”规则”，是数据传输和数据解释的规则</p>
<p>假设A、B双方欲传输文件，规定：</p>
<ul>
<li>第一次：传输文件名，接收方接受到的文件名应答OK给传输方</li>
<li>第二次：发送文件的尺寸，接收方接收到数据应答一个OK给传输方</li>
<li>第三次：传输文件内容，接收方接收到数据完成后应答OK表示文件内容接受成功</li>
</ul>
<p>由此，无论A、B之间传递何种文件，都是通过三次数据传输来完成。A、B之间形成了一个最简单的数据传输规则。双方都按此规则发送、接收数据。A、B之间达成的这个相互遵守的规则即为协议</p>
<p>这种仅在A、B之间被遵守的协议称之为原始协议。当此协议被更多的人采用，不断地增加、改进、维护、完善，最终形成了一个稳定的、完整的文件传输协议，被广泛应用于各种文件传输过程中。该协议就成为了一个标准协议。最早的FTP协议就是由此衍生而来</p>
<p>TCP协议注重数据的传输，HTTP协议注重数据的解释</p>
<h4 id="典型协议"><a href="#典型协议" class="headerlink" title="典型协议"></a>典型协议</h4><p>应用层：HTTP、FTP、SSH、NFS、TELNET、</p>
<p>传输层：TCP、UDP</p>
<p>网络层：IP、ARP、ICMP、IGMP</p>
<p>TCP：传输控制协议（Transmisssion Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议</p>
<p>UDP：用户数据报协议（User Datagram Protocol）是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送协议</p>
<p>HTTP：超文本传输协议（Hyper Text Transfer Protocol）是互联网上应用最为广泛的一种网络协议</p>
<p>FTP：文本传输协议（File Transfer Protocol）</p>
<p>IP：因特网互联协议（Internet Protocol）</p>
<p>ICMP：因特网控制报文协议（Internet Control Message Protocol）是TCP&#x2F;IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息</p>
<p>IGMP：因特网组管理协议（Internet Group Management Protocol）是因特网协议家族的一个组播协议，运行在主机和组播路由器之间</p>
<p>ARP：正向地址解析协议（Address Resolution Protocol）通过已知IP地址寻找主机对应MAC地址</p>
<h3 id="网络应用程序设计模式"><a href="#网络应用程序设计模式" class="headerlink" title="网络应用程序设计模式"></a>网络应用程序设计模式</h3><p><strong>C&#x2F;S模式：</strong>传统的网络应用设计模式，客户机(client)&#x2F;服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信</p>
<p><strong>B&#x2F;S模式：</strong>浏览器(Browser)&#x2F;服务器(Server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输</p>
<p><strong>优缺点：</strong></p>
<ul>
<li>C&#x2F;S：<ul>
<li>优点：缓存数据，调高传输效率；协议选择灵活，可定制、剪裁；</li>
<li>缺点：开发工作量大；安全性差；不能跨平台</li>
</ul>
</li>
<li>B&#x2F;S：<ul>
<li>优点：开发工作量小；安全性强；跨平台</li>
<li>缺点：数据无法缓存；只能使用固定协议</li>
</ul>
</li>
</ul>
<h3 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h3><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><p>物理层：主要定义物理设备标准，如网线的接口类型、光线的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转化），这一层的数据叫做比特层</p>
<p>数据链路层：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。如：串口通信中使用到的115200、8、N、1</p>
<p>网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路由选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层</p>
<p>传输层：定义了一些传输数据的协议和端口号（WWW端口号80等）如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高、数据量大的数据），UDP（传输控制协议，传输效率高，可靠性弱，用于传输可靠性要求低、数据量小的数据）主要是将从下层接受的数据进行分段和传输，到达目的地址后再进行重组</p>
<p>会话层：通过传输层（端口号，传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要相互认识可以是IP也可以是MAC或者是主机名）</p>
<p>表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如：PC程序与另一台计算机进行通信，其中一台计算机使用扩展EBCDIC交换码，而另一台则使用美国信息交换标准码（ASCII）来表示相同字符。如果必要，表示层会通过使用一种通用格式来实验多种数据格式之间的转换</p>
<p>应用层：是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网路服务</p>
<h4 id="TCP-x2F-IP四层模型"><a href="#TCP-x2F-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h4><p>TCP&#x2F;IP网络协议栈分为应用层（Application）、传输层（Transport）、网络层（Network）和链路层（Link）四层</p>
<div align="center">
    <img src="/2023/12/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/TCP_IP模型.jpg" style="zoom: 70%" alt="TCP/IP模型">
</div>

<p>一般在应用开发过程中讨论最多的就是TCP&#x2F;IP模型</p>
<h3 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h3><p>两台计算机通过TCP&#x2F;IP协议通信的过程如下：</p>
<div align="center">
    <img src="/2023/12/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/TCP_IP通信过程.jpg" style="zoom: 50%" alt="TCP/IP通信过程">
</div>

<p>上图对应两台计算机在同一网段中的情况，如果两天计算机在不同的网段中，那么是数据从一台计算机到另一台计算机传输过程要经过一个或过个路由器</p>
<p>数据没有封装之前是不能在网络中传递</p>
<ul>
<li>链路层有以太网、令牌环网等标准，链路层负责网卡设备的驱动、帧同步（即从网线上检测到什么信号算作新帧的开始）、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。交换机是工作在链路层的网络设备，可以在不同的链路层网络之间转发数据帧（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间），由于不同链路层的帧格式不同，交换机要将进来的数据包拆掉链路层首部重新封装之后再转发</li>
<li>网络层的IP协议是构成Internet的基础。Internet上的主机通过IP地址来标识，Inter-net上有大量路由器负责根据IP地址选择合适的路径转发数据包，数据包从Internet上的源主机到目的主机往往要经过十多个路由器。路由器是工作在第三层的网络设备，同时兼有交换机的功能，可以在不同的链路层接口之间转发数据包，因此路由器需要将进来的数据包拆掉网络层和链路层两层首部并重新封装。IP协议不保证传输的可靠性，数据包在传输过程中可能丢失，可靠性可以在上层协议或应用程序中提供支持</li>
<li>网络层负责点到点（ptop，point-to-point）的传输（这里的“点”指主机或路由器），而传输层负责端到端（etoe，end-to-end）的传输（这里的“端”指源主机和目的主机）。传输层可选择TCP或UDP协议</li>
<li>TCP是一种面向连接的、可靠的协议，有点像打电话，双方拿起电话互通身份之后就建立了连接，然后说话就行了，这边说的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。也就是说TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接</li>
<li>UDP是无连接的传输协议，不保证可靠性，有点像寄信，信写好放到邮筒里，既不能保证信件在邮递过程中不会丢失，也不能保证信件寄送顺序。使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作</li>
</ul>
<h3 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a>协议格式</h3><h4 id="数据包封装"><a href="#数据包封装" class="headerlink" title="数据包封装"></a>数据包封装</h4><p>传输层及其以下的机制由内核提供，应用层由用户进程提供（后面将介绍如何使用socket API编写应用程序），应用程序对通讯数据的含义进行解释，而传输层及其以下处理通讯的细节，将数据从一台计算机通过一定的路径发送到另一台计算机。应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部（header），称为封装（Encapsulation）</p>
<p>不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）。数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理</p>
<h4 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h4><p>以太网帧中的数据长度规定最小46字节，最大1500字节，ARP和RARP数据包的长度不够46字节，要在后面补填充位。最大值1500称为以太网的最大传输单元（MTU），不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU，则需要对数据包进行分片（fragmentation）</p>
<h4 id="ARP数据报格式"><a href="#ARP数据报格式" class="headerlink" title="ARP数据报格式"></a>ARP数据报格式</h4><p>ARP协议是根据IP地址获取MAC地址</p>
<p>在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须获得目的主机的硬件地址。ARP协议就起到这个作用。源主机发出ARP请求，询问“IP地址是192.168.0.1的主机的硬件地址是多少”，并将这个请求广播到本地网段（以太网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播），目的主机接收到广播的ARP请求，发现其中的IP地址与本机相符，则发送一个ARP应答数据包给源主机，将自己的硬件地址填写在应答包中</p>
<p>每台主机都维护一个ARP缓存表，可以用arp -a命令查看。缓存表中的表项有过期时间（一般为20分钟），如果20分钟内没有再次使用某个表项，则该表项失效，下次还要发ARP请求来获得目的主机的硬件地址</p>
<h4 id="IP段格式"><a href="#IP段格式" class="headerlink" title="IP段格式"></a>IP段格式</h4><p>IP数据报的首部长度和数据长度都是可变长的，但总是4字节的整数倍。对于IPv4，4位版本字段是4。4位首部长度的数值是以4字节为单位的，最小值为5，也就是说首部长度最小是4x5&#x3D;20字节，也就是不带任何选项的IP首部，4位能表示的最大值是15，也就是说首部长度最大是60字节。8位TOS字段有3个位用来指定IP数据报的优先级（目前已经废弃不用），还有4个位表示可选的服务类型（最小延迟、最大吐量、最大可靠性、最小成本），还有一个位总是0。总长度是整个数据报（包括IP首部和IP层payload）的字节数。每传一个IP数据报，16位的标识加1，可用于分片和重新组装数据报。3位标志和13位片偏移用于分片。TTL（Time to live)是这样用的：源主机为数据包设定一个生存时间，比如64，每过一个路由器就把该值减1，如果减到0就表示路由已经太长了仍然找不到目的主机的网络，就丢弃该包，因此这个生存时间的单位不是秒，而是跳（hop）。协议字段指示上层协议是TCP、UDP、ICMP还是IGMP。然后是校验和，只校验IP首部，数据的校验由更高层协议负责。IPv4的IP地址长度为32位</p>
<h4 id="UDP数据报格式"><a href="#UDP数据报格式" class="headerlink" title="UDP数据报格式"></a>UDP数据报格式</h4><p>般的网络通信都是像TFTP协议这样，通信的双方分别是客户端和服务器，客户端主动发起请求（上面的例子就是客户端发起的请求帧），而服务器被动地等待、接收和应答请求。客户端的IP地址和端口号唯一标识了该主机上的TFTP客户端进程，服务器的IP地址和端口号唯一标识了该主机上的TFTP服务进程，由于客户端是主动发起请求的一方，它必须知道服务器的IP地址和TFTP服务进程的端口号，所以，一些常见的网络协议有默认的服务器端口，例如HTTP服务默认TCP协议的80端口，FTP服务默认TCP协议的21端口，TFTP服务默认UDP协议的69端口（如上例所示）。在使用客户端程序时，必须指定服务器的主机名或IP地址，如果不明确指定端口号则采用默认端口，请读者查阅ftp、tftp等程序的man page了解如何指定端口号。&#x2F;etc&#x2F;services中列出了所有well-known的服务端口和对应的传输层协议，这是由IANA（Internet Assigned Numbers Authority）规定的，其中有些服务既可以用TCP也可以用UDP，为了清晰，IANA规定这样的服务采用相同的TCP或UDP默认端口号，而另外一些TCP和UDP的相同端口号却对应不同的服务</p>
<p>使用UDP协议的应用程序必须考虑到这些可能的问题并实现适当的解决方案，例如等待应答、超时重发、为数据包编号、流量控制等。一般使用UDP协议的应用程序实现都比较简单，只是发送一些对可靠性要求不高的消息，而不发送大量的数据。例如，基于UDP的TFTP协议一般只用于传送小文件（所以才叫trivial的ftp），而基于TCP的FTP协议适用于	各种文件的传输</p>
<h4 id="TCP数据报格式"><a href="#TCP数据报格式" class="headerlink" title="TCP数据报格式"></a>TCP数据报格式</h4><p>与UDP协议一样也有源端口号和目的端口号，通讯的双方由IP地址和端口号标识。32位序号、32位确认序号、窗口大小稍后详细解释。4位首部长度和IP协议头类似，表示TCP协议头的长度，以4字节为单位，因此TCP协议头最长可以是4x15&#x3D;60字节，如果没有选项字段，TCP协议头最短20字节。URG、ACK、PSH、RST、SYN、FIN是六个控制位，本节稍后将解释SYN、ACK、FIN、RST四个位，其它位的解释从略。16位检验和将TCP协议头和数据都计算在内</p>
<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><h4 id="TCP通信时序"><a href="#TCP通信时序" class="headerlink" title="TCP通信时序"></a>TCP通信时序</h4><p>建立连接（三次握手）的过程：</p>
<ul>
<li>客户端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的段1。客户端发出段1，SYN位表示连接请求。序号是1000，这个序号在网络通讯中用作临时的地址，每发一个数据字节，这个序号要加1，这样在接收端可以根据序号排出数据包的正确顺序，也可以发现丢包的情况，另外，规定SYN位和FIN位也要占一个序号，这次虽然没发数据，但是由于发了SYN位，因此下次再发送应该用序号1001。mss表示最大段尺寸，如果一个段太大，封装成帧后超过了链路层的最大帧长度，就必须在IP层分片，为了避免这种情况，客户端声明自己的最大段尺寸，建议服务器端发来的段不要超过这个长度</li>
<li>服务器端回应客户端，是三次握手中的第2个报文段，同时带ACK标志和SYN标志。它表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯。服务器发出段2，也带有SYN位，同时置ACK位表示确认，确认序号是1001，表示“我接收到序号1000及其以前所有的段，请你下次发送序号为1001的段”，也就是应答了客户端的连接请求，同时也给客户端发出一个连接请求，同时声明最大尺寸为1024</li>
<li>客户必须再次回应服务器端一个ACK报文，这是报文段3。客户端发出段3，对服务器的连接请求进行应答，确认序号是8001。在这个过程中，客户端和服务器分别给对方发了连接请求，也应答了对方的连接请求，其中服务器的请求和应答在一个段中发出，因此一共有三个段用于建立连接，称为”三方握手（three-way-handshake）”。在建立连接的同时，双方协商了一些信息，例如双方发送序号的初始值、最大段尺寸等</li>
</ul>
<p>关闭连接（四次握手）的过程：</p>
<p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭</p>
<ul>
<li>客户端发出段7，FIN位表示关闭连接的请求</li>
<li>服务器发出段8，应答客户端的关闭连接请求</li>
<li>服务器发出段9，其中也包含FIN位，向客户端发送关闭连接请求</li>
<li>客户端发出段10，应答服务器的关闭连接请求</li>
</ul>
<h4 id="TCP状态转换"><a href="#TCP状态转换" class="headerlink" title="TCP状态转换"></a>TCP状态转换</h4><div align="center">
    <img src="/2023/12/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/TCP状态转换.jpg" style="zoom: 70%" alt="TCP状态转换">
</div>

<h2 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h2><h3 id="套接字概念"><a href="#套接字概念" class="headerlink" title="套接字概念"></a>套接字概念</h3><p>Socket本身有”插座”的意思，在Linux环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件</p>
<p>既然是文件，那么理所应当的可以使用文件描述符引用套接字。与管道类似，Linux系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递</p>
<p>套接字的内核实现较为复杂</p>
<p>在TCP&#x2F;IP协议中，”IP地址+TCP或UDP端口号”唯一标识网络通信中的一个进程。”IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用socket来描述网络连接的一对一关系</p>
<p>在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应对端的接受缓冲区</p>
<p>TCP&#x2F;IP协议最早在BSD UNIX上实现，为TCP&#x2F;IP协议设计的应用层编程接口称为socket API</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h4 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h4><p>我们知道，内存中的多字节数据相对于内存地址有大端和小端之分，磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分。网络数据流同样有大端小端之分，那么如何定义网络数据流的地址？发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出，接收主机把从网络上接到的字节依次保存在接收缓冲区中，也是按内存地址从低到高的顺序保存。因此，网络数据流的地址应规定：先发出的数据是低地址，后发出的数据是高地址</p>
<ul>
<li>小端法（pc本地存储）：高位存高地址，低位存低地址</li>
<li>大端法（网络存储）：高位存低地址，低位存高地址</li>
</ul>
<p>网络字节序和主机字节序转换函数：</p>
<ul>
<li><code>uint32_t htonl(uint32_t hostlong);</code></li>
<li><code>uint16_t htons(uint16_t hostshort);</code></li>
<li><code>uint32_t ntohl(uint32_t netlong);</code></li>
<li><code>uint16_t ntohs(uint16_t netshort);</code></li>
</ul>
<h4 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;	<span class="comment">// 本地字节序转化为网络字节序</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;	<span class="comment">// 网络字节序转换为本地字节序</span></span><br></pre></td></tr></table></figure>

<p>支持IPv4和IPv6：af（AF_INET、AF_INET6）</p>
<h4 id="sockaddr数据结构"><a href="#sockaddr数据结构" class="headerlink" title="sockaddr数据结构"></a>sockaddr数据结构</h4><p>struct sockaddr很多网络编程函数诞生早于IPv4，那时候都是用的是sockaddr结构体，为了向前兼容，现在sockaddr退化成<code>(void *)</code>的作用，传递一个地址给函数，至于这个函数是sockaddr_in还是sockaddr_in6由地址族确定，然后函数内部再强制类型转化为所需的地址类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sa_family; 		<span class="comment">/* address family, AF_xxx */</span></span><br><span class="line">	<span class="type">char</span> sa_data[<span class="number">14</span>];			<span class="comment">/* 14 bytes of protocol address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">	<span class="type">__kernel_sa_family_t</span> sin_family; 			<span class="comment">/* Address family */</span>  	地址结构类型</span><br><span class="line">	__be16 sin_port;					 		<span class="comment">/* Port number */</span>		端口号</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>					<span class="comment">/* Internet address */</span>	IP地址</span><br><span class="line">	<span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> __pad[__SOCK_SIZE__ - <span class="keyword">sizeof</span>(<span class="type">short</span> <span class="type">int</span>) -</span><br><span class="line">	<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span>) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span>						<span class="comment">/* Internet address. */</span></span><br><span class="line">	__be32 s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> sin6_family; 		<span class="comment">/* AF_INET6 */</span></span><br><span class="line">	__be16 sin6_port; 					<span class="comment">/* Transport layer port # */</span></span><br><span class="line">	__be32 sin6_flowinfo; 				<span class="comment">/* IPv6 flow information */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>			<span class="comment">/* IPv6 address */</span></span><br><span class="line">	__u32 sin6_scope_id; 				<span class="comment">/* scope id (new in RFC2553) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__u8 u6_addr8[<span class="number">16</span>];</span><br><span class="line">		__be16 u6_addr16[<span class="number">8</span>];</span><br><span class="line">		__be32 u6_addr32[<span class="number">4</span>];</span><br><span class="line">	&#125; in6_u;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> s6_addr 		in6_u.u6_addr8</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> s6_addr16 		in6_u.u6_addr16</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> s6_addr32	 	in6_u.u6_addr32</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNIX_PATH_MAX 108</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">	<span class="type">__kernel_sa_family_t</span> sun_family; 	<span class="comment">/* AF_UNIX */</span></span><br><span class="line">	<span class="type">char</span> sun_path[UNIX_PATH_MAX]; 	<span class="comment">/* pathname */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="网络套接字函数"><a href="#网络套接字函数" class="headerlink" title="网络套接字函数"></a>网络套接字函数</h3><h4 id="socket模型创建流程图"><a href="#socket模型创建流程图" class="headerlink" title="socket模型创建流程图"></a>socket模型创建流程图</h4><div align="center">
    <img src="/2023/12/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/socket API.jpg" style="zoom: 40%" alt="socket API">
</div>

<ul>
<li><code>bind()</code>：向套接字绑定IP地址和端口号</li>
<li><code>listen()</code>：设置监听上限</li>
<li><code>accept()</code>：阻塞监听客户端连接</li>
</ul>
<h4 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>domain：AF_INET、AF_INET6、AF_UNIX</p>
</li>
<li><p>type：SOCK_STREAM（流式TCP）、SOCK_DGRAM（报式UDP）</p>
</li>
<li><p>protocol：0（自动选择type对应的典型协议）</p>
</li>
</ul>
<p>返回值：成功（新套接字对应的文件描述符）、失败（-1 errno）</p>
<h4 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>sockfd：socket函数返回值</p>
</li>
<li><p>addr：<code>(struct sockaddr *)&amp;addr;</code></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line">addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"><span class="comment">// 传入(struct sockaddr *)&amp;addr;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>addrlen：<code>sizeof(addr)</code>地址结构大小</p>
</li>
</ul>
<p>返回值：成功（0）、失败（-1 errno）</p>
<h4 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;	<span class="comment">// 设置同时与服务器建立连接的上线数(同时进行三次握手的客户端数量)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>sockfd：socket函数返回值</li>
<li>backlog：上限数值</li>
</ul>
<p>返回值：成功（0）、失败（-1 errno）</p>
<h4 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> 		<span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;	<span class="comment">// 阻塞等待客户端建立连接，成功返回一个与客户端成功连接的socket文件描述符</span></span><br></pre></td></tr></table></figure>

<ul>
<li>sockfd：socket函数返回值</li>
<li>addr：传出参数，成功与服务器建立连接的那个客户端的地址结构（IP+port）</li>
<li>addrlen：传入传出，传入addr大小，传出客户端addr实际大小</li>
</ul>
<p>返回值：成功（能与服务器进行数据通信的socket文件描述符）、失败（-1 errno）</p>
<h4 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> 					<span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;	<span class="comment">// 使用现有的socket与服务器建立连接</span></span><br></pre></td></tr></table></figure>

<ul>
<li>sockfd：socket函数返回值</li>
<li>addr：传入参数，服务器的地址结构</li>
<li>addrlen：服务器地址结构的大小</li>
</ul>
<p>返回值：成功（0）、失败（-1 errno）</p>
<p>如果不使用bind绑定客户端地址结构，采用”隐式绑定”</p>
<h3 id="C-x2F-S模型"><a href="#C-x2F-S模型" class="headerlink" title="C&#x2F;S模型"></a>C&#x2F;S模型</h3><h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//server:</span></span><br><span class="line"><span class="comment">//    socket()    创建socket</span></span><br><span class="line"><span class="comment">//    bind()      绑定服务器地址结构</span></span><br><span class="line"><span class="comment">//    listen()    设置监听上限</span></span><br><span class="line"><span class="comment">//    accept()    阻塞监听客户端连接</span></span><br><span class="line"><span class="comment">//    read(fd)    读socket获取客户端数据</span></span><br><span class="line"><span class="comment">//    大小写转换</span></span><br><span class="line"><span class="comment">//    write(fd)</span></span><br><span class="line"><span class="comment">//    close()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> lfd = <span class="number">0</span>, cfd = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ], clientIP[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>, <span class="title">clientAddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> clientAddrLen;</span><br><span class="line"></span><br><span class="line">    serverAddr.sin_family = AF_INET;</span><br><span class="line">    serverAddr.sin_port = htons(SERVER_PORT);</span><br><span class="line">    serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// socket</span></span><br><span class="line">    lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        sys_err(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bind</span></span><br><span class="line">    <span class="type">int</span> errno = bind(lfd, (<span class="keyword">struct</span> sockaddr *) &amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr));</span><br><span class="line">    <span class="keyword">if</span> (errno == <span class="number">-1</span>) &#123;</span><br><span class="line">        sys_err(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen</span></span><br><span class="line">    errno = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (errno == <span class="number">-1</span>) &#123;</span><br><span class="line">        sys_err(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clientAddrLen = <span class="keyword">sizeof</span>(clientAddr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// accept</span></span><br><span class="line">        cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *) &amp;clientAddr, &amp;clientAddrLen);</span><br><span class="line">        <span class="keyword">if</span> (cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">            sys_err(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            close(cfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        write(cfd, buf, ret);</span><br><span class="line">        write(STDOUT_FILENO, buf, ret);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;server start ...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// io_service对象</span></span><br><span class="line">    boost::asio::io_service ios;</span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    boost::asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(ios, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), <span class="number">8888</span>))</span></span>;</span><br><span class="line">    <span class="comment">// socket对象</span></span><br><span class="line">    boost::asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ios)</span></span>;</span><br><span class="line">    <span class="comment">// 阻塞等待socket连接</span></span><br><span class="line">    acceptor.<span class="built_in">accept</span>(sock);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> msgFromClient[BUFSIZ];</span><br><span class="line">    <span class="type">char</span> msgToClient[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        boost::asio::<span class="built_in">read</span>(sock, boost::asio::<span class="built_in">buffer</span>(msgFromClient));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;client: &quot;</span> &lt;&lt; sock.<span class="built_in">remote_endpoint</span>().<span class="built_in">address</span>() &lt;&lt; <span class="string">&quot;; msgFromClient: &quot;</span> &lt;&lt; msgFromClient &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        std::string tmp = std::<span class="built_in">string</span>(msgFromClient);</span><br><span class="line">        std::<span class="built_in">transform</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), tmp.<span class="built_in">begin</span>(), ::toupper);</span><br><span class="line">        <span class="built_in">strcpy</span>(msgToClient, tmp.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">        boost::asio::<span class="built_in">write</span>(sock, boost::asio::<span class="built_in">buffer</span>(msgToClient));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;msgToClient: &quot;</span> &lt;&lt; msgToClient &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="client"><a href="#client" class="headerlink" title="client"></a>client</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//client:</span></span><br><span class="line"><span class="comment">//    socket()    创建socket</span></span><br><span class="line"><span class="comment">//    connect()   与服务器建立连接</span></span><br><span class="line"><span class="comment">//    write()     写数据到socket</span></span><br><span class="line"><span class="comment">//    read()      读转换后的数据</span></span><br><span class="line"><span class="comment">//    显示结果</span></span><br><span class="line"><span class="comment">//    close()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> cfd;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>;</span></span><br><span class="line"></span><br><span class="line">    serverAddr.sin_family = AF_INET;</span><br><span class="line">    serverAddr.sin_port = htons(SERVER_PORT);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serverAddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    cfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        sys_err(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> errno = connect(cfd, (<span class="keyword">struct</span> sockaddr *)&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr));</span><br><span class="line">    <span class="keyword">if</span>(errno == <span class="number">-1</span>) &#123;</span><br><span class="line">        sys_err(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(count--) &#123;</span><br><span class="line">        write(cfd, <span class="string">&quot;hello\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="type">int</span> ret = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(STDOUT_FILENO, buf, ret);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;client start ...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// io_service对象</span></span><br><span class="line">    boost::asio::io_service ios;</span><br><span class="line">    <span class="comment">// socket对象</span></span><br><span class="line">    boost::asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ios)</span></span>;</span><br><span class="line">    <span class="comment">// 创建连接端</span></span><br><span class="line">    boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(boost::asio::ip::address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8888</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    sock.<span class="built_in">connect</span>(ep);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> msgFromServer[BUFSIZ];</span><br><span class="line">    <span class="type">char</span> msgToServer[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        std::<span class="built_in">memset</span>(msgToServer, <span class="number">0x00</span>, <span class="built_in">sizeof</span>(msgToServer));</span><br><span class="line">        std::<span class="built_in">memset</span>(msgFromServer, <span class="number">0x00</span>, <span class="built_in">sizeof</span>(msgFromServer));</span><br><span class="line">        std::string tmp = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">strcpy</span>(msgToServer, tmp.<span class="built_in">c_str</span>());</span><br><span class="line">        boost::asio::<span class="built_in">write</span>(sock, boost::asio::<span class="built_in">buffer</span>(msgToServer));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;client to server: &quot;</span> &lt;&lt; msgToServer &lt;&lt; std::endl;</span><br><span class="line">        boost::asio::<span class="built_in">read</span>(sock, boost::asio::<span class="built_in">buffer</span>(msgFromServer));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;client from server: &quot;</span> &lt;&lt; msgFromServer &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高并发服务器"><a href="#高并发服务器" class="headerlink" title="高并发服务器"></a>高并发服务器</h2><div align="center">
    <img src="/2023/12/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/高并发服务器.jpg" style="zoom: 100%" alt="高并发服务器">
</div>

<h3 id="多进程并发服务器"><a href="#多进程并发服务器" class="headerlink" title="多进程并发服务器"></a>多进程并发服务器</h3><p>使用多进程并发服务器时需要考虑一下几点：</p>
<ul>
<li>父进程最大文件描述符个数（父进程中需要close关闭accept返回的新文件描述符）</li>
<li>系统内创建进程个数（与内存大小相关）</li>
<li>进程创建过多是否降低整体服务性能（进程调度）</li>
</ul>
<h4 id="server-x2F-client"><a href="#server-x2F-client" class="headerlink" title="server&#x2F;client"></a>server&#x2F;client</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//server:</span></span><br><span class="line"><span class="comment">//    socket()    创建socket</span></span><br><span class="line"><span class="comment">//    bind()      绑定服务器地址结构</span></span><br><span class="line"><span class="comment">//    listen()    设置监听上限</span></span><br><span class="line"><span class="comment">//    accept()    阻塞监听客户端连接</span></span><br><span class="line"><span class="comment">//    read(fd)    读socket获取客户端数据</span></span><br><span class="line"><span class="comment">//    大小写转换</span></span><br><span class="line"><span class="comment">//    write(fd)</span></span><br><span class="line"><span class="comment">//    close()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 9999</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">catch_child</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">0</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> lfd = <span class="number">0</span>, cfd = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ], clientIP[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>, <span class="title">clientAddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> clientAddrLen;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    serverAddr.sin_family = AF_INET;</span><br><span class="line">    serverAddr.sin_port = htons(SERVER_PORT);</span><br><span class="line">    serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// socket</span></span><br><span class="line">    lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        sys_err(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bind</span></span><br><span class="line">    <span class="type">int</span> errno = bind(lfd, (<span class="keyword">struct</span> sockaddr *) &amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr));</span><br><span class="line">    <span class="keyword">if</span> (errno == <span class="number">-1</span>) &#123;</span><br><span class="line">        sys_err(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen</span></span><br><span class="line">    errno = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (errno == <span class="number">-1</span>) &#123;</span><br><span class="line">        sys_err(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clientAddrLen = <span class="keyword">sizeof</span>(clientAddr);</span><br><span class="line">    <span class="comment">// write/read</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// accept</span></span><br><span class="line">        cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *) &amp;clientAddr, &amp;clientAddrLen);</span><br><span class="line">        <span class="keyword">if</span> (cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">            sys_err(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sys_err(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程</span></span><br><span class="line">            close(lfd);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                ret = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    close(cfd);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line">                    buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                write(cfd, buf, ret);</span><br><span class="line">                write(STDOUT_FILENO, buf, ret);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 父进程</span></span><br><span class="line">            close(cfd);</span><br><span class="line">            <span class="comment">// 回收子进程</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">            act.sa_handler = catch_child;</span><br><span class="line">            sigemptyset(&amp;act.sa_mask);</span><br><span class="line">            act.sa_flags = <span class="number">0</span>;</span><br><span class="line">            ret = sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">                sys_err(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多线程并发服务器"><a href="#多线程并发服务器" class="headerlink" title="多线程并发服务器"></a>多线程并发服务器</h3><p>使用多线程并发服务器时需要考虑一下几点：</p>
<ul>
<li>调整进程内最大文件描述符上限</li>
<li>线程如有共享数据，考虑线程同步</li>
<li>服务于客户端线程退出时，退出处理（退出处理，分离态）</li>
<li>系统负载，随着链接2客户端增加，导致其他线程不能及时得到CPU</li>
</ul>
<h4 id="server-1"><a href="#server-1" class="headerlink" title="server"></a>server</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">session</span><span class="params">(boost::asio::ip::tcp::socket socket)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        <span class="type">char</span> msgFromClient[BUFSIZ];</span><br><span class="line">        <span class="comment">// 回传数据</span></span><br><span class="line">        <span class="type">char</span> msgToClient[BUFSIZ];</span><br><span class="line">        boost::system::error_code error;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">size_t</span> len = socket.<span class="built_in">read_some</span>(boost::asio::<span class="built_in">buffer</span>(msgFromClient), error);</span><br><span class="line">            <span class="keyword">if</span> (error == boost::asio::error::eof) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;client: &quot;</span> &lt;&lt; socket.<span class="built_in">remote_endpoint</span>().<span class="built_in">address</span>() &lt;&lt; <span class="string">&quot;; msgFromClient: &quot;</span> &lt;&lt; msgFromClient</span><br><span class="line">                      &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            std::string tmp = std::<span class="built_in">string</span>(msgFromClient);</span><br><span class="line">            std::<span class="built_in">transform</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), tmp.<span class="built_in">begin</span>(), ::toupper);</span><br><span class="line">            <span class="built_in">strcpy</span>(msgToClient, tmp.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">            boost::asio::<span class="built_in">write</span>(socket, boost::asio::<span class="built_in">buffer</span>(msgToClient, len));</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;msgToClient: &quot;</span> &lt;&lt; msgToClient &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception in session: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boost::asio::io_context io_context;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个TCP端点并侦听端口 8000</span></span><br><span class="line">        boost::asio::ip::tcp::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), <span class="number">8000</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 接受客户端连接</span></span><br><span class="line">            boost::asio::ip::tcp::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">            acceptor.<span class="built_in">accept</span>(socket);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建一个新的会话</span></span><br><span class="line">            std::<span class="built_in">thread</span>(session, std::<span class="built_in">move</span>(socket)).<span class="built_in">detach</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception in server: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="client-1"><a href="#client-1" class="headerlink" title="client"></a>client</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boost::asio::io_context io_context;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接到服务器</span></span><br><span class="line">        boost::asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">        socket.<span class="built_in">connect</span>(tcp::<span class="built_in">endpoint</span>(boost::asio::ip::address::<span class="built_in">from_string</span>(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息并接收回显</span></span><br><span class="line">        <span class="type">char</span> msgToServer[BUFSIZ];</span><br><span class="line">        <span class="type">char</span> msgFromServer[BUFSIZ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            std::<span class="built_in">memset</span>(msgToServer, <span class="number">0x00</span>, <span class="built_in">sizeof</span>(msgToServer));</span><br><span class="line">            std::<span class="built_in">memset</span>(msgFromServer, <span class="number">0x00</span>, <span class="built_in">sizeof</span>(msgFromServer));</span><br><span class="line">            std::string tmp = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">strcpy</span>(msgToServer, tmp.<span class="built_in">c_str</span>());</span><br><span class="line">            boost::asio::<span class="built_in">write</span>(socket, boost::asio::<span class="built_in">buffer</span>(msgToServer));</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;client to server: &quot;</span> &lt;&lt; msgToServer &lt;&lt; std::endl;</span><br><span class="line">            boost::asio::<span class="built_in">read</span>(socket, boost::asio::<span class="built_in">buffer</span>(msgFromServer));</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;client from server: &quot;</span> &lt;&lt; msgFromServer &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception in client: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多路I-x2F-O转接服务器"><a href="#多路I-x2F-O转接服务器" class="headerlink" title="多路I&#x2F;O转接服务器"></a>多路I&#x2F;O转接服务器</h3><p>多路IO转接服务器也叫做多任务IO服务器。该类服务器实现的主旨思想是，不再由应用程序自己监视客户端连接，取而代之由内核替应用程序监视文件</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>缺点：</p>
<ul>
<li>监听上限受文件描述符限制。最大1024</li>
<li>检测满足条件的fd，自己添加业务逻辑提高较小。提高了编码难度</li>
</ul>
<p>优点：</p>
<ul>
<li>跨平台</li>
</ul>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>缺点：</p>
<ul>
<li>不能跨平台，只能在Linux下使用</li>
<li>无法直接定位满足监听事件的文件描述符，编码难度较大</li>
</ul>
<p>优点：</p>
<ul>
<li>自带数据结构，可以将监听事件结合和返回事件集合分离</li>
<li>拓展监听上限，超出1024限制</li>
</ul>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll是Linux下多路复用IO接口select&#x2F;poll的增强版本，他能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要监听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被监听的文件描述符集，只要遍那些被内核IO时间异步唤醒而加入Ready队列的文件描述符集合就行</p>
<p>epoll除了提供select&#x2F;poll那种IO时间的电平触发（Level Triggered）外，还提供了边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait&#x2F;epoll_pwait的调用，提高应用程序效率</p>
<p>epoll函数原型：</p>
<ul>
<li><code>int epoll_create(int size);</code></li>
<li><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code></li>
<li><code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</code></li>
</ul>
<p>参数：</p>
<ul>
<li>size：创建的红黑树的监听节点数量（仅供内核参考）</li>
<li>epfd：epoll_create函数的返回值</li>
<li>op：对该监听红黑树所做的操作<ul>
<li>EPOLL_CTL_ADD：添加fd到监听红黑树</li>
<li>EPOLL_CTL_MOD：修改fd在监听红黑树上的监听事件</li>
<li>EPOPP_CTL_DEL：将一个fd从监听红黑树上摘下（取消监听）</li>
</ul>
</li>
<li>fd：待监听的fd</li>
<li>event：本质是struct epoll_event结构体地址<ul>
<li>events：EPOLLIN &#x2F; EPOLLOUT &#x2F; EPOLLERROR等</li>
<li>data：联合体（fd、ptr、uint32_t、uint64_t）</li>
</ul>
</li>
<li>events：传出参数，传出满足监听条件的fd结构体</li>
<li>maxevents：数组元素总个数</li>
<li>timeout：<ul>
<li><code>-1</code>：阻塞</li>
<li><code>0</code>：不阻塞</li>
<li><code>&gt;0</code>：超时时间（毫秒）</li>
</ul>
</li>
</ul>
<p>优点：高效，突破1024文件描述符</p>
<p>缺点：不能跨平台，Linux</p>
<h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><h4 id="ET模式"><a href="#ET模式" class="headerlink" title="ET模式"></a>ET模式</h4><p>ET模式即Edge Triggered工作模式，边缘触发模式</p>
<p>基于非阻塞文件语柄</p>
<p>只有当read或write返回EAGAIN（非阻塞读，暂时无数据）时才需要挂起、等待。但这并不是说每次read时都需要循环读，直到读产生一个EAGAIN才认为此事件处理完成，当read返回的读到的数据长度小于请求的数据长度时，就可以确定此时缓冲中已没有数据了，也就可以认为此事读事件已处理完成</p>
<h4 id="LT模式"><a href="#LT模式" class="headerlink" title="LT模式"></a>LT模式</h4><p>LT模式即Level Triggered工作模式，水平触发（默认采用模式）</p>
<p>与ET模式不同的是，以LT方式调用epoll接口的时候，它就相当于一个速度比较快的poll，无论后面的数据是否被使用</p>
<h4 id="LT与ET比较"><a href="#LT与ET比较" class="headerlink" title="LT与ET比较"></a>LT与ET比较</h4><p>LT是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式变成出错的可能性小一点。传统的select&#x2F;poll都是这种模型的代表</p>
<p>ET是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已准备就绪，并且不会再为那个文件描述符发送更多的就绪通知。请注意，如果一直不对这个fd作IO操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only-once）</p>
<p>ET和LT区别在于残留数据是否会进行调用</p>
<h3 id="epoll反应堆模型"><a href="#epoll反应堆模型" class="headerlink" title="epoll反应堆模型"></a>epoll反应堆模型</h3><p>epoll ET模式+非阻塞、轮询+void *ptr</p>
<p>在反应堆模型下：不但要监听cfd的读事件，还要监听cfd的写事件</p>
<h3 id="线程池模型"><a href="#线程池模型" class="headerlink" title="线程池模型"></a>线程池模型</h3><ul>
<li>预先创建阻塞于accept多线程，使用互斥锁上锁保护accept</li>
<li>预先创建多线程，由主线程调用accept</li>
</ul>
<div align="center">
    <img src="/2023/12/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/线程池.jpg" style="zoom: 50%" alt="线程池">
</div>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">threadpoll_t</span> &#123;</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> lock;			<span class="comment">// 用于锁住本结构体</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> thread_counter;	<span class="comment">// 记录忙状态线程个数的锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">pthread_cond_t</span> queue_not_full;	<span class="comment">// 当任务队列满时, 添加任务的线程阻塞, 等待此条件变量</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> queue_not_empty;	<span class="comment">// 任务队列里不为空时, 通知等待任务的线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">pthread_t</span> *threads;				<span class="comment">// 存放线程池中每个线程的tid, 数组</span></span><br><span class="line">    <span class="type">pthread_t</span> adjust_tid;			<span class="comment">// 存管理线程tid</span></span><br><span class="line">    <span class="type">threadpool_task_t</span> *task_queue;	<span class="comment">// 任务队列(数组首地址)</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> min_thr_num;		<span class="comment">// 线程池最小线程数</span></span><br><span class="line">    <span class="type">int</span> max_thr_num;		<span class="comment">// 线程池最大线程数</span></span><br><span class="line">    <span class="type">int</span> live_thr_num;		<span class="comment">// 当前存活线程个数</span></span><br><span class="line">    <span class="type">int</span> busy_thr_num;		<span class="comment">// 忙状态线程个数</span></span><br><span class="line">    <span class="type">int</span> wait_exit_thr_num;	<span class="comment">// 要销毁的线程个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> queue_front;		<span class="comment">// task_queue队头下标</span></span><br><span class="line">    <span class="type">int</span> queue_rear;			<span class="comment">// task_queue队尾下标</span></span><br><span class="line">    <span class="type">int</span> queue_size;			<span class="comment">// task_queue队中实际任务数</span></span><br><span class="line">    <span class="type">int</span> queue_max_size;		<span class="comment">// task_queue队列可容纳任务数上限</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> shutdown;			<span class="comment">// 标志位, 线程池使用状态, true或false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="UDP服务器"><a href="#UDP服务器" class="headerlink" title="UDP服务器"></a>UDP服务器</h3><p>传输层主要应用的协议模型有两种：一种是TCP协议，另一种则是UDP协议。TCP协议在网络通信中占主导地位，绝大多数的网络通信记住TCP协议完成数据传输。但UDP也是网络通信中不可或缺的重要通信手段</p>
<p>相较于TCP而言，UDP通信形式更像是发送短信。不需要在数据传输之前建立、维护连接。只专心获取数据就好。省去了三次握手的过程，通信速度可以大大提高，但与之伴随的通信的稳定性和正确率便得不到保证。因此，我们称UDP为”无连接的不可靠报文传递”</p>
<p>UDP的优点和不足：由于无需创建连接，所以UDP开销较小，数据传输速度快，实用性较强。多用于对实时性要求较高的通信场合。但也伴随这数据传输的不可靠，传输数据的正确率、传输顺序和流量都得不到控制和保证</p>
<p>与TCP类似的，UDP也有可能出现缓冲区被填满后，再接收数据时丢包的现象。由于它没有TCP滑动窗口的机制，通常采用如下两种方法解决：</p>
<ul>
<li>服务器应用层设计流量控制，控制发送数据速度</li>
<li>借助setsockopt函数改变接收缓冲区大小</li>
</ul>
<h3 id="C-x2F-S模型-UDP"><a href="#C-x2F-S模型-UDP" class="headerlink" title="C&#x2F;S模型-UDP"></a>C&#x2F;S模型-UDP</h3><h4 id="server-2"><a href="#server-2" class="headerlink" title="server"></a>server</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 启动UDP服务器</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;UDP Server Start...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 创建io上下文对象</span></span><br><span class="line">        boost::asio::io_context ioContext;</span><br><span class="line">        <span class="comment">// 创建UDP下的通信socket</span></span><br><span class="line">        boost::asio::ip::<span class="function">udp::socket <span class="title">serverSocket</span><span class="params">(ioContext, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), <span class="number">8000</span>))</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 用于接收和发送数据</span></span><br><span class="line">        	<span class="type">char</span> messageFromClient[BUFSIZ] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        	<span class="type">char</span> messageToClient[BUFSIZ] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="comment">// ep为保存的端口信息</span></span><br><span class="line">            boost::asio::ip::udp::endpoint ep;</span><br><span class="line">            <span class="comment">// ec为接收发送端发送信息时是否出错</span></span><br><span class="line">            boost::system::error_code ec;</span><br><span class="line">            serverSocket.<span class="built_in">receive_from</span>(boost::asio::<span class="built_in">buffer</span>(messageFromClient), ep, <span class="number">0</span>, ec);</span><br><span class="line">            <span class="keyword">if</span> (ec &amp;&amp; ec != boost::asio::error::message_size) &#123;</span><br><span class="line">                <span class="keyword">throw</span> boost::system::<span class="built_in">system_error</span>(ec);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将接收到的信息转化为大写</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; std::<span class="built_in">strlen</span>(messageFromClient); i++) &#123;</span><br><span class="line">                messageToClient[i] = (<span class="type">char</span>) <span class="built_in">toupper</span>(messageFromClient[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; messageToClient &lt;&lt; <span class="string">&quot; send to port: &quot;</span> &lt;&lt; ep.<span class="built_in">port</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 将转换后的信息通过保存的端口信息返回给客户端</span></span><br><span class="line">            serverSocket.<span class="built_in">send_to</span>(boost::asio::<span class="built_in">buffer</span>(messageToClient), ep);</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 将用于接收和发送数据的空间置空</span></span><br><span class="line">            <span class="built_in">memset</span>(messageToClient, <span class="string">&#x27;\0&#x27;</span>, BUFSIZ);</span><br><span class="line">            <span class="built_in">memset</span>(messageFromClient, <span class="string">&#x27;\0&#x27;</span>, BUFSIZ);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="client-2"><a href="#client-2" class="headerlink" title="client"></a>client</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 启动UDP客户端</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;UDP Client Start...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 创建io上下文对象</span></span><br><span class="line">        boost::asio::io_context ioContext;</span><br><span class="line">        <span class="comment">// 创建UDP下的通信socket</span></span><br><span class="line">        boost::asio::ip::<span class="function">udp::socket <span class="title">clientSocket</span><span class="params">(ioContext)</span></span>;</span><br><span class="line">		<span class="comment">// 打开套接字, 多用于UDP和ICMP</span></span><br><span class="line">        clientSocket.<span class="built_in">open</span>(boost::asio::ip::udp::<span class="built_in">v4</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于接收和发送数据</span></span><br><span class="line">        <span class="type">char</span> messageToServer[BUFSIZ] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">char</span> messageFromServer[BUFSIZ] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 从标准输入流输入message信息</span></span><br><span class="line">            std::cin &gt;&gt; messageToServer;</span><br><span class="line">            <span class="comment">// 将信息通过发送端口发送给服务器</span></span><br><span class="line">            clientSocket.<span class="built_in">send_to</span>(boost::asio::<span class="built_in">buffer</span>(messageToServer), boost::asio::ip::udp::<span class="built_in">endpoint</span>(boost::asio::ip::address::<span class="built_in">from_string</span>(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8000</span>));</span><br><span class="line">            boost::asio::ip::udp::endpoint ep;</span><br><span class="line">            clientSocket.<span class="built_in">receive_from</span>(boost::asio::<span class="built_in">buffer</span>(messageFromServer), ep);</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;recv from port: &quot;</span>  &lt;&lt; ep.<span class="built_in">port</span>() &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; messageFromServer &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memset</span>(messageToServer, <span class="string">&#x27;\0&#x27;</span>, BUFSIZ);</span><br><span class="line">            <span class="built_in">memset</span>(messageFromServer, <span class="string">&#x27;\0&#x27;</span>, BUFSIZ);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="asio库高级"><a href="#asio库高级" class="headerlink" title="asio库高级"></a>asio库高级</h3><h4 id="同步读写"><a href="#同步读写" class="headerlink" title="同步读写"></a>同步读写</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="comment">// 通过多线程实现并发</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大长度</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; socket_ptr;</span><br><span class="line">std::set&lt;std::shared_ptr&lt;std::thread&gt;&gt; thread_set;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建session函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session</span><span class="params">(socket_ptr socketPtr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        <span class="type">char</span> msgFromClient[MAX_LENGTH];</span><br><span class="line">        <span class="comment">// 回传数据</span></span><br><span class="line">        <span class="type">char</span> msgToClient[MAX_LENGTH];</span><br><span class="line">        boost::system::error_code ec;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(msgToClient, <span class="string">&#x27;\0&#x27;</span>, MAX_LENGTH);</span><br><span class="line">            <span class="built_in">memset</span>(msgFromClient, <span class="string">&#x27;\0&#x27;</span>, MAX_LENGTH);</span><br><span class="line"></span><br><span class="line">            socketPtr-&gt;<span class="built_in">read_some</span>(boost::asio::<span class="built_in">buffer</span>(msgFromClient, MAX_LENGTH), ec);</span><br><span class="line">            <span class="keyword">if</span> (ec == boost::asio::error::eof) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;connection closed by peer&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ec) &#123;</span><br><span class="line">                <span class="keyword">throw</span> boost::system::<span class="built_in">system_error</span>(ec);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;client: &quot;</span> &lt;&lt; socketPtr-&gt;<span class="built_in">remote_endpoint</span>().<span class="built_in">address</span>().<span class="built_in">to_string</span>() &lt;&lt; <span class="string">&quot;; msgFromClient: &quot;</span> &lt;&lt; msgFromClient &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            std::string tmp = std::<span class="built_in">string</span>(msgFromClient);</span><br><span class="line">            std::<span class="built_in">transform</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), tmp.<span class="built_in">begin</span>(), ::toupper);</span><br><span class="line">            <span class="built_in">strcpy</span>(msgToClient, tmp.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">            boost::asio::<span class="built_in">write</span>(*socketPtr, boost::asio::<span class="built_in">buffer</span>(msgToClient, MAX_LENGTH));</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;msgToClient: &quot;</span> &lt;&lt; msgToClient &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception in session: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server</span><span class="params">(boost::asio::io_context &amp;ioContext, <span class="type">unsigned</span> <span class="type">short</span> port)</span> </span>&#123;</span><br><span class="line">    boost::asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(ioContext, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port))</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">socket_ptr <span class="title">socketPtr</span><span class="params">(<span class="keyword">new</span> boost::asio::ip::tcp::socket(ioContext))</span></span>;</span><br><span class="line">        acceptor.<span class="built_in">accept</span>(*socketPtr);</span><br><span class="line">        <span class="keyword">auto</span> t = std::<span class="built_in">make_shared</span>&lt;std::thread&gt;(Session, socketPtr);</span><br><span class="line">        thread_set.<span class="built_in">insert</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boost::asio::io_context ioContext;</span><br><span class="line">        <span class="built_in">Server</span>(ioContext, <span class="number">8000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t: thread_set) &#123;</span><br><span class="line">            t-&gt;<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大长度</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建上下文服务ioContext</span></span><br><span class="line">        boost::asio::io_context ioContext;</span><br><span class="line">        <span class="comment">// 创建连接点endpoint</span></span><br><span class="line">        boost::asio::ip::<span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(boost::asio::ip::address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8000</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 创建socket</span></span><br><span class="line">        boost::asio::ip::<span class="function">tcp::socket <span class="title">clientSocket</span><span class="params">(ioContext)</span></span>;</span><br><span class="line">        <span class="comment">// 创建错误提示码</span></span><br><span class="line">        boost::system::error_code ec = boost::asio::error::host_not_found;</span><br><span class="line">        <span class="comment">// 连接服务器</span></span><br><span class="line">        clientSocket.<span class="built_in">connect</span>(endpoint, ec);</span><br><span class="line">        <span class="keyword">if</span> (ec) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;connect failed, code is &quot;</span> &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;error msg is &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> messageFromServer[MAX_LENGTH];</span><br><span class="line">        <span class="type">char</span> messageToServer[MAX_LENGTH];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(messageFromServer, <span class="string">&#x27;\0&#x27;</span>, MAX_LENGTH);</span><br><span class="line">            <span class="built_in">memset</span>(messageToServer, <span class="string">&#x27;\0&#x27;</span>, MAX_LENGTH);</span><br><span class="line"></span><br><span class="line">            std::cin &gt;&gt; messageToServer;</span><br><span class="line">            boost::asio::<span class="built_in">write</span>(clientSocket, boost::asio::<span class="built_in">buffer</span>(messageToServer, MAX_LENGTH));</span><br><span class="line"></span><br><span class="line">            boost::asio::<span class="built_in">read</span>(clientSocket, boost::asio::<span class="built_in">buffer</span>(messageFromServer, MAX_LENGTH));</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;message from server: &quot;</span> &lt;&lt; messageFromServer &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同步读写的缺陷在于读写时阻塞的，如果客户端对端不发送数据服务器的read操作是阻塞的，这将导致服务器处于阻塞等待状态</li>
<li>可以通过开辟新的线程为新生成的连接处理读写，但是一个进程开辟的线程是有限的，约为2048个线程，在Linux环境可以通过unlimit增加一个进程的线程数，但是线程过多也会导致切换消耗的时间片过多</li>
<li>该服务器和客户端为应答式，实际场景为全双工通信模式，发送和接收要独立分开</li>
<li>该服务器和客户端未考虑粘包处理</li>
</ul>
<h4 id="异步读写"><a href="#异步读写" class="headerlink" title="异步读写"></a>异步读写</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="comment">// Session.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SERVER_SESSION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_SESSION_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Session</span>(boost::asio::io_context &amp;ioContext) : _socket(ioContext) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boost::asio::ip::<span class="function">tcp::socket &amp;<span class="title">Socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;error, <span class="type">size_t</span> bytes_transrred)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;error)</span></span>;</span><br><span class="line"></span><br><span class="line">    boost::asio::ip::tcp::socket _socket;</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        max_length = <span class="number">1024</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span> _data[max_length];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Server</span>(boost::asio::io_context &amp;ioContext, <span class="type">short</span> port);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start_accept</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_accept</span><span class="params">(Session *new_session, <span class="type">const</span> boost::system::error_code &amp;error)</span></span>;</span><br><span class="line">    boost::asio::io_context &amp;_ioContext;</span><br><span class="line">    boost::asio::ip::tcp::acceptor _acceptor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//SERVER_SESSION_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Session.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Session.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);   <span class="comment">// 存储归零</span></span><br><span class="line">	<span class="comment">// 异步读函数</span></span><br><span class="line">	_socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length), std::<span class="built_in">bind</span>(&amp;Session::handle_read, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;error, <span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">		<span class="comment">// 读正常, echo</span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; std::endl;</span><br><span class="line">		boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_data, bytes_transferred), std::<span class="built_in">bind</span>(&amp;Session::handle_write, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 读出错, 存在多次析构隐患</span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;read error: &quot;</span> &lt;&lt; error.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;error)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">		<span class="comment">// 进行异步读事件</span></span><br><span class="line">		_socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length), std::<span class="built_in">bind</span>(&amp;Session::handle_read, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 写出错</span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;write error: &quot;</span> &lt;&lt; error.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Server::<span class="built_in">Server</span>(boost::asio::io_context &amp;ioContext, <span class="type">short</span> port) : _ioContext(ioContext), _acceptor(ioContext, boost::asio::ip::tcp::<span class="built_in">endpoint</span>(boost::asio::ip::tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Server start success, on port: &quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">start_accept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::start_accept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// new_session会创建一个session会话, 其中包含封装好的socket对象</span></span><br><span class="line">	Session *new_session = <span class="keyword">new</span> <span class="built_in">Session</span>(_ioContext);</span><br><span class="line">	_acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">Socket</span>(), std::<span class="built_in">bind</span>(&amp;Server::handle_accept, <span class="keyword">this</span>, new_session, std::placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::handle_accept</span><span class="params">(Session *new_session, <span class="type">const</span> boost::system::error_code &amp;error)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">		new_session-&gt;<span class="built_in">Start</span>();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">delete</span> new_session;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">start_accept</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Session.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boost::asio::io_context ioContext;</span><br><span class="line">        <span class="function">Server <span class="title">s</span><span class="params">(ioContext, <span class="number">8000</span>)</span></span>;</span><br><span class="line">        ioContext.<span class="built_in">run</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>该服务器的发送和接受以应答的方式交互，而并不能做到应用层随意发送的目的，也就是未做到完全的收发分离（全双工逻辑）</li>
<li>该服务器未处理粘包、序列化以及逻辑和收发线程解耦问题</li>
<li>该服务器存在二次析构风险</li>
</ul>
<h4 id="利用伪闭包延长生命周期"><a href="#利用伪闭包延长生命周期" class="headerlink" title="利用伪闭包延长生命周期"></a>利用伪闭包延长生命周期</h4><p>C++中没有闭包机制，在Golang中可以通过闭包机制延长变量的声明周期</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeferReturn</span><span class="params">()</span></span> (res <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        res++</span><br><span class="line">        log.Println(res)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上Go代码中，我们可以发现延时函数调用了外部的res变量，所以在延时函数没有结束之前res不会被释放，即使主函数已经结束也不会释放res</p>
<p>在C++中我们可以通过智能指针的引用计数方式传入函数对象，如果函数对象不被释放则智能指针不被释放</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Session.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SERVER_SESSION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_SESSION_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Session&gt; &#123;</span><br><span class="line">	<span class="comment">// 会话类, 用于接收发送数据</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Session</span>(boost::asio::io_context &amp;ioContext, Server *server) : _socket(ioContext), _server(server) &#123;</span><br><span class="line">		<span class="comment">// 构造函数, socket绑定ioc</span></span><br><span class="line">		boost::uuids::uuid a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line">		_uuid = boost::uuids::<span class="built_in">to_string</span>(a_uuid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	boost::asio::ip::<span class="function">tcp::socket &amp;<span class="title">Socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取当前socket变量</span></span><br><span class="line">		<span class="keyword">return</span> _socket;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;    <span class="comment">// 监听客户端的读和写</span></span><br><span class="line"></span><br><span class="line">	<span class="function">std::string &amp;<span class="title">GetUuid</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 回调函数是作为参数传递给另一个函数, 并在函数执行完毕后被调用</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;error, <span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;Session&gt; _self_shared)</span></span>;   <span class="comment">// 读回调函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;error, std::shared_ptr&lt;Session&gt; _self_shared)</span></span>;  <span class="comment">// 写回调函数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">enum</span> &#123;</span><br><span class="line">		max_length = <span class="number">1024</span>    <span class="comment">// 最大长度</span></span><br><span class="line">	&#125;;</span><br><span class="line">	boost::asio::ip::tcp::socket _socket;   <span class="comment">// 在服务端创建session类后, session需要管理一个tcp连接</span></span><br><span class="line">	<span class="type">char</span> _data[max_length]; <span class="comment">// 接收数据</span></span><br><span class="line">	Server *_server;</span><br><span class="line">	std::string _uuid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">	<span class="comment">// 服务类, 用于维护连接</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Server</span>(boost::asio::io_context &amp;ioContext, <span class="type">short</span> port);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ClearSession</span><span class="params">(std::string uuid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">start_accept</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">handle_accept</span><span class="params">(std::shared_ptr&lt;Session&gt; new_session, <span class="type">const</span> boost::system::error_code &amp;error)</span></span>;</span><br><span class="line"></span><br><span class="line">	boost::asio::io_context &amp;_ioContext;    <span class="comment">// ioContext不允许拷贝构造, 我们通过引用方式</span></span><br><span class="line">	boost::asio::ip::tcp::acceptor _acceptor;</span><br><span class="line">	std::map&lt;std::string, std::shared_ptr&lt;Session&gt;&gt; _sessions;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//SERVER_SESSION_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Session.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Session.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// brief: 用于开启服务器</span></span><br><span class="line"><span class="comment">// param: NULL</span></span><br><span class="line"><span class="comment">// ret: NULL</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);   <span class="comment">// 存储归零</span></span><br><span class="line">	<span class="comment">// 异步监听读事件, 并在接收到读事件后调用读回调函数, 将类的成员函数绑定为普通函数对象</span></span><br><span class="line">	_socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length), std::<span class="built_in">bind</span>(&amp;Session::handle_read, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">shared_from_this</span>()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string &amp;<span class="title">Session::GetUuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _uuid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// brief: 服务器的读回调函数, 用于读取异步上下文中的数据</span></span><br><span class="line"><span class="comment">// param: error: 在读取数据过程中的错误码</span></span><br><span class="line"><span class="comment">//		  bytes_transferred: 服务器实际读了多少数据</span></span><br><span class="line"><span class="comment">// ret: NULL</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;error, <span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;Session&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">		<span class="comment">// 读正常, echo</span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; std::endl;</span><br><span class="line">		<span class="comment">// 异步写事件, 将刚才收到的数据发回去, 绑定写回调函数</span></span><br><span class="line">		boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_data, bytes_transferred), std::<span class="built_in">bind</span>(&amp;Session::handle_write, <span class="keyword">this</span>, std::placeholders::_1, _self_shared));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 读出错, 存在多次析构隐患</span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;read error: &quot;</span> &lt;&lt; error.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">		_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// brief: 服务器的写回调函数, 用于像异步上下文中写入数据</span></span><br><span class="line"><span class="comment">// param: error: 在写入数据过程中的错误码</span></span><br><span class="line"><span class="comment">// ret: NULL</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;error, std::shared_ptr&lt;Session&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">		<span class="comment">// 数据清零</span></span><br><span class="line">		<span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">		<span class="comment">// 异步读事件, 并在接收到读事件后调用读回调函数</span></span><br><span class="line">		_socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length), std::<span class="built_in">bind</span>(&amp;Session::handle_read, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _self_shared));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 写出错</span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;write error: &quot;</span> &lt;&lt; error.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">		_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// brief: 用于创建并启动服务器</span></span><br><span class="line"><span class="comment">// param: ioContext: 上下文对象, 不允许拷贝构造在成员列表中为引用方式, 需要使用初始化列表方式赋值, 用于网络通信间的数据传递</span></span><br><span class="line"><span class="comment">//        port: 端口, 用于指定服务器启动的端口地址</span></span><br><span class="line"><span class="comment">// ret: NULL</span></span><br><span class="line">Server::<span class="built_in">Server</span>(boost::asio::io_context &amp;ioContext, <span class="type">short</span> port) : _ioContext(ioContext), _acceptor(ioContext, boost::asio::ip::tcp::<span class="built_in">endpoint</span>(boost::asio::ip::tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Server start success, on port: &quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">start_accept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// brief: 用于启动描述符</span></span><br><span class="line"><span class="comment">// param: NULL</span></span><br><span class="line"><span class="comment">// ret: NULL</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::start_accept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::shared_ptr&lt;Session&gt; new_session = std::<span class="built_in">make_shared</span>&lt;Session&gt;(_ioContext, <span class="keyword">this</span>);</span><br><span class="line">	<span class="comment">// new_session会创建一个session类对象, 其中包含封装好的socket对象</span></span><br><span class="line">	<span class="comment">// Session *new_session = new Session(_ioContext);</span></span><br><span class="line">	_acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">Socket</span>(), std::<span class="built_in">bind</span>(&amp;Server::handle_accept, <span class="keyword">this</span>, new_session, std::placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// brief: 回调函数, 当客户端需要连接时触发回调</span></span><br><span class="line"><span class="comment">// param: *new_session:</span></span><br><span class="line"><span class="comment">// 		  error: 捕获错误信息</span></span><br><span class="line"><span class="comment">// ret: NULL</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::handle_accept</span><span class="params">(std::shared_ptr&lt;Session&gt; new_session, <span class="type">const</span> boost::system::error_code &amp;error)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">		new_session-&gt;<span class="built_in">Start</span>();</span><br><span class="line">		_sessions.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(new_session-&gt;<span class="built_in">GetUuid</span>(), new_session));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// delete new_session;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">start_accept</span>();	<span class="comment">// 使Server接收新的连接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::ClearSession</span><span class="params">(std::string uuid)</span> </span>&#123;</span><br><span class="line">	_sessions.<span class="built_in">erase</span>(uuid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="增加发送队列实现全双工通信"><a href="#增加发送队列实现全双工通信" class="headerlink" title="增加发送队列实现全双工通信"></a>增加发送队列实现全双工通信</h4><p>异步发送过程中，TCP底层的发送缓冲区不能把我们的数据进行全部发送，在二次发送过程中会出现数据错乱。我们引入发送队列保证发送的时序性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设计一个数据节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">CSession</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MsgNode</span>(<span class="type">char</span> *msg, <span class="type">int</span> max_len) &#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[max_len];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_data, msg, max_len);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_cur_len;	<span class="comment">// 表示数据当前已处理的长度, 已发送的数据或已接收的数据长度</span></span><br><span class="line">    <span class="type">int</span> m_max_len;	<span class="comment">// 表示数据的总长度</span></span><br><span class="line">    <span class="type">char</span> *m_data;	<span class="comment">// 表示数据域, 已接收或已发送的数据都放在此空间内</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在企业级开发中，通常发送接口和回调函数的接口不在一个线程中，为了保证队列访问的安全性，我们需要为队列增加一个锁</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">char</span> *msg, <span class="type">int</span> max_length)</span></span>;</span><br><span class="line">std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; m_send_que;</span><br><span class="line">std::mutex m_send_lock;</span><br></pre></td></tr></table></figure>

<h4 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h4><p>粘包问题是服务器发送数据常遇到的一个现象，当客户端发送多个数据包服务器时，服务器底层的TCP接受缓冲区收到的数据为粘在一起的</p>
<p>因为TCP面向字节流传输的，TCP只保证发送数据的准确性和顺序性，字节流以自己为单位，客户端每次发送N个字节给服务端，N取决于当前客户端的发送缓冲区是否有数据，比如发送缓冲区总大小为10个字节，当前有5个字节数据未发完，那么此时只有5个字节空闲空间，我们再次调用发送接口时会出现上次数据与本次数据的粘连</p>
<p><strong>粘包原因：</strong></p>
<ul>
<li>客户端的发送频率远高于服务器的接受频率，就会导致数据在服务器的TCP接收缓冲区滞留形成粘连，比如客户端1s内连续发送了两个hello world!，服务器过了2s才接收数据，那一次性读出两个hello world!</li>
<li>TCP底层的安全和效率机制不允许字节数特别少的小包发送频率过高，TCP会在底层累计数据到一定大小一起发送，比如连续发送1字节的数据要累计到多个字节才发送，可以了解下TCP底层的Nagle算法</li>
<li>发送缓冲区有上次未发送完的数据或接受端的缓冲区里有未取出的数据导致数据粘连</li>
</ul>
<p><strong>处理粘包：</strong>处理粘包的方式主要采用应用层定义收发包格式的方式，这个过程俗称切包处理，常用的协议被称为tlv协议（消息id+消息长度+消息内容），我们简化为消息长度+消息内容</p>
<p><code>async_read_some</code>这个函数的特点是只要对端发数据，服务器就接受数据，即使没有收全对端发送的数据也会触发HandleRead函数，所以我们会在HandleRead回调函数里判断接受的自己数，接受的数据可能不满足头部长度，可能大于头部长度但小于消息体的长度，可能大于消息体的长度，还可能大于多个消息体的长度，所以要切包等，这些逻辑写起来复杂，所以我们可以通过读取指定字节数，直到读完这些字节才触发回调函数，那么可以采用<code>async_read</code>函数，这个函数指定读取字节数，只有读完才会触发回调函数</p>
<h4 id="字节序处理和消息队列的控制"><a href="#字节序处理和消息队列的控制" class="headerlink" title="字节序处理和消息队列的控制"></a>字节序处理和消息队列的控制</h4><p><strong>字节序问题：</strong></p>
<p>在计算机网络中，由于不同的计算机使用的CPU架构和字节序顺序可能不同，因此在传输数据时需要对数据的字节序进行统一，以保证数据能够正常传输和解析。这就是网路字节序的作用，具体来说，计算机内部存储的方式有两种：大端序（Big-Endian）和小端序（Little-Endian）。在大端序中，高位自己存储在低地址处，而低位字节存储在高地址处；在小端序中，高位自己存储在高地址处，而低位字节存储在低地址处。在网络通信中，通常使用大端序，这是因为早期的网络硬件大多采用了Motorda处理器，而Motorola处理器使用的是大端序。此外，大多数网络通信协议规定了网络字节序必须为大端序，因此，在进行网路编程时，需要将主机字节序转换为网络字节序，也就是将数据从本地字节序转化为大端序。可以使用htonl、htons、ntohl好ntohs等函数来实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断当前系统字节序时大端序还是小端序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBigEndian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">char</span> *)&amp;num == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前系统为小端序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前系统为大端序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了保证字节序一致性，网络传输使用网络字节序，也就是大端序模型</p>
<p>在boost::asio库中，可以使用<code>boost::asio::detail::socket_ops::host_to_network_long()</code>和<code>boost::asio::detail::socket_ops::host_to_network_short()</code>函数主机字节序转化为网络字节序</p>
<ul>
<li><code>host_to_network_long()</code>函数将一个32位无符号整数从主机字节序转化为网络字节</li>
<li><code>host_to_network_short()</code>函数将一个16位无符号整数从主机字节序转化为网络字节序</li>
</ul>
<h4 id="protobuf配置和使用"><a href="#protobuf配置和使用" class="headerlink" title="protobuf配置和使用"></a>protobuf配置和使用</h4><p><strong>protobuf简介：</strong>Protocol Buffers（简称protobuf）是一种轻便高效的序列化数据结构协议，有Google开发。它可以用于将结构化的数据序列化到二进制格式，并广泛用于数据存储、通信协议、配置文件等领域</p>
<p>我们的逻辑是有类等抽象的数据构成的，而TCP是面向字节流的，我们需要将类结构序列化为字符串来传输</p>
<p>gRPC是一个高性能、开源和通用的RPC框架，使用Protocol Buffers作为序列化协议。它可以在任何地方运行，并连接各种语言和平台。常被使用在服务端与服务端之间通信</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置为proto3版本</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Book</span> &#123;</span><br><span class="line">	<span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int32</span> pages = <span class="number">2</span>;</span><br><span class="line">	<span class="type">float</span> price = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在终端中执行：<code>protoc -cpp_out=. ./msg.proto</code>会生成msg.pb.h和msg.pb.cc两个文件，这两个文件就是我们要用到的头文件和cpp文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;msg.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Book book;</span><br><span class="line">    book.<span class="built_in">set_name</span>(<span class="string">&quot;CPP programing&quot;</span>);</span><br><span class="line">    book.<span class="built_in">set_pages</span>(<span class="number">100</span>);</span><br><span class="line">    std::string bookstr;</span><br><span class="line">    book.<span class="built_in">SerializeToString</span>(&amp;bookstr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;serialize str is &quot;</span> &lt;&lt; bookstr &lt;&lt; std::endl;</span><br><span class="line">    Book book2;</span><br><span class="line">    book2.<span class="built_in">ParseFromString</span>(bookstr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;book2 name is &quot;</span> &lt;&lt; book2.<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;price is &quot;</span> &lt;&lt; book2.<span class="built_in">price</span>() &lt;&lt; <span class="string">&quot;pages is &quot;</span> &lt;&lt; book2.<span class="built_in">pages</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="jsoncpp配置和使用"><a href="#jsoncpp配置和使用" class="headerlink" title="jsoncpp配置和使用"></a>jsoncpp配置和使用</h4><p><strong>jsoncpp简介：</strong>jsoncpp是一个C++JSON库，它提供了将JSON数据解析为C++，将C++对象序列化为JSON数据的功能，它支持所有主流操作系统（包括Windows、Linux、MacOS等），并且可以与常见编译器（包括Visual Studio、GCC等）兼容</p>
<p>jsoncpp库是以源代码形式发布的，因此使用者需要自己构建和链接库文件。该文件不依赖于第三方库，只需要包含头文件即可使用</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.25</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER g++)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_compile_options</span>(-std=c++<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">        /opt/homebrew/Cellar/jsoncpp/<span class="number">1.9</span>.<span class="number">5</span>/<span class="keyword">include</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">link_directories</span>(</span><br><span class="line">        /opt/homebrew/Cellar/jsoncpp/<span class="number">1.9</span>.<span class="number">5</span>/lib</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="keyword">test</span> main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="keyword">test</span> PRIVATE jsoncpp)</span><br></pre></td></tr></table></figure>

<p><strong>jsoncpp库的特点：</strong></p>
<ul>
<li>轻量级：JSON解析器和序列化器都非常快速，不会占用太多的CPU和内存资源</li>
<li>易于使用：提供简单的API，易于理解和使用</li>
<li>可靠性高：经过广泛测试，已被许多企业和开发者用于声生产环境中</li>
<li>开源免费：遵循MIT许可证发布，使用和修改均免费</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;json/json.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;json/value.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;json/reader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Json::Value root;</span><br><span class="line">	root[<span class="string">&quot;id&quot;</span>] = <span class="number">1001</span>;</span><br><span class="line">	root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	std::string request = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;request: &quot;</span> &lt;&lt; request &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	Json::Value root2;</span><br><span class="line">	Json::Reader reader;</span><br><span class="line">	reader.<span class="built_in">parse</span>(request, root2);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;msg id: &quot;</span> &lt;&lt; root2[<span class="string">&quot;id&quot;</span>] &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;msg data: &quot;</span> &lt;&lt; root2[<span class="string">&quot;data&quot;</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>jsoncpp在网络编程中的应用</strong></p>
<p>在客户端发送数据时对发送的数据进行序列化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client</span></span><br><span class="line">Json::Value root;</span><br><span class="line">root[<span class="string">&quot;id&quot;</span>] = <span class="number">1001</span>;</span><br><span class="line">root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">sts::string request = root.<span class="built_in">toStyleString</span>();</span><br><span class="line"><span class="type">size_t</span> request_length = request.<span class="built_in">length</span>();	<span class="comment">// 计算要发送的字节序长度</span></span><br><span class="line"><span class="type">char</span> send_data[MAX_LENGTH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 转为网络字节序</span></span><br><span class="line"><span class="type">int</span> request_host_length = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(request_length);</span><br><span class="line"><span class="built_in">memcpy</span>(send_data, &amp;request_host_length, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(send_data + <span class="number">2</span>, request.<span class="built_in">c_str</span>(), request_length);</span><br><span class="line">boost::asio::<span class="built_in">write</span>(sock, boost::asio::<span class="built_in">buffer</span>(send_data, request_length + <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>服务器接收到数据之后需要转换为本地字节序进行操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="type">char</span> reply_head[HEAD_LENGTH];</span><br><span class="line"><span class="type">size_t</span> reply_length = boost::asio::<span class="built_in">read</span>(socket, boost::asio::<span class="built_in">buffer</span>(reply_head, HEAD_LENGTH));</span><br><span class="line"><span class="type">short</span> msglen = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;msglen, reply_head, HEAD_LENGTH);</span><br><span class="line"><span class="comment">// 转为本地字节序</span></span><br><span class="line">msglen = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msglen);</span><br><span class="line"><span class="type">char</span> msg[MAX_LENGTH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">size_t</span> msg_length = boost::asio::<span class="built_in">read</span>(socket, boost::asio::<span class="built_in">buffer</span>(msg, msglen));</span><br><span class="line">Json::Reader reader;</span><br><span class="line">reader.<span class="built_in">parse</span>(std::<span class="built_in">string</span>(msg, msg_length), root);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;msg id: &quot;</span> &lt;&lt; root[]</span><br></pre></td></tr></table></figure>

<h4 id="服务器逻辑层设计和消息完善"><a href="#服务器逻辑层设计和消息完善" class="headerlink" title="服务器逻辑层设计和消息完善"></a>服务器逻辑层设计和消息完善</h4><p>本节概述了基于<code>boost::asio</code>实现的服务器逻辑层结构，并且完善之前设计的消息结构。因为为了简化粘包处理，我们简化了发送数据的结构，这次我们给出完整的消息设计，以及服务架构设计</p>
<p>在公司实际开发中，我们通常将逻辑系统设计为单线程模式，因为在逻辑系统操作时会读某些共享资源进行访问，如果设计为多线程模式就需要频繁的进行加锁和解锁，这样也会消耗大量资源，所以我们在设计逻辑系统是设计为单线程，例如Redis</p>
<p>父类中将默认构造函数和拷贝构造函数均置为private后，子类也就没有了默认构造和拷贝构造函数，子类就变成了单例类</p>
<div align="center">
    <img src="/2023/12/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/逻辑层.jpg" style="zoom: 50%" alt="逻辑层">
</div>
**消息头完善：**在之前的消息头仅包含数据与和长度，但是要进行逻辑处理，就需要传递一个id字段表示要处理的消息id，当然可以不在包首部传id字段，将id字段序列化到消息体也是可以的，但是我们为了便于处理也便于回调逻辑层对应函数，最好是将id写入包首部

<div align="center">
    <img src="/2023/12/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tlv消息格式.jpg" style="zoom: 50%" alt="tlv消息格式">
</div>

<p>为了减少耦合和歧义，重新设计消息节点</p>
<ul>
<li><code>MsgNode</code>：消息节点的基类，头部的消息用这个结构体储存</li>
<li><code>RecvNode</code>：接受消息节点</li>
<li><code>SendNode</code>：发送消息节点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> JSONSERVER_MSGNODE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JSONSERVER_MSGNODE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;boost/asio.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/JsonServer/const.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MsgNode</span>(<span class="type">short</span> max_len) : <span class="built_in">m_total_len</span>(max_len), <span class="built_in">m_cur_len</span>(<span class="number">0</span>) &#123;</span><br><span class="line">		m_data = <span class="keyword">new</span> <span class="type">char</span>[m_total_len + <span class="number">1</span>]();</span><br><span class="line">		m_data[m_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;destruct MsgNode&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">delete</span> m_data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::<span class="built_in">memset</span>(m_data, <span class="number">0</span>, m_total_len);</span><br><span class="line">		m_cur_len = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前长度</span></span><br><span class="line">	<span class="type">short</span> m_cur_len;</span><br><span class="line">	<span class="comment">// 总长度</span></span><br><span class="line">	<span class="type">short</span> m_total_len;</span><br><span class="line">	<span class="comment">// 数据域起始地址</span></span><br><span class="line">	<span class="type">char</span> *m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RecvNode</span> : <span class="keyword">public</span> MsgNode &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">RecvNode</span>(<span class="type">short</span> max_len, <span class="type">short</span> msg_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">short</span> m_msg_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SendNode</span> : <span class="keyword">public</span> MsgNode &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SendNode</span>(<span class="type">const</span> <span class="type">char</span> *msg, <span class="type">short</span> max_len, <span class="type">short</span> msg_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">short</span> m_msg_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//JSONSERVER_MSGNODE_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/JsonServer/MsgNode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">RecvNode::<span class="built_in">RecvNode</span>(<span class="type">short</span> max_len, <span class="type">short</span> msg_id) : <span class="built_in">MsgNode</span>(max_len), <span class="built_in">m_msg_id</span>(msg_id)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SendNode::<span class="built_in">SendNode</span>(<span class="type">const</span> <span class="type">char</span> *msg, <span class="type">short</span> max_len, <span class="type">short</span> msg_id) : <span class="built_in">MsgNode</span>(max_len + HEAD_TOTAL_LEN), <span class="built_in">m_msg_id</span>(msg_id)&#123;</span><br><span class="line">	<span class="comment">// 实现深拷贝将msg拷贝到m_data</span></span><br><span class="line">	<span class="comment">// 先发送id</span></span><br><span class="line">	<span class="type">short</span> msg_id_host = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(m_msg_id);</span><br><span class="line">	<span class="built_in">memcpy</span>(m_data, &amp;msg_id_host, HEAD_ID_LEN);</span><br><span class="line">	<span class="comment">// 在发送长度</span></span><br><span class="line">	<span class="type">short</span> msg_len_host = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(max_len);</span><br><span class="line">	<span class="built_in">memcpy</span>(m_data + HEAD_ID_LEN, &amp;msg_len_host, HEAD_DATA_LEN);</span><br><span class="line">	<span class="comment">// 拷贝消息体</span></span><br><span class="line">	<span class="built_in">memcpy</span>(m_data + HEAD_TOTAL_LEN, msg, max_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用单例逻辑实现逻辑类"><a href="#利用单例逻辑实现逻辑类" class="headerlink" title="利用单例逻辑实现逻辑类"></a>利用单例逻辑实现逻辑类</h4><p>我们可以发现在消息处理的逻辑层中使用了一种单例模式，通过该模式使得对处理队列中的数据是依次有序的，该模式也在Redis的开发中被应用</p>
<p><strong>单例模式：</strong></p>
<ul>
<li><p>局部静态变量</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过静态成员变量实现单例</span></span><br><span class="line"><span class="comment">// 懒汉式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Single2</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Single2</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Single2</span>(<span class="type">const</span> Single2 &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Single2 &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Single2 &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Single2 &amp;<span class="title">GetInst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Signle2 single;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  上述代码通过局部静态成员single实现单例类，原理就是函数的局部静态变量生命周期随着进程结束而结束，但是在多线程中可能会出现问题，其调用方法<code>&amp;Single2::GetInst()</code></p>
</li>
<li><p>静态成员变量指针方式</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 饿汉式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Single2Hungry</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Single2Hungry</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Single2Hungry</span>(<span class="type">const</span> Single2Hungry &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Single2Hungry &amp;<span class="keyword">operator</span>=(<span class="type">const</span> S  ingle2Hungry &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">static</span> Single2Hungry *single;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Single2Hungry *<span class="title">GetInst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (single == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            single = <span class="keyword">new</span> <span class="built_in">Single2Hungry</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  饿汉式对比懒汉式的好处在于避免了线程安全问题，无论是在多线程还是单线程模式下，通过静态成员变量的指针实现单例类都是唯一的。缺点是将内存释放交给了用户处理，其初始化方式<code>Single2Hungry *Single2Hungry::single = Single2Hungry::GetInst();</code></p>
</li>
<li><p>智能指针方式</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用智能指针解决释放问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleAuto</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleAuto</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">SingleAuto</span>(<span class="type">const</span> SingleAuto &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleAuto &amp;<span class="keyword">operator</span>=(<span class="type">const</span> SingleAuto &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;SingleAuto&gt; single;</span><br><span class="line">    <span class="type">static</span> mutex s_mutex;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">SingleAuto</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;single auto delete success &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;SingleAuto&gt; <span class="title">GetInst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (single != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        s_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (single != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        single = std::<span class="built_in">shared_ptr</span>&lt;SingleAuto&gt;(<span class="keyword">new</span> SingleAuto);</span><br><span class="line">        s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  SingleAuto的GetInst返回std::shared_ptr&lt;SingleAuto&gt;类型的变量single。因为single是静态成员变量，所以会在进程结束时被回收。智能指针被回收时会调用内置指针类型的析构函数，从而完成内存的回收。智能指针方式不存在内存泄露，但是有一个隐患就是单例类的析构函数是public的，如果被人手动调用会存在崩溃问题</p>
</li>
<li><p>辅助类智能指针单例模式</p>
<p>  智能指针在构造的时候可以指定删除器，所以可以传递一个辅助类或者辅助函数帮助智能指针回收内存时调用我们指定的析构函数</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// safe deletor</span></span><br><span class="line"><span class="comment">//防止外界delete</span></span><br><span class="line"><span class="comment">//声明辅助类</span></span><br><span class="line"><span class="comment">//该类定义仿函数调用SingleAutoSafe析构函数</span></span><br><span class="line"><span class="comment">//不可以提前声明SafeDeletor，编译时会提示incomplete type</span></span><br><span class="line"><span class="comment">// class SafeDeletor;</span></span><br><span class="line"><span class="comment">//所以要提前定义辅助类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleAutoSafe</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeDeletor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(SingleAutoSafe *sf)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is safe deleter operator()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> sf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleAutoSafe</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleAutoSafe</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">SingleAutoSafe</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is single auto safe deletor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SingleAutoSafe</span>(<span class="type">const</span> SingleAutoSafe &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleAutoSafe &amp;<span class="keyword">operator</span>=(<span class="type">const</span> SingleAutoSafe &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">//定义友元类，通过友元类调用该类析构函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">SafeDeletor</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;SingleAutoSafe&gt; <span class="title">GetInst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (single != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        s_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (single != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//额外指定删除器</span></span><br><span class="line">        single = std::<span class="built_in">shared_ptr</span>&lt;SingleAutoSafe&gt;(<span class="keyword">new</span> SingleAutoSafe, <span class="built_in">SafeDeletor</span>());</span><br><span class="line">        <span class="comment">//也可以指定删除函数</span></span><br><span class="line">        <span class="comment">// single = std::shared_ptr&lt;SingleAutoSafe&gt;(new SingleAutoSafe, SafeDelFunc);</span></span><br><span class="line">        s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;SingleAutoSafe&gt; single;</span><br><span class="line">    <span class="type">static</span> mutex s_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  SafeDeletor要写在SingleAutoSafe上边，并且SafeDeletor要声明为SingleAutoSafe类的友元类，这样就可以访问SingleAutoSafe的析构函数了<br>  我们在构造single时制定了SafeDeletor()，single在回收时，会调用SingleAutoSafe的仿函数，从而完成内存的销毁</p>
</li>
<li><p>通用的单例模版类</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Single_T</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Single_T</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Single_T</span>(<span class="type">const</span> Single_T&lt;T&gt; &amp;st) = <span class="keyword">delete</span>;</span><br><span class="line">    Single_T &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Single_T&lt;T&gt; &amp;st) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">Single_T</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is auto safe template destruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;T&gt; <span class="title">GetInst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (single != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        s_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (single != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//额外指定删除器</span></span><br><span class="line">        single = std::<span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T, <span class="built_in">SafeDeletor_T</span>&lt;T&gt;());</span><br><span class="line">        <span class="comment">//也可以指定删除函数</span></span><br><span class="line">        <span class="comment">// single = std::shared_ptr&lt;SingleAutoSafe&gt;(new SingleAutoSafe, SafeDelFunc);</span></span><br><span class="line">        s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;T&gt; single;</span><br><span class="line">    <span class="type">static</span> mutex s_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模板类的static成员要放在h文件里初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; Single_T&lt;T&gt;::single = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">mutex Single_T&lt;T&gt;::s_mutex;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>服务器代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./include/CServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> bStop = <span class="literal">false</span>;</span><br><span class="line">std::condition_variable condQuit;</span><br><span class="line">std::mutex mutexQuit;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SigHandler</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 收到cmd + z信号退出服务器</span></span><br><span class="line">	<span class="keyword">if</span> (sig == SIGINT || sig == SIGTERM) &#123;</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lockQuit</span><span class="params">(mutexQuit)</span></span>;</span><br><span class="line">		<span class="comment">// 改变退出所需要的全局变量, 唤醒主线程后, 主线程得以跳出循环</span></span><br><span class="line">		bStop = <span class="literal">true</span>;</span><br><span class="line">		lockQuit.<span class="built_in">unlock</span>();</span><br><span class="line">		<span class="comment">// 唤醒主线程</span></span><br><span class="line">		condQuit.<span class="built_in">notify_one</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 初始化ioContext</span></span><br><span class="line">		boost::asio::io_context ioContext;</span><br><span class="line">		<span class="comment">// 创建一个线程, 该线程用于管理网络层, 初始化服务, 启动服务</span></span><br><span class="line">		<span class="function">std::thread <span class="title">newWorkThread</span><span class="params">([&amp;ioContext] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">			Server server(ioContext, <span class="number">8888</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">			ioContext.run();</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line">		<span class="comment">// 将退出信号与退出函数绑定</span></span><br><span class="line">		<span class="built_in">signal</span>(SIGINT, SigHandler);</span><br><span class="line">		<span class="comment">// 如果停止按钮为false, 未收到退出信号, 将主线程挂起, 当收到唤醒信号时继续执行</span></span><br><span class="line">		<span class="keyword">while</span> (!bStop) &#123;</span><br><span class="line">			<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lockQuit</span><span class="params">(mutexQuit)</span></span>;</span><br><span class="line">			<span class="comment">// 使用条件变量等待退出锁</span></span><br><span class="line">			condQuit.<span class="built_in">wait</span>(lockQuit);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// bStop被改为true后, 主线程唤醒并使用asio提供的stop函数</span></span><br><span class="line">		ioContext.<span class="built_in">stop</span>();</span><br><span class="line">		<span class="comment">// 回收网络线程</span></span><br><span class="line">		newWorkThread.<span class="built_in">join</span>();</span><br><span class="line">	&#125; <span class="built_in">catch</span> (std::exception &amp;exception) &#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;exception: &quot;</span> &lt;&lt; exception.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CServer.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SERVER_CSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_CSERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Server</span>(boost::asio::io_context &amp;ioContext, <span class="type">short</span> port);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 擦除连接session的uuid</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ClearSession</span><span class="params">(std::string uuid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 回调函数, 用于等待客户端发来请求, 由asio底层进行调用</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HandleAccept</span><span class="params">(std::shared_ptr&lt;Session&gt; newSession, <span class="type">const</span> boost::system::error_code &amp;errorCode)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动网络服务</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">StartAccept</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	boost::asio::io_context &amp;m_ioContext;</span><br><span class="line">	<span class="type">short</span> m_port;</span><br><span class="line">	boost::asio::ip::tcp::acceptor m_acceptor;</span><br><span class="line">	std::map&lt;std::string, std::shared_ptr&lt;Session&gt;&gt; m_sessions;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//SERVER_CSERVER_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cserver.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/CServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Server::<span class="built_in">Server</span>(boost::asio::io_context &amp;ioContext, <span class="type">short</span> port) : <span class="built_in">m_ioContext</span>(ioContext), <span class="built_in">m_port</span>(port), <span class="built_in">m_acceptor</span>(ioContext, boost::asio::ip::tcp::<span class="built_in">endpoint</span>(boost::asio::ip::tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">	<span class="comment">// 创建一个网络层服务对象, 其含有启动服务器方法和接受</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Server start success, listen on port: &quot;</span> &lt;&lt; m_port &lt;&lt; std::endl;</span><br><span class="line">	<span class="comment">// 开始接受客户端发来请求</span></span><br><span class="line">	<span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::HandleAccept</span><span class="params">(std::shared_ptr&lt;Session&gt; newSession, <span class="type">const</span> boost::system::error_code &amp;errorCode)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!errorCode) &#123;</span><br><span class="line">		<span class="comment">// 没有错误, 将newSession的uuid加入到map中, 一个uuid对应一个session</span></span><br><span class="line">		newSession-&gt;<span class="built_in">Start</span>();</span><br><span class="line">		m_sessions.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(newSession-&gt;<span class="built_in">GetUuid</span>(), newSession));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;session accept failed, error is &quot;</span> &lt;&lt; errorCode.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::StartAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// newSession是一个会话, 需要使用ioContext和server</span></span><br><span class="line">	std::shared_ptr&lt;Session&gt; newSession = std::<span class="built_in">make_shared</span>&lt;Session&gt;(m_ioContext, <span class="keyword">this</span>);</span><br><span class="line">	m_acceptor.<span class="built_in">async_accept</span>(newSession-&gt;<span class="built_in">GetSocket</span>(), std::<span class="built_in">bind</span>(&amp;Server::HandleAccept, <span class="keyword">this</span>, newSession, std::placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::ClearSession</span><span class="params">(std::string uuid)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 将不使用的session从map中擦除</span></span><br><span class="line">	m_sessions.<span class="built_in">erase</span>(uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CSession.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SERVER_CSESSION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_CSESSION_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/reader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/value.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../utils/utils.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MessageNode.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LogicSystem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogicSystem</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Session&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Session</span>(boost::asio::io_context &amp;ioContext, Server *server);</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Session</span>();</span><br><span class="line"></span><br><span class="line">	boost::asio::ip::<span class="function">tcp::socket &amp;<span class="title">GetSocket</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string &amp;<span class="title">GetUuid</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">char</span> *message, <span class="type">short</span> maxLength, <span class="type">short</span> messageId)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(std::string message, <span class="type">short</span> messageId)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::shared_ptr&lt;Session&gt; <span class="title">SharedSelf</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;errorCode, <span class="type">size_t</span> bytesTransferred, std::shared_ptr&lt;Session&gt; sharedPtr)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;errorCode, std::shared_ptr&lt;Session&gt; sharedPtr)</span></span>;</span><br><span class="line"></span><br><span class="line">	boost::asio::ip::tcp::socket m_socket;</span><br><span class="line">	std::string m_uuid;</span><br><span class="line">	<span class="type">char</span> m_data[MAX_LENGTH];</span><br><span class="line">	Server *m_server;</span><br><span class="line">	<span class="type">bool</span> m_bClose;</span><br><span class="line">	std::queue&lt;std::shared_ptr&lt;SendNode&gt;&gt; m_sendQueue;</span><br><span class="line">	std::mutex m_sendLock;</span><br><span class="line">	<span class="comment">// 收到的消息结构</span></span><br><span class="line">	std::shared_ptr&lt;RecvNode&gt; m_recvMessageNode;</span><br><span class="line">	<span class="type">bool</span> m_bHeadParse;</span><br><span class="line">	<span class="comment">// 收到的头结构</span></span><br><span class="line">	std::shared_ptr&lt;MessageNode&gt; m_recvHeadNode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogicNode</span> &#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">LogicSystem</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">LogicNode</span>(std::shared_ptr&lt;Session&gt; session, std::shared_ptr&lt;RecvNode&gt; recvNode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::shared_ptr&lt;Session&gt; m_session;</span><br><span class="line">	std::shared_ptr&lt;RecvNode&gt; m_recvNode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//SERVER_CSESSION_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CSession.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/CServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Server::<span class="built_in">Server</span>(boost::asio::io_context &amp;ioContext, <span class="type">short</span> port) : <span class="built_in">m_ioContext</span>(ioContext), <span class="built_in">m_port</span>(port), <span class="built_in">m_acceptor</span>(ioContext, boost::asio::ip::tcp::<span class="built_in">endpoint</span>(boost::asio::ip::tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">	<span class="comment">// 创建一个网络层服务对象, 其含有启动服务器方法和接受</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Server start success, listen on port: &quot;</span> &lt;&lt; m_port &lt;&lt; std::endl;</span><br><span class="line">	<span class="comment">// 开始接受客户端发来请求</span></span><br><span class="line">	<span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::HandleAccept</span><span class="params">(std::shared_ptr&lt;Session&gt; newSession, <span class="type">const</span> boost::system::error_code &amp;errorCode)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!errorCode) &#123;</span><br><span class="line">		<span class="comment">// 没有错误, 将newSession的uuid加入到map中, 一个uuid对应一个session</span></span><br><span class="line">		newSession-&gt;<span class="built_in">Start</span>();</span><br><span class="line">		m_sessions.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(newSession-&gt;<span class="built_in">GetUuid</span>(), newSession));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;session accept failed, error is &quot;</span> &lt;&lt; errorCode.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::StartAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// newSession是一个会话, 需要使用ioContext和server</span></span><br><span class="line">	std::shared_ptr&lt;Session&gt; newSession = std::<span class="built_in">make_shared</span>&lt;Session&gt;(m_ioContext, <span class="keyword">this</span>);</span><br><span class="line">	m_acceptor.<span class="built_in">async_accept</span>(newSession-&gt;<span class="built_in">GetSocket</span>(), std::<span class="built_in">bind</span>(&amp;Server::HandleAccept, <span class="keyword">this</span>, newSession, std::placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::ClearSession</span><span class="params">(std::string uuid)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 将不使用的session从map中擦除</span></span><br><span class="line">	m_sessions.<span class="built_in">erase</span>(uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MessageNode.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SERVER_MESSAGENODE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_MESSAGENODE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../utils/utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MessageNode</span>(<span class="type">short</span> maxLen) : <span class="built_in">m_totalLen</span>(maxLen), <span class="built_in">m_currentLen</span>(<span class="number">0</span>) &#123;</span><br><span class="line">		m_data = <span class="keyword">new</span> <span class="type">char</span>[m_totalLen + <span class="number">1</span>]();</span><br><span class="line">		m_data[m_totalLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">MessageNode</span>() &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;destruct MessageNode&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">delete</span>[] m_data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::<span class="built_in">memset</span>(m_data, <span class="number">0</span>, m_totalLen);</span><br><span class="line">		m_currentLen = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">short</span> m_currentLen;</span><br><span class="line">	<span class="type">short</span> m_totalLen;</span><br><span class="line">	<span class="type">char</span> *m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RecvNode</span> : <span class="keyword">public</span> MessageNode &#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">LogicSystem</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">RecvNode</span>(<span class="type">short</span> maxLen, <span class="type">short</span> messageId);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">short</span> m_messageId;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SendNode</span> : <span class="keyword">public</span> MessageNode &#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">LogicSystem</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SendNode</span>(<span class="type">const</span> <span class="type">char</span> *message, <span class="type">short</span> maxLen, <span class="type">short</span> messageId);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">short</span> m_messageId;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//SERVER_MESSAGENODE_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MessageNode.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/MessageNode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">RecvNode::<span class="built_in">RecvNode</span>(<span class="type">short</span> maxLen, <span class="type">short</span> messageId) : <span class="built_in">MessageNode</span>(maxLen), <span class="built_in">m_messageId</span>(messageId) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SendNode::<span class="built_in">SendNode</span>(<span class="type">const</span> <span class="type">char</span> *message, <span class="type">short</span> maxLen, <span class="type">short</span> messageId): <span class="built_in">MessageNode</span>(maxLen + HEAD_TOTAL_LEN), <span class="built_in">m_messageId</span>(messageId) &#123;</span><br><span class="line">	<span class="comment">// 先发送id, 转为网络字节序</span></span><br><span class="line">	<span class="type">short</span> messageIdHost = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(messageId);</span><br><span class="line">	<span class="built_in">memcpy</span>(m_data, &amp;messageIdHost, HEAD_ID_LEN);</span><br><span class="line">	<span class="comment">// 再发送数据长度, 转为网络字节系</span></span><br><span class="line">	<span class="type">short</span> maxLenHost = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(maxLen);</span><br><span class="line">	<span class="built_in">memcpy</span>(m_data + HEAD_ID_LEN, &amp;maxLenHost, HEAD_DATA_LEN);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最后发送数据</span></span><br><span class="line">	<span class="built_in">memcpy</span>(m_data + HEAD_TOTAL_LEN, message, maxLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// LogicSystem.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SERVER_LOGICSYSTEM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_LOGICSYSTEM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/value.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/reader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Singleton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../utils/utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogicNode</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(std::shared_ptr&lt;Session&gt;, <span class="type">const</span> <span class="type">short</span> &amp;messageId, <span class="type">const</span> std::string &amp;messageData)&gt; FunCallBack;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogicSystem</span> : <span class="keyword">public</span> Singleton&lt;LogicSystem&gt; &#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;LogicSystem&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">LogicSystem</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PostMessageToQueue</span><span class="params">(std::shared_ptr&lt;LogicNode&gt; message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">LogicSystem</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DealMessage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">RegisterCallBacks</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HelloWorldCallBack</span><span class="params">(std::shared_ptr&lt;Session&gt;, <span class="type">const</span> <span class="type">short</span> &amp;messageId, <span class="type">const</span> std::string &amp;messageData)</span></span>;</span><br><span class="line"></span><br><span class="line">	std::thread m_workerThread;</span><br><span class="line">	std::queue&lt;std::shared_ptr&lt;LogicNode&gt;&gt; m_messageQueue;</span><br><span class="line">	std::mutex m_mutex;</span><br><span class="line">	std::condition_variable m_consume;</span><br><span class="line">	<span class="type">bool</span> m_bStop;</span><br><span class="line">	std::map&lt;<span class="type">short</span>, FunCallBack&gt; m_funcCallBacks;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//SERVER_LOGICSYSTEM_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// LogicSystem.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/LogicSystem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">LogicSystem::<span class="built_in">LogicSystem</span>() : <span class="built_in">m_bStop</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">	<span class="built_in">RegisterCallBacks</span>();</span><br><span class="line">	m_workerThread = std::<span class="built_in">thread</span>(&amp;LogicSystem::DealMessage, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LogicSystem::~<span class="built_in">LogicSystem</span>() &#123;</span><br><span class="line">	m_bStop = <span class="literal">true</span>;</span><br><span class="line">	m_consume.<span class="built_in">notify_one</span>();</span><br><span class="line">	m_workerThread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::PostMessageToQueue</span><span class="params">(std::shared_ptr&lt;LogicNode&gt; message)</span> </span>&#123;</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">uniqueLock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">	m_messageQueue.<span class="built_in">push</span>(message);</span><br><span class="line">	<span class="comment">// 当未处理的消息加入队列后队列变为1, 则通过锁可以启动</span></span><br><span class="line">	<span class="keyword">if</span> (m_messageQueue.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">		uniqueLock.<span class="built_in">unlock</span>();</span><br><span class="line">		m_consume.<span class="built_in">notify_one</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::DealMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">uniqueLock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">		<span class="comment">// 判断队列为空则条件变量阻塞等待, 并释放锁</span></span><br><span class="line">		<span class="keyword">while</span> (m_messageQueue.<span class="built_in">empty</span>() &amp;&amp; !m_bStop) &#123;</span><br><span class="line">			m_consume.<span class="built_in">wait</span>(uniqueLock);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断是否为关闭状态, 把所有逻辑执行完后则退出循环</span></span><br><span class="line">		<span class="keyword">if</span> (m_bStop) &#123;</span><br><span class="line">			<span class="keyword">while</span> (!m_messageQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">				<span class="keyword">auto</span> messageNode = m_messageQueue.<span class="built_in">front</span>();</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;recv message id is &quot;</span> &lt;&lt; messageNode-&gt;m_recvNode-&gt;m_messageId &lt;&lt; std::endl;</span><br><span class="line">				<span class="keyword">auto</span> callBackIter = m_funcCallBacks.<span class="built_in">find</span>(messageNode-&gt;m_recvNode-&gt;m_messageId);</span><br><span class="line">				<span class="keyword">if</span> (callBackIter == m_funcCallBacks.<span class="built_in">end</span>()) &#123;</span><br><span class="line">					m_messageQueue.<span class="built_in">pop</span>();</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				callBackIter-&gt;<span class="built_in">second</span>(messageNode-&gt;m_session, messageNode-&gt;m_recvNode-&gt;m_messageId, std::<span class="built_in">string</span>(messageNode-&gt;m_recvNode-&gt;m_data, messageNode-&gt;m_recvNode-&gt;m_currentLen));</span><br><span class="line">				m_messageQueue.<span class="built_in">pop</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果没有停服, 且说明队列中有数据</span></span><br><span class="line">		<span class="keyword">auto</span> messageNode = m_messageQueue.<span class="built_in">front</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;recv message id is &quot;</span> &lt;&lt; messageNode-&gt;m_recvNode-&gt;m_messageId &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">auto</span> callBackIter = m_funcCallBacks.<span class="built_in">find</span>(messageNode-&gt;m_recvNode-&gt;m_messageId);</span><br><span class="line">		<span class="keyword">if</span> (callBackIter == m_funcCallBacks.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			m_messageQueue.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		callBackIter-&gt;<span class="built_in">second</span>(messageNode-&gt;m_session, messageNode-&gt;m_recvNode-&gt;m_messageId, std::<span class="built_in">string</span>(messageNode-&gt;m_recvNode-&gt;m_data, messageNode-&gt;m_recvNode-&gt;m_currentLen));</span><br><span class="line">		m_messageQueue.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::RegisterCallBacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	m_funcCallBacks[MESSAGE_HELLO_WORLD] = std::<span class="built_in">bind</span>(&amp;LogicSystem::HelloWorldCallBack, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::HelloWorldCallBack</span><span class="params">(std::shared_ptr&lt;Session&gt; session, <span class="type">const</span> <span class="type">short</span> &amp;messageId, <span class="type">const</span> std::string &amp;messageData)</span> </span>&#123;</span><br><span class="line">	Json::Reader reader;</span><br><span class="line">	Json::Value root;</span><br><span class="line">	reader.<span class="built_in">parse</span>(messageData, root);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;recevie message id &quot;</span> &lt;&lt; root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>() &lt;&lt; <span class="string">&quot;message data is &quot;</span> &lt;&lt; root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>() &lt;&lt; std::endl;</span><br><span class="line">	root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;server had received message, message data is &quot;</span> + root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">	std::string returnString = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">	session-&gt;<span class="built_in">Send</span>(returnString, root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Singleton.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SERVER_SINGLETON_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_SINGLETON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton&lt;T&gt; &amp;st) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> std::shared_ptr&lt;T&gt; m_instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> std::shared_ptr&lt;T&gt; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="type">static</span> std::once_flag s_flag;</span><br><span class="line">		std::<span class="built_in">call_once</span>(s_flag, [&amp;]() &#123;</span><br><span class="line">			m_instance = std::<span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T);</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">return</span> m_instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;this is singleton destruct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; Singleton&lt;T&gt;::m_instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//SERVER_SINGLETON_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// utils.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SERVER_UTILS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_UTILS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LENGTH 1024 * 2</span></span><br><span class="line"><span class="comment">// 头部总长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAD_TOTAL_LEN 4</span></span><br><span class="line"><span class="comment">// 头部ID长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAD_ID_LEN 2</span></span><br><span class="line"><span class="comment">// 头部数据长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAD_DATA_LEN 2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_RECVQUE 10000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SENDQUE 1000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MSG_IDS</span> &#123;</span><br><span class="line">	MESSAGE_HELLO_WORLD = <span class="number">1001</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//SERVER_UTILS_H</span></span></span><br></pre></td></tr></table></figure>

<p>目录结构</p>
<blockquote>
<p>Server</p>
<blockquote>
<p>builds</p>
<p>cmake-build-debug</p>
<p>doc</p>
<p>include</p>
<blockquote>
<p>CServer.h</p>
<p>CSession.h</p>
<p>LogicSystem.h</p>
<p>Singleton.h</p>
<p>MessageNode.h</p>
</blockquote>
<p>src</p>
<blockquote>
<p>CServer.cpp</p>
<p>CSession.cpp</p>
<p>LogicSystem.cpp</p>
<p>MessageNode.cpp</p>
</blockquote>
<p>utils</p>
<blockquote>
<p>utils.h</p>
</blockquote>
<p>CMakeLists.txt</p>
<p>main.cpp</p>
</blockquote>
</blockquote>
<h4 id="asio多线程模型IOServicePool"><a href="#asio多线程模型IOServicePool" class="headerlink" title="asio多线程模型IOServicePool"></a>asio多线程模型IOServicePool</h4><p><strong>简介：</strong>前面的设计，我们对asio的使用都是单线程模式，为了提升网络IO并发处理效率，这一次我们设计多线程模式下asio的使用方式，总体来说asio有两个多线程模型，第一个是起启动多线程，每个线程管理一个ioContext；第二个是只启动一个ioContext，被多个线程共享。下面我们会提到文章对比两个模式区别</p>
<p><strong>单线程和多线程对比：</strong></p>
<div align="center">
    <img src="/2023/12/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/asio单线程模式图.jpg" style="zoom: 50%" alt="单线程模式">
</div>

<div align="center">
    <img src="/2023/12/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/IOServicePool多线程模式.jpg" style="zoom: 50%" alt="多线程模式">
</div>

<p>IOServicePool多线程模式特点：</p>
<ul>
<li>每一个io_context跑在不同的线程中，所以同一个socket会被注册在同一个io_context里，它的回调函数也会被单独的一个线程回调，那么对于同一个socket，他的回调函数每次出发都是在同一个线程里，就不会有线程安全问题，网络io层面上的并发是线程安全的</li>
<li>对于不同的socket，回到函数的触发可能是同一个线程（两个socket被分配到同一个io_context），也不可能不是同一个线程（两个socket被分配到不同的io_context里）。所以如果两个socket对应的上层逻辑处理，如果有交互或者访问共享区，会存在线程安全问题。比如socket1代表玩家1，socket代表玩家2，玩家1和玩家2在逻辑层存在交互，比如两个玩家都在做工会任务，他们属于同一个工会，工会积分的增加就是共享区的数据，需要保证线程安全。可以通过加锁或者逻辑队列的方式解决安全问题，我们目前采取了后者</li>
<li>多线程相比单线程极大的提高了并发能力，因为单线程仅有一个io_context服务用来监听读写时间，就绪后回调函数在一个线程里串行调用，如果一个回调函数的调用时间较长肯定会影响后续的函数调用，毕竟是串行调用。而采用多线程方式，可以在一定程度上减少前一个逻辑调用影响下一个逻辑调用的情况，比如两个socket被部署到不同的io_context上，但是当两个socket部署到同一个io_context上时仍然存在调用时间影响的问题。不过我们已经通过逻辑队列的方式将网络线程和逻辑线程耦合了，不会出现前一个调用时间影响下一个回调出发的问题</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Notes/">Notes</a><a class="post-meta__tags" href="/tags/DataBase/">DataBase</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/11/03/ROS/"><img class="next-cover" src="https://d2908q01vomqb2.cloudfront.net/ca3512f4dfa95a03169c5a670a4c91a19b3077b4/2018/11/26/ros-logo.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">ROS基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/02/15/Golang/" title="Golang"><img class="cover" src="http://5b0988e595225.cdn.sohucs.com/images/20190127/98d2709000f649198967eb6e91d26a1a.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-15</div><div class="title">Golang</div></div></a></div><div><a href="/2023/01/30/MySQL%E5%9F%BA%E7%A1%80/" title="MySQL"><img class="cover" src="https://upload.wikimedia.org/wikipedia/zh/thumb/6/62/MySQL.svg/1200px-MySQL.svg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-30</div><div class="title">MySQL</div></div></a></div><div><a href="/2023/02/27/Docker/" title="Docker"><img class="cover" src="https://www.ondat.io/hubfs/Docker.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-27</div><div class="title">Docker</div></div></a></div><div><a href="/2023/03/14/C++/" title="C++"><img class="cover" src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/ISO_C%2B%2B_Logo.svg/1200px-ISO_C%2B%2B_Logo.svg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-14</div><div class="title">C++</div></div></a></div><div><a href="/2023/02/06/Flask/" title="Flask"><img class="cover" src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3c/Flask_logo.svg/1200px-Flask_logo.svg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-06</div><div class="title">Flask</div></div></a></div><div><a href="/2023/03/16/CMake/" title="CMake"><img class="cover" src="https://www.kitware.com/main/wp-content/uploads/2016/11/CMake-Logo-and-Text-e1540917038464.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-16</div><div class="title">CMake</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/day.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">santidad DAY</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">17</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/santidadday" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">网络基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">协议的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.1.2.</span> <span class="toc-text">典型协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">网络应用程序设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">分层模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">OSI七层模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-x2F-IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">TCP&#x2F;IP四层模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">通信过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.5.</span> <span class="toc-text">协议格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8C%85%E5%B0%81%E8%A3%85"><span class="toc-number">1.5.1.</span> <span class="toc-text">数据包封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">以太网帧格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ARP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.5.3.</span> <span class="toc-text">ARP数据报格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IP%E6%AE%B5%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.5.4.</span> <span class="toc-text">IP段格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.5.5.</span> <span class="toc-text">UDP数据报格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.5.6.</span> <span class="toc-text">TCP数据报格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.6.</span> <span class="toc-text">TCP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E9%80%9A%E4%BF%A1%E6%97%B6%E5%BA%8F"><span class="toc-number">1.6.1.</span> <span class="toc-text">TCP通信时序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.6.2.</span> <span class="toc-text">TCP状态转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket%E7%BC%96%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">Socket编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">套接字概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="toc-number">2.2.</span> <span class="toc-text">预备知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">网络字节序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">IP地址转换函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sockaddr%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.3.</span> <span class="toc-text">sockaddr数据结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%A5%97%E6%8E%A5%E5%AD%97%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">网络套接字函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#socket%E6%A8%A1%E5%9E%8B%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">2.3.1.</span> <span class="toc-text">socket模型创建流程图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#socket%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.2.</span> <span class="toc-text">socket函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bind%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.3.</span> <span class="toc-text">bind函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#listen%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.4.</span> <span class="toc-text">listen函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#accept%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.5.</span> <span class="toc-text">accept函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#connect%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.6.</span> <span class="toc-text">connect函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-x2F-S%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">C&#x2F;S模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#server"><span class="toc-number">2.4.1.</span> <span class="toc-text">server</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#client"><span class="toc-number">2.4.2.</span> <span class="toc-text">client</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">高并发服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.1.</span> <span class="toc-text">多进程并发服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#server-x2F-client"><span class="toc-number">3.1.1.</span> <span class="toc-text">server&#x2F;client</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">多线程并发服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#server-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">server</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#client-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">client</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AFI-x2F-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">多路I&#x2F;O转接服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#select"><span class="toc-number">3.3.1.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#poll"><span class="toc-number">3.3.2.</span> <span class="toc-text">poll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll"><span class="toc-number">3.3.3.</span> <span class="toc-text">epoll</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">事件模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ET%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.1.</span> <span class="toc-text">ET模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LT%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.2.</span> <span class="toc-text">LT模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LT%E4%B8%8EET%E6%AF%94%E8%BE%83"><span class="toc-number">3.4.3.</span> <span class="toc-text">LT与ET比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.5.</span> <span class="toc-text">epoll反应堆模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.6.</span> <span class="toc-text">线程池模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.7.</span> <span class="toc-text">UDP服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-x2F-S%E6%A8%A1%E5%9E%8B-UDP"><span class="toc-number">3.8.</span> <span class="toc-text">C&#x2F;S模型-UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#server-2"><span class="toc-number">3.8.1.</span> <span class="toc-text">server</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#client-2"><span class="toc-number">3.8.2.</span> <span class="toc-text">client</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#asio%E5%BA%93%E9%AB%98%E7%BA%A7"><span class="toc-number">3.9.</span> <span class="toc-text">asio库高级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E8%AF%BB%E5%86%99"><span class="toc-number">3.9.1.</span> <span class="toc-text">同步读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%AF%BB%E5%86%99"><span class="toc-number">3.9.2.</span> <span class="toc-text">异步读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%BC%AA%E9%97%AD%E5%8C%85%E5%BB%B6%E9%95%BF%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.9.3.</span> <span class="toc-text">利用伪闭包延长生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E5%8F%91%E9%80%81%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%8F%8C%E5%B7%A5%E9%80%9A%E4%BF%A1"><span class="toc-number">3.9.4.</span> <span class="toc-text">增加发送队列实现全双工通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">3.9.5.</span> <span class="toc-text">粘包问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%BA%8F%E5%A4%84%E7%90%86%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">3.9.6.</span> <span class="toc-text">字节序处理和消息队列的控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#protobuf%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">3.9.7.</span> <span class="toc-text">protobuf配置和使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jsoncpp%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">3.9.8.</span> <span class="toc-text">jsoncpp配置和使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%BB%E8%BE%91%E5%B1%82%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%B6%88%E6%81%AF%E5%AE%8C%E5%96%84"><span class="toc-number">3.9.9.</span> <span class="toc-text">服务器逻辑层设计和消息完善</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8D%95%E4%BE%8B%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91%E7%B1%BB"><span class="toc-number">3.9.10.</span> <span class="toc-text">利用单例逻辑实现逻辑类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#asio%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8BIOServicePool"><span class="toc-number">3.9.11.</span> <span class="toc-text">asio多线程模型IOServicePool</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="Linux网络编程"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux网络编程"/></a><div class="content"><a class="title" href="/2023/12/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="Linux网络编程">Linux网络编程</a><time datetime="2023-11-30T16:00:00.000Z" title="Created 2023-12-01 00:00:00">2023-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/03/ROS/" title="ROS基础"><img src="https://d2908q01vomqb2.cloudfront.net/ca3512f4dfa95a03169c5a670a4c91a19b3077b4/2018/11/26/ros-logo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ROS基础"/></a><div class="content"><a class="title" href="/2023/11/03/ROS/" title="ROS基础">ROS基础</a><time datetime="2023-11-02T16:00:00.000Z" title="Created 2023-11-03 00:00:00">2023-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/04/C++11/" title="C++11"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/ISO_C%2B%2B_Logo.svg/1200px-ISO_C%2B%2B_Logo.svg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++11"/></a><div class="content"><a class="title" href="/2023/07/04/C++11/" title="C++11">C++11</a><time datetime="2023-07-03T16:00:00.000Z" title="Created 2023-07-04 00:00:00">2023-07-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" title="Linux系统编程"><img src="https://file.rymooc.com/SuperLargeCover/200303ae51194686d43e" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux系统编程"/></a><div class="content"><a class="title" href="/2023/06/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" title="Linux系统编程">Linux系统编程</a><time datetime="2023-06-19T16:00:00.000Z" title="Created 2023-06-20 00:00:00">2023-06-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/11/C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="C++设计模式"><img src="https://picx.zhimg.com/v2-f7e5e75bb391e9c74762d9dbee97f807_720w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++设计模式"/></a><div class="content"><a class="title" href="/2023/05/11/C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="C++设计模式">C++设计模式</a><time datetime="2023-05-10T16:00:00.000Z" title="Created 2023-05-11 00:00:00">2023-05-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2025 By santidad DAY</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">welcome  to  my  <a  target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>